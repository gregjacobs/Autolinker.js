{"version":3,"sources":["Autolinker.js","es2015/utils.js","es2015/truncate/truncate-smart.js","es2015/truncate/truncate-middle.js","es2015/truncate/truncate-end.js","es2015/html-tag.js","es2015/anchor-tag-builder.js","es2015/htmlParser/html-node.js","es2015/htmlParser/comment-node.js","es2015/htmlParser/element-node.js","es2015/htmlParser/entity-node.js","es2015/htmlParser/text-node.js","es2015/htmlParser/html-parser.js","es2015/match/match.js","es2015/match/email-match.js","es2015/match/hashtag-match.js","es2015/match/mention-match.js","es2015/match/phone-match.js","es2015/match/url-match.js","es2015/matcher/matcher.js","es2015/regex-lib.js","es2015/matcher/tld-regex.js","es2015/matcher/email-matcher.js","es2015/matcher/url-match-validator.js","es2015/matcher/url-matcher.js","es2015/matcher/hashtag-matcher.js","es2015/matcher/phone-matcher.js","es2015/matcher/mention-matcher.js","es2015/autolinker.js"],"names":["global","factory","exports","module","define","amd","self","Autolinker","this","defaults","dest","src","prop","hasOwnProperty","undefined","ellipsis","str","truncateLen","ellipsisChars","ellipsisLength","length","substring","indexOf","arr","element","Array","prototype","i","len","remove","fn","splice","splitAndCapture","splitRegex","Error","match","result","lastIdx","exec","push","index","truncateSmart","url","ellipsisLengthBeforeParsing","parse_url","urlObj","urlSub","scheme","substr","host","path","query","fragment","buildUrl","buildSegment","segment","remainingAvailableLength","remainingAvailableLengthHalf","startOffset","Math","ceil","endOffset","floor","end","availableLength","matchQuery","replace","pathAndQuery","remainingAvailableLength2","truncateMiddle","truncateEnd","anchorText","HtmlTag","cfg","whitespaceRegex","tagName","attrs","innerHTML","innerHtml","setTagName","getTagName","setAttr","attrName","attrValue","tagAttrs","getAttrs","getAttr","setAttrs","Object","assign","setClass","cssClass","addClass","newClass","classAttr","getClass","classes","split","newClasses","shift","join","removeClass","removeClasses","idx","hasClass","setInnerHTML","html","setInnerHtml","getInnerHTML","getInnerHtml","toAnchorString","attrsStr","buildAttrsStr","attrsArr","AnchorTagBuilder","newWindow","truncate","className","build","createAttrs","processAnchorText","getAnchorText","href","getAnchorHref","createCssClass","returnClasses","cssClassSuffixes","getCssClassSuffixes","doTruncate","truncateLength","truncateLocation","location","HtmlNode","offset","text","getOffset","getText","__extends","extendStatics","d","b","setPrototypeOf","__proto__","p","__","constructor","create","CommentNode","_super","_this","call","comment","getType","getComment","ElementNode","closing","isClosing","EntityNode","apply","arguments","TextNode","htmlRegex","commentTagRegex","tagNameRegex","attrNameRegex","attrValueRegex","optionalAttrValueRegex","source","getNameEqualsValueRegex","group","RegExp","htmlCharacterEntitiesRegex","HtmlParser","parse","currentResult","textAndEntityNodes","lastIndex","nodes","tagText","commentText","isClosingTag","inBetweenTagsText","parseTextAndEntityNodes","createCommentNode","createElementNode","forEach","node","textAndEntityTokens","textToken","entityToken","createTextNode","createEntityNode","trim","toLowerCase","Match","tagBuilder","matchedText","getMatchedText","setOffset","buildTag","EmailMatch","email","getEmail","HashtagMatch","serviceName","hashtag","getServiceName","getHashtag","MentionMatch","mention","getMention","PhoneMatch","number","plusSign","getNumber","UrlMatch","schemePrefixRegex","wwwPrefixRegex","protocolRelativeRegex","protocolPrepended","urlMatchType","protocolUrlMatch","protocolRelativeMatch","stripPrefix","stripTrailingSlash","decodePercentEncoding","getUrlMatchType","getUrl","stripProtocolRelativePrefix","stripSchemePrefix","www","stripWwwPrefix","removeTrailingSlash","removePercentEncoding","charAt","slice","decodeURIComponent","e","Matcher","alphaCharsStr","decimalNumbersStr","alphaNumericCharsStr","ipStr","domainLabelStr","getDomainLabelStr","getDomainNameStr","tldRegex","EmailMatcher","matcherRegex","alphaNumericChars","specialCharacters","restrictedSpecialCharacters","validCharacters","validRestrictedCharacters","emailRegex","parseMatches","matches","UrlMatchValidator","isValid","urlMatch","isValidUriScheme","urlMatchDoesNotHaveProtocolOrDot","urlMatchDoesNotHaveAtLeastOneWordChar","isValidIpAddress","containsMultipleDots","uriSchemeMatch","newRegex","hasFullProtocolRegex","ipRegex","uriScheme","stringBeforeSlash","test","uriSchemeMatchArr","uriSchemeRegex","hasWordCharAfterProtocolRegex","UrlMatcher","schemeRegex","wwwRegex","urlSuffixRegex","wordCharRegExp","openParensRe","closeParensRe","matchStr","schemeUrlMatch","wwwUrlMatch","wwwProtocolRelativeMatch","tldProtocolRelativeMatch","prevChar","matchHasUnbalancedClosingParen","pos","matchHasInvalidCharAfterTld","lastChar","openParensMatch","closeParensMatch","numOpenParens","numCloseParens","re","res","HashtagMatcher","nonWordCharRegex","PhoneMatcher","cleanNumber","before","after","contextClear","testMatch","MentionMatcher","matcherRegexes","twitter","instagram","soundcloud","version","urls","normalizeUrlsCfg","phone","normalizeStripPrefixCfg","normalizeTruncateCfg","replaceFn","context","htmlParser","matchers","link","textOrHtml","options","autolinker","schemeMatches","wwwMatches","tldMatches","Number","POSITIVE_INFINITY","htmlNodes","anchorTagStackCount","nodeType","max","textNodeMatches","parseText","compactMatches","removeUnwantedMatches","sort","a","matchedTextLength","endIdx","removeIdx","m","getMatchers","numMatchers","textMatches","j","numTextMatches","newHtml","createMatchReturnVal","replaceFnResult","anchorTag","getTagBuilder","matcher","Email","Hashtag","Mention","Phone","Url"],"mappings":";;;;;;;;;CASC,SAAUA,EAAQC,GACI,gBAAZC,UAA0C,mBAAXC,QAAyBA,OAAOD,QAAUD,IAC9D,kBAAXG,SAAyBA,OAAOC,IAAMD,OAAOH,IACnDD,EAASA,GAAUM,KAAMN,EAAOO,WAAaN,MAChDO,KAAM,WAAc,YCLf,SAASC,GAASC,EAAMC,GAC3B,IAAK,GAAIC,KAAQD,GACTA,EAAIE,eAAeD,IAAwBE,SAAfJ,EAAKE,KACjCF,EAAKE,GAAQD,EAAIC,GAGzB,OAAOF,GAYJ,QAASK,GAASC,EAAKC,EAAaC,GACvC,GAAIC,EAWJ,OAVIH,GAAII,OAASH,IACQ,MAAjBC,GACAA,EAAgB,WAChBC,EAAiB,GAGjBA,EAAiBD,EAAcE,OAEnCJ,EAAMA,EAAIK,UAAU,EAAGJ,EAAcE,GAAkBD,GAEpDF,EASJ,QAASM,GAAQC,EAAKC,GACzB,GAAIC,MAAMC,UAAUJ,QAChB,MAAOC,GAAID,QAAQE,EAGnB,KAAK,GAAIG,GAAI,EAAGC,EAAML,EAAIH,OAAQO,EAAIC,EAAKD,IACvC,GAAIJ,EAAII,KAAOH,EACX,MAAOG,EAEf,UAiBD,QAASE,GAAON,EAAKO,GACxB,IAAK,GAAIH,GAAIJ,EAAIH,OAAS,EAAGO,GAAK,EAAGA,IAC7BG,EAAGP,EAAII,OAAQ,GACfJ,EAAIQ,OAAOJ,EAAG,GA2BnB,QAASK,GAAgBhB,EAAKiB,GACjC,IAAKA,EAAWjC,OACZ,KAAM,IAAIkC,OAAM,0CAEpB,KADA,GAA8BC,GAA1BC,KAAaC,EAAU,EACpBF,EAAQF,EAAWK,KAAKtB,IAC3BoB,EAAOG,KAAKvB,EAAIK,UAAUgB,EAASF,EAAMK,QACzCJ,EAAOG,KAAKJ,EAAM,IAClBE,EAAUF,EAAMK,MAAQL,EAAM,GAAGf,MAGrC,OADAgB,GAAOG,KAAKvB,EAAIK,UAAUgB,IACnBD,ECrGJ,QAASK,GAAcC,EAAKzB,EAAaC,GAC5C,GAAIyB,GACAxB,CACiB,OAAjBD,GACAA,EAAgB,WAChBC,EAAiB,EACjBwB,EAA8B,IAG9BxB,EAAiBD,EAAcE,OAC/BuB,EAA8BzB,EAAcE,OAEhD,IAAIwB,GAAY,SAAUF,GACtB,GAAIG,MACAC,EAASJ,EACTP,EAAQW,EAAOX,MAAM,kBAyBzB,OAxBIA,KACAU,EAAOE,OAASZ,EAAM,GACtBW,EAASA,EAAOE,OAAOb,EAAM,GAAGf,SAEpCe,EAAQW,EAAOX,MAAM,0BACjBA,IACAU,EAAOI,KAAOd,EAAM,GACpBW,EAASA,EAAOE,OAAOb,EAAM,GAAGf,SAEpCe,EAAQW,EAAOX,MAAM,yBACjBA,IACAU,EAAOK,KAAOf,EAAM,GACpBW,EAASA,EAAOE,OAAOb,EAAM,GAAGf,SAEpCe,EAAQW,EAAOX,MAAM,sBACjBA,IACAU,EAAOM,MAAQhB,EAAM,GACrBW,EAASA,EAAOE,OAAOb,EAAM,GAAGf,SAEpCe,EAAQW,EAAOX,MAAM,aACjBA,IACAU,EAAOO,SAAWjB,EAAM,IAGrBU,GAEPQ,EAAW,SAAUR,GACrB,GAAIH,GAAM,EAgBV,OAfIG,GAAOE,QAAUF,EAAOI,OACxBP,GAAOG,EAAOE,OAAS,OAEvBF,EAAOI,OACPP,GAAOG,EAAOI,MAEdJ,EAAOK,OACPR,GAAO,IAAMG,EAAOK,MAEpBL,EAAOM,QACPT,GAAO,IAAMG,EAAOM,OAEpBN,EAAOO,WACPV,GAAO,IAAMG,EAAOO,UAEjBV,GAEPY,EAAe,SAAUC,EAASC,GAClC,GAAIC,GAA+BD,EAA2B,EAAGE,EAAcC,KAAKC,KAAKH,GAA+BI,KAAmBF,KAAKG,MAAML,GAA+BM,EAAM,EAI3L,OAHIF,GAAY,IACZE,EAAMR,EAAQP,OAAOa,IAElBN,EAAQP,OAAO,EAAGU,GAAexC,EAAgB6C,EAE5D,IAAIrB,EAAItB,QAAUH,EACd,MAAOyB,EAEX,IAAIsB,GAAkB/C,EAAcE,EAChC0B,EAASD,EAAUF,EAEvB,IAAIG,EAAOM,MAAO,CACd,GAAIc,GAAapB,EAAOM,MAAMhB,MAAM,2BAChC8B,KAEApB,EAAOM,MAAQN,EAAOM,MAAMH,OAAO,EAAGiB,EAAW,GAAG7C,QACpDsB,EAAMW,EAASR,IAGvB,GAAIH,EAAItB,QAAUH,EACd,MAAOyB,EAMX,IAJIG,EAAOI,OACPJ,EAAOI,KAAOJ,EAAOI,KAAKiB,QAAQ,SAAU,IAC5CxB,EAAMW,EAASR,IAEfH,EAAItB,QAAUH,EACd,MAAOyB,EAGX,IAAI1B,GAAM,EAIV,IAHI6B,EAAOI,OACPjC,GAAO6B,EAAOI,MAEdjC,EAAII,QAAU4C,EACd,MAAInB,GAAOI,KAAK7B,QAAUH,GACd4B,EAAOI,KAAKD,OAAO,EAAI/B,EAAcE,GAAmBD,GAAe8B,OAAO,EAAGgB,EAAkBrB,GAExGW,EAAatC,EAAKgD,GAAiBhB,OAAO,EAAGgB,EAAkBrB,EAE1E,IAAIwB,GAAe,EAOnB,IANItB,EAAOK,OACPiB,GAAgB,IAAMtB,EAAOK,MAE7BL,EAAOM,QACPgB,GAAgB,IAAMtB,EAAOM,OAE7BgB,EAAc,CACd,IAAKnD,EAAMmD,GAAc/C,QAAU4C,EAAiB,CAChD,IAAKhD,EAAMmD,GAAc/C,QAAUH,EAC/B,OAAQD,EAAMmD,GAAcnB,OAAO,EAAG/B,EAE1C,IAAIuC,GAA2BQ,EAAkBhD,EAAII,MACrD,QAAQJ,EAAMsC,EAAaa,EAAcX,IAA2BR,OAAO,EAAGgB,EAAkBrB,GAGhG3B,GAAOmD,EAGf,GAAItB,EAAOO,SAAU,CACjB,GAAIA,GAAW,IAAMP,EAAOO,QAC5B,KAAKpC,EAAMoC,GAAUhC,QAAU4C,EAAiB,CAC5C,IAAKhD,EAAMoC,GAAUhC,QAAUH,EAC3B,OAAQD,EAAMoC,GAAUJ,OAAO,EAAG/B,EAEtC,IAAImD,GAA4BJ,EAAkBhD,EAAII,MACtD,QAAQJ,EAAMsC,EAAaF,EAAUgB,IAA4BpB,OAAO,EAAGgB,EAAkBrB,GAG7F3B,GAAOoC,EAGf,GAAIP,EAAOE,QAAUF,EAAOI,KAAM,CAC9B,GAAIF,GAASF,EAAOE,OAAS,KAC7B,KAAK/B,EAAM+B,GAAQ3B,OAAS4C,EACxB,OAAQjB,EAAS/B,GAAKgC,OAAO,EAAG/B,GAGxC,GAAID,EAAII,QAAUH,EACd,MAAOD,EAEX,IAAI+C,GAAM,EAIV,OAHIC,GAAkB,IAClBD,EAAM/C,EAAIgC,UAAcW,KAAKG,MAAME,EAAkB,MAEjDhD,EAAIgC,OAAO,EAAGW,KAAKC,KAAKI,EAAkB,IAAM9C,EAAgB6C,GAAKf,OAAO,EAAGgB,EAAkBrB,GCrJtG,QAAS0B,GAAe3B,EAAKzB,EAAaC,GAC7C,GAAIwB,EAAItB,QAAUH,EACd,MAAOyB,EAEX,IAAIC,GACAxB,CACiB,OAAjBD,GACAA,EAAgB,WAChByB,EAA8B,EAC9BxB,EAAiB,IAGjBwB,EAA8BzB,EAAcE,OAC5CD,EAAiBD,EAAcE,OAEnC,IAAI4C,GAAkB/C,EAAcE,EAChC4C,EAAM,EAIV,OAHIC,GAAkB,IAClBD,EAAMrB,EAAIM,UAAcW,KAAKG,MAAME,EAAkB,MAEjDtB,EAAIM,OAAO,EAAGW,KAAKC,KAAKI,EAAkB,IAAM9C,EAAgB6C,GAAKf,OAAO,EAAGgB,EAAkBrB,GCtBtG,QAAS2B,GAAYC,EAAYtD,EAAaC,GACjD,MAAOH,GAASwD,EAAYtD,EAAaC,GCiE7C,GAAIsD,GAAyB,WAKzB,QAASA,GAAQC,GACD,SAARA,IAAkBA,MAOtBjE,KAAKkE,gBAAkB,MACvBlE,KAAKmE,QAAUF,EAAIE,SAAW,GAC9BnE,KAAKoE,MAAQH,EAAIG,UACjBpE,KAAKqE,UAAYJ,EAAIK,WAAaL,EAAII,WAAa,GAsLvD,MA9KAL,GAAQ9C,UAAUqD,WAAa,SAAUJ,GAErC,MADAnE,MAAKmE,QAAUA,EACRnE,MAOXgE,EAAQ9C,UAAUsD,WAAa,WAC3B,MAAOxE,MAAKmE,SAAW,IAS3BH,EAAQ9C,UAAUuD,QAAU,SAAUC,EAAUC,GAC5C,GAAIC,GAAW5E,KAAK6E,UAEpB,OADAD,GAASF,GAAYC,EACd3E,MAQXgE,EAAQ9C,UAAU4D,QAAU,SAAUJ,GAClC,MAAO1E,MAAK6E,WAAWH,IAQ3BV,EAAQ9C,UAAU6D,SAAW,SAAUX,GAEnC,MADAY,QAAOC,OAAOjF,KAAK6E,WAAYT,GACxBpE,MAOXgE,EAAQ9C,UAAU2D,SAAW,WACzB,MAAO7E,MAAKoE,QAAUpE,KAAKoE,WAQ/BJ,EAAQ9C,UAAUgE,SAAW,SAAUC,GACnC,MAAOnF,MAAKyE,QAAQ,QAASU,IAQjCnB,EAAQ9C,UAAUkE,SAAW,SAAUD,GAEnC,IADA,GAAuLE,GAAnLC,EAAYtF,KAAKuF,WAAYrB,EAAkBlE,KAAKkE,gBAAiBsB,EAAYF,EAAkBA,EAAUG,MAAMvB,MAAkBwB,EAAaP,EAASM,MAAMvB,GAC9JmB,EAAWK,EAAWC,SACrB7E,EAAQ0E,EAASH,SACjBG,EAAQzD,KAAKsD,EAIrB,OADArF,MAAK6E,WAAW,SAAWW,EAAQI,KAAK,KACjC5F,MAQXgE,EAAQ9C,UAAU2E,YAAc,SAAUV,GAEtC,IADA,GAA0LU,GAAtLP,EAAYtF,KAAKuF,WAAYrB,EAAkBlE,KAAKkE,gBAAiBsB,EAAYF,EAAkBA,EAAUG,MAAMvB,MAAkB4B,EAAgBX,EAASM,MAAMvB,GACjKsB,EAAQ5E,SAAWiF,EAAcC,EAAcH,UAAU,CAC5D,GAAII,GAAMjF,EAAQ0E,EAASK,EACvBE,SACAP,EAAQjE,OAAOwE,EAAK,GAI5B,MADA/F,MAAK6E,WAAW,SAAWW,EAAQI,KAAK,KACjC5F,MAQXgE,EAAQ9C,UAAUqE,SAAW,WACzB,MAAOvF,MAAK6E,WAAW,UAAY,IAQvCb,EAAQ9C,UAAU8E,SAAW,SAAUb,GACnC,OAAQ,IAAMnF,KAAKuF,WAAa,KAAKzE,QAAQ,IAAMqE,EAAW,WAQlEnB,EAAQ9C,UAAU+E,aAAe,SAAUC,GAEvC,MADAlG,MAAKqE,UAAY6B,EACVlG,MAQXgE,EAAQ9C,UAAUiF,aAAe,SAAUD,GACvC,MAAOlG,MAAKiG,aAAaC,IAO7BlC,EAAQ9C,UAAUkF,aAAe,WAC7B,MAAOpG,MAAKqE,WAAa,IAO7BL,EAAQ9C,UAAUmF,aAAe,WAC7B,MAAOrG,MAAKoG,gBAOhBpC,EAAQ9C,UAAUoF,eAAiB,WAC/B,GAAInC,GAAUnE,KAAKwE,aAAc+B,EAAWvG,KAAKwG,eAEjD,OADAD,GAAW,EAAa,IAAMA,EAAW,IACjC,IAAKpC,EAASoC,EAAU,IAAKvG,KAAKqG,eAAgB,KAAMlC,EAAS,KAAKyB,KAAK,KASvF5B,EAAQ9C,UAAUsF,cAAgB,WAC9B,IAAKxG,KAAKoE,MACN,MAAO,EACX,IAAIA,GAAQpE,KAAK6E,WAAY4B,IAC7B,KAAK,GAAIrG,KAAQgE,GACTA,EAAM/D,eAAeD,IACrBqG,EAAS1E,KAAK3B,EAAO,KAAOgE,EAAMhE,GAAQ,IAGlD,OAAOqG,GAASb,KAAK,MAElB5B,KCnPP0C,EAAkC,WAKlC,QAASA,GAAiBzC,GACV,SAARA,IAAkBA,MACtBjE,KAAK2G,UAAY1C,EAAI0C,YAAa,EAClC3G,KAAK4G,SAAW3C,EAAI2C,aACpB5G,KAAK6G,UAAY5C,EAAI4C,WAAa,GAqHtC,MA3GAH,GAAiBxF,UAAU4F,MAAQ,SAAUnF,GACzC,MAAO,IAAIqC,IACPG,QAAS,IACTC,MAAOpE,KAAK+G,YAAYpF,GACxB2C,UAAWtE,KAAKgH,kBAAkBrF,EAAMsF,oBAYhDP,EAAiBxF,UAAU6F,YAAc,SAAUpF,GAC/C,GAAIyC,IACA8C,KAAQvF,EAAMwF,iBAEdhC,EAAWnF,KAAKoH,eAAezF,EAanC,OAZIwD,KACAf,EAAM,SAAWe,GAEjBnF,KAAK2G,YACLvC,EAAc,OAAI,SAClBA,EAAW,IAAI,uBAEfpE,KAAK4G,UACD5G,KAAK4G,SAAShG,QAAUZ,KAAK4G,SAAShG,OAASe,EAAMsF,gBAAgBrG,SACrEwD,EAAa,MAAIzC,EAAMwF,iBAGxB/C,GAsBXsC,EAAiBxF,UAAUkG,eAAiB,SAAUzF,GAClD,GAAIkF,GAAY7G,KAAK6G,SACrB,IAAKA,EAGA,CAED,IAAK,GADDQ,IAAiBR,GAAYS,EAAmB3F,EAAM4F,sBACjDpG,EAAI,EAAGC,EAAMkG,EAAiB1G,OAAQO,EAAIC,EAAKD,IACpDkG,EAActF,KAAK8E,EAAY,IAAMS,EAAiBnG,GAE1D,OAAOkG,GAAczB,KAAK,KAP1B,MAAO,IAmBfc,EAAiBxF,UAAU8F,kBAAoB,SAAUjD,GAErD,MADAA,GAAa/D,KAAKwH,WAAWzD,IAcjC2C,EAAiBxF,UAAUsG,WAAa,SAAUzD,GAC9C,GAAI6C,GAAW5G,KAAK4G,QACpB,KAAKA,IAAaA,EAAShG,OACvB,MAAOmD,EACX,IAAI0D,GAAiBb,EAAShG,OAAQ8G,EAAmBd,EAASe,QAClE,OAAyB,UAArBD,EACOzF,EAAc8B,EAAY0D,GAEP,WAArBC,EACE7D,EAAeE,EAAY0D,GAG3B3D,EAAYC,EAAY0D,IAGhCf,KC3IPkB,EAA0B,WAM1B,QAASA,GAAS3D,GACdjE,KAAK6H,OAAS5D,EAAI4D,OAClB7H,KAAK8H,KAAO7D,EAAI6D,KAmBpB,MAXAF,GAAS1G,UAAU6G,UAAY,WAC3B,MAAO/H,MAAK6H,QAOhBD,EAAS1G,UAAU8G,QAAU,WACzB,MAAOhI,MAAK8H,MAETF,KC5CPK,EAAwC,WACxC,GAAIC,GAAgB,SAAUC,EAAGC,GAI7B,OAHAF,EAAgBlD,OAAOqD,iBAChBC,uBAA2BrH,QAAS,SAAUkH,EAAGC,GAAKD,EAAEG,UAAYF,IACvE,SAAUD,EAAGC,GAAK,IAAK,GAAIG,KAAKH,GAAOA,EAAE/H,eAAekI,KAAIJ,EAAEI,GAAKH,EAAEG,MACpDJ,EAAGC,GAE5B,OAAO,UAAUD,EAAGC,GAEhB,QAASI,KAAOxI,KAAKyI,YAAcN,EADnCD,EAAcC,EAAGC,GAEjBD,EAAEjH,UAAkB,OAANkH,EAAapD,OAAO0D,OAAON,IAAMI,EAAGtH,UAAYkH,EAAElH,UAAW,GAAIsH,QAcnFG,EAA6B,SAAUC,GAEvC,QAASD,GAAY1E,GACjB,GAAI4E,GAAQD,EAAOE,KAAK9I,KAAMiE,IAAQjE,IAEtC,OADA6I,GAAME,QAAU9E,EAAI8E,QACbF,EAkBX,MAtBAZ,GAAUU,EAAaC,GAWvBD,EAAYzH,UAAU8H,QAAU,WAC5B,MAAO,WAOXL,EAAYzH,UAAU+H,WAAa,WAC/B,MAAOjJ,MAAK+I,SAETJ,GACTf,GChDEK,EAAwC,WACxC,GAAIC,GAAgB,SAAUC,EAAGC,GAI7B,OAHAF,EAAgBlD,OAAOqD,iBAChBC,uBAA2BrH,QAAS,SAAUkH,EAAGC,GAAKD,EAAEG,UAAYF,IACvE,SAAUD,EAAGC,GAAK,IAAK,GAAIG,KAAKH,GAAOA,EAAE/H,eAAekI,KAAIJ,EAAEI,GAAKH,EAAEG,MACpDJ,EAAGC,GAE5B,OAAO,UAAUD,EAAGC,GAEhB,QAASI,KAAOxI,KAAKyI,YAAcN,EADnCD,EAAcC,EAAGC,GAEjBD,EAAEjH,UAAkB,OAANkH,EAAapD,OAAO0D,OAAON,IAAMI,EAAGtH,UAAYkH,EAAElH,UAAW,GAAIsH,QAanFU,EAA6B,SAAUN,GAEvC,QAASM,GAAYjF,GACjB,GAAI4E,GAAQD,EAAOE,KAAK9I,KAAMiE,IAAQjE,IAGtC,OAFA6I,GAAM1E,QAAUF,EAAIE,QACpB0E,EAAMM,QAAUlF,EAAIkF,QACbN,EA4BX,MAjCAZ,GAAUiB,EAAaN,GAYvBM,EAAYhI,UAAU8H,QAAU,WAC5B,MAAO,WAQXE,EAAYhI,UAAUsD,WAAa,WAC/B,MAAOxE,MAAKmE,SAQhB+E,EAAYhI,UAAUkI,UAAY,WAC9B,MAAOpJ,MAAKmJ,SAETD,GACTtB,GC1DEK,EAAwC,WACxC,GAAIC,GAAgB,SAAUC,EAAGC,GAI7B,OAHAF,EAAgBlD,OAAOqD,iBAChBC,uBAA2BrH,QAAS,SAAUkH,EAAGC,GAAKD,EAAEG,UAAYF,IACvE,SAAUD,EAAGC,GAAK,IAAK,GAAIG,KAAKH,GAAOA,EAAE/H,eAAekI,KAAIJ,EAAEI,GAAKH,EAAEG,MACpDJ,EAAGC,GAE5B,OAAO,UAAUD,EAAGC,GAEhB,QAASI,KAAOxI,KAAKyI,YAAcN,EADnCD,EAAcC,EAAGC,GAEjBD,EAAEjH,UAAkB,OAANkH,EAAapD,OAAO0D,OAAON,IAAMI,EAAGtH,UAAYkH,EAAElH,UAAW,GAAIsH,QAkBnFa,EAA4B,SAAUT,GAEtC,QAASS,KACL,MAAkB,QAAXT,GAAmBA,EAAOU,MAAMtJ,KAAMuJ,YAAcvJ,KAU/D,MAZAiI,GAAUoB,EAAYT,GAStBS,EAAWnI,UAAU8H,QAAU,WAC3B,MAAO,UAEJK,GACTzB,GC1CEK,EAAwC,WACxC,GAAIC,GAAgB,SAAUC,EAAGC,GAI7B,OAHAF,EAAgBlD,OAAOqD,iBAChBC,uBAA2BrH,QAAS,SAAUkH,EAAGC,GAAKD,EAAEG,UAAYF,IACvE,SAAUD,EAAGC,GAAK,IAAK,GAAIG,KAAKH,GAAOA,EAAE/H,eAAekI,KAAIJ,EAAEI,GAAKH,EAAEG,MACpDJ,EAAGC,GAE5B,OAAO,UAAUD,EAAGC,GAEhB,QAASI,KAAOxI,KAAKyI,YAAcN,EADnCD,EAAcC,EAAGC,GAEjBD,EAAEjH,UAAkB,OAANkH,EAAapD,OAAO0D,OAAON,IAAMI,EAAGtH,UAAYkH,EAAElH,UAAW,GAAIsH,QAanFgB,EAA0B,SAAUZ,GAEpC,QAASY,KACL,MAAkB,QAAXZ,GAAmBA,EAAOU,MAAMtJ,KAAMuJ,YAAcvJ,KAU/D,MAZAiI,GAAUuB,EAAUZ,GASpBY,EAAStI,UAAU8H,QAAU,WACzB,MAAO,QAEJQ,GACT5B,GChBE6B,EAAY,WACZ,GAAIC,GAAkB,kBAAmBC,EAAe,2BAA4BC,EAAgB,4BACpGC,EAAiB,qCACjBC,EAAyB,iBAAmBD,EAAeE,OAAS,KAChEC,EAA0B,SAAUC,GACpC,MAAO,OAASL,EAAcG,OAAS,OAASE,EAAQH,EAE5D,OAAO,IAAII,SAEP,MACA,cAEA,MACA,OAKA,MAAOF,EAAwB,GAAI,IAAKH,EAAeE,OAAS,IAChE,KACA,IACA,IACA,IAEA,MACA,QAEA,MACAL,EAAgBK,OAChB,IAKA,MAEA,IAAMJ,EAAaI,OAAS,IAC5B,SACA,IACA,IAKA,MAEA,IAAMJ,EAAaI,OAAS,IAC5B,OAEA,MACA,eAEAC,EAAwB,GACxB,KACA,SACA,IACA,IACA,IACA,KACFpE,KAAK,IAAK,SAUZuE,EAA6B,6DAW7BC,EAA4B,WAC5B,QAASA,MA2IT,MAlIAA,GAAWlJ,UAAUmJ,MAAQ,SAAUnE,GAEnC,IADA,GAAIoE,GAA8BC,EAAfC,EAAY,EAAuBC,KACJ,QAA1CH,EAAgBb,EAAU3H,KAAKoE,KAAiB,CACpD,GAAIwE,GAAUJ,EAAc,GAAIK,EAAcL,EAAc,GAC5DnG,EAAUmG,EAAc,IAAMA,EAAc,IAAMA,EAAc,GAChEM,IAAiBN,EAAc,GAAIzC,EAASyC,EAActI,MAAO6I,EAAoB3E,EAAKrF,UAAU2J,EAAW3C,EAE3GgD,KACAN,EAAqBvK,KAAK8K,wBAAwBN,EAAWK,GAC7DJ,EAAM1I,KAAKuH,MAAMmB,EAAOF,IAGxBI,EACAF,EAAM1I,KAAK/B,KAAK+K,kBAAkBlD,EAAQ6C,EAASC,IAGnDF,EAAM1I,KAAK/B,KAAKgL,kBAAkBnD,EAAQ6C,EAASvG,EAASyG,IAEhEJ,EAAY3C,EAAS6C,EAAQ9J,OAGjC,GAAI4J,EAAYtE,EAAKtF,OAAQ,CACzB,GAAIkH,GAAO5B,EAAKrF,UAAU2J,EAEtB1C,KACAyC,EAAqBvK,KAAK8K,wBAAwBN,EAAW1C,GAK7DyC,EAAmBU,QAAQ,SAAUC,GAAQ,MAAOT,GAAM1I,KAAKmJ,MAGvE,MAAOT,IAeXL,EAAWlJ,UAAU4J,wBAA0B,SAAUjD,EAAQC,GAK7D,IAAK,GAJD2C,MAAYU,EAAsB3J,EAAgBsG,EAAMqC,GAInDhJ,EAAI,EAAGC,EAAM+J,EAAoBvK,OAAQO,EAAIC,EAAKD,GAAK,EAAG,CAC/D,GAAIiK,GAAYD,EAAoBhK,GAAIkK,EAAcF,EAAoBhK,EAAI,EAC1EiK,KACAX,EAAM1I,KAAK/B,KAAKsL,eAAezD,EAAQuD,IACvCvD,GAAUuD,EAAUxK,QAEpByK,IACAZ,EAAM1I,KAAK/B,KAAKuL,iBAAiB1D,EAAQwD,IACzCxD,GAAUwD,EAAYzK,QAG9B,MAAO6J,IAYXL,EAAWlJ,UAAU6J,kBAAoB,SAAUlD,EAAQ6C,EAASC,GAChE,MAAO,IAAIhC,IACPd,OAAQA,EACRC,KAAM4C,EACN3B,QAAS4B,EAAYa,UAiB7BpB,EAAWlJ,UAAU8J,kBAAoB,SAAUnD,EAAQ6C,EAASvG,EAASyG,GACzE,MAAO,IAAI1B,IACPrB,OAAQA,EACRC,KAAM4C,EACNvG,QAASA,EAAQsH,cACjBtC,QAASyB,KAajBR,EAAWlJ,UAAUqK,iBAAmB,SAAU1D,EAAQC,GACtD,MAAO,IAAIuB,IAAaxB,OAAQA,EAAQC,KAAMA,KAWlDsC,EAAWlJ,UAAUoK,eAAiB,SAAUzD,EAAQC,GACpD,MAAO,IAAI0B,IAAW3B,OAAQA,EAAQC,KAAMA,KAEzCsC,KCjPPsB,EAAuB,WAMvB,QAASA,GAAMzH,GACXjE,KAAK2L,WAAa1H,EAAI0H,WACtB3L,KAAK4L,YAAc3H,EAAI2H,YACvB5L,KAAK6H,OAAS5D,EAAI4D,OA4EtB,MArEA6D,GAAMxK,UAAU2K,eAAiB,WAC7B,MAAO7L,MAAK4L,aAchBF,EAAMxK,UAAU4K,UAAY,SAAUjE,GAClC7H,KAAK6H,OAASA,GAQlB6D,EAAMxK,UAAU6G,UAAY,WACxB,MAAO/H,MAAK6H,QAuBhB6D,EAAMxK,UAAUqG,oBAAsB,WAClC,OAAQvH,KAAKgJ,YAiBjB0C,EAAMxK,UAAU6K,SAAW,WACvB,MAAO/L,MAAK2L,WAAW7E,MAAM9G,OAE1B0L,KCrFPzD,EAAwC,WACxC,GAAIC,GAAgB,SAAUC,EAAGC,GAI7B,OAHAF,EAAgBlD,OAAOqD,iBAChBC,uBAA2BrH,QAAS,SAAUkH,EAAGC,GAAKD,EAAEG,UAAYF,IACvE,SAAUD,EAAGC,GAAK,IAAK,GAAIG,KAAKH,GAAOA,EAAE/H,eAAekI,KAAIJ,EAAEI,GAAKH,EAAEG,MACpDJ,EAAGC,GAE5B,OAAO,UAAUD,EAAGC,GAEhB,QAASI,KAAOxI,KAAKyI,YAAcN,EADnCD,EAAcC,EAAGC,GAEjBD,EAAEjH,UAAkB,OAANkH,EAAapD,OAAO0D,OAAON,IAAMI,EAAGtH,UAAYkH,EAAElH,UAAW,GAAIsH,QAYnFwD,EAA4B,SAAUpD,GAOtC,QAASoD,GAAW/H,GAChB,GAAI4E,GAAQD,EAAOE,KAAK9I,KAAMiE,IAAQjE,IAEtC,OADA6I,GAAMoD,MAAQhI,EAAIgI,MACXpD,EAkCX,MA3CAZ,GAAU+D,EAAYpD,GAgBtBoD,EAAW9K,UAAU8H,QAAU,WAC3B,MAAO,SAOXgD,EAAW9K,UAAUgL,SAAW,WAC5B,MAAOlM,MAAKiM,OAOhBD,EAAW9K,UAAUiG,cAAgB,WACjC,MAAO,UAAYnH,KAAKiM,OAO5BD,EAAW9K,UAAU+F,cAAgB,WACjC,MAAOjH,MAAKiM,OAETD,GACTN,GCnEEzD,EAAwC,WACxC,GAAIC,GAAgB,SAAUC,EAAGC,GAI7B,OAHAF,EAAgBlD,OAAOqD,iBAChBC,uBAA2BrH,QAAS,SAAUkH,EAAGC,GAAKD,EAAEG,UAAYF,IACvE,SAAUD,EAAGC,GAAK,IAAK,GAAIG,KAAKH,GAAOA,EAAE/H,eAAekI,KAAIJ,EAAEI,GAAKH,EAAEG,MACpDJ,EAAGC,GAE5B,OAAO,UAAUD,EAAGC,GAEhB,QAASI,KAAOxI,KAAKyI,YAAcN,EADnCD,EAAcC,EAAGC,GAEjBD,EAAEjH,UAAkB,OAANkH,EAAapD,OAAO0D,OAAON,IAAMI,EAAGtH,UAAYkH,EAAElH,UAAW,GAAIsH,QAcnF2D,EAA8B,SAAUvD,GAOxC,QAASuD,GAAalI,GAClB,GAAI4E,GAAQD,EAAOE,KAAK9I,KAAMiE,IAAQjE,IAGtC,OAFA6I,GAAMuD,YAAcnI,EAAImI,YACxBvD,EAAMwD,QAAUpI,EAAIoI,QACbxD,EAqDX,MA/DAZ,GAAUkE,EAAcvD,GAiBxBuD,EAAajL,UAAU8H,QAAU,WAC7B,MAAO,WAQXmD,EAAajL,UAAUoL,eAAiB,WACpC,MAAOtM,MAAKoM,aAOhBD,EAAajL,UAAUqL,WAAa,WAChC,MAAOvM,MAAKqM,SAOhBF,EAAajL,UAAUiG,cAAgB,WACnC,GAAIiF,GAAcpM,KAAKoM,YAAaC,EAAUrM,KAAKqM,OACnD,QAAQD,GACJ,IAAK,UACD,MAAO,+BAAiCC,CAC5C,KAAK,WACD,MAAO,oCAAsCA,CACjD,KAAK,YACD,MAAO,sCAAwCA,CACnD,SACI,KAAM,IAAI3K,OAAM,6CAA+C0K,KAQ3ED,EAAajL,UAAU+F,cAAgB,WACnC,MAAO,IAAMjH,KAAKqM,SAEfF,GACTT,GCzFEzD,EAAwC,WACxC,GAAIC,GAAgB,SAAUC,EAAGC,GAI7B,OAHAF,EAAgBlD,OAAOqD,iBAChBC,uBAA2BrH,QAAS,SAAUkH,EAAGC,GAAKD,EAAEG,UAAYF,IACvE,SAAUD,EAAGC,GAAK,IAAK,GAAIG,KAAKH,GAAOA,EAAE/H,eAAekI,KAAIJ,EAAEI,GAAKH,EAAEG,MACpDJ,EAAGC,GAE5B,OAAO,UAAUD,EAAGC,GAEhB,QAASI,KAAOxI,KAAKyI,YAAcN,EADnCD,EAAcC,EAAGC,GAEjBD,EAAEjH,UAAkB,OAANkH,EAAapD,OAAO0D,OAAON,IAAMI,EAAGtH,UAAYkH,EAAElH,UAAW,GAAIsH,QAYnFgE,EAA8B,SAAU5D,GAOxC,QAAS4D,GAAavI,GAClB,GAAI4E,GAAQD,EAAOE,KAAK9I,KAAMiE,IAAQjE,IAGtC,OAFA6I,GAAM4D,QAAUxI,EAAIwI,QACpB5D,EAAMuD,YAAcnI,EAAImI,YACjBvD,EAkEX,MA5EAZ,GAAUuE,EAAc5D,GAiBxB4D,EAAatL,UAAU8H,QAAU,WAC7B,MAAO,WAOXwD,EAAatL,UAAUwL,WAAa,WAChC,MAAO1M,MAAKyM,SAQhBD,EAAatL,UAAUoL,eAAiB,WACpC,MAAOtM,MAAKoM,aAOhBI,EAAatL,UAAUiG,cAAgB,WACnC,OAAQnH,KAAKoM,aACT,IAAK,UACD,MAAO,uBAAyBpM,KAAKyM,OACzC,KAAK,YACD,MAAO,yBAA2BzM,KAAKyM,OAC3C,KAAK,aACD,MAAO,0BAA4BzM,KAAKyM,OAC5C,SACI,KAAM,IAAI/K,OAAM,6CAA+C1B,KAAKoM,eAQhFI,EAAatL,UAAU+F,cAAgB,WACnC,MAAO,IAAMjH,KAAKyM,SAStBD,EAAatL,UAAUqG,oBAAsB,WACzC,GAAID,GAAmBsB,EAAO1H,UAAUqG,oBAAoBuB,KAAK9I,MAAOoM,EAAcpM,KAAKsM,gBAI3F,OAHIF,IACA9E,EAAiBvF,KAAKqK,GAEnB9E,GAEJkF,GACTd,GCpGEzD,EAAwC,WACxC,GAAIC,GAAgB,SAAUC,EAAGC,GAI7B,OAHAF,EAAgBlD,OAAOqD,iBAChBC,uBAA2BrH,QAAS,SAAUkH,EAAGC,GAAKD,EAAEG,UAAYF,IACvE,SAAUD,EAAGC,GAAK,IAAK,GAAIG,KAAKH,GAAOA,EAAE/H,eAAekI,KAAIJ,EAAEI,GAAKH,EAAEG,MACpDJ,EAAGC,GAE5B,OAAO,UAAUD,EAAGC,GAEhB,QAASI,KAAOxI,KAAKyI,YAAcN,EADnCD,EAAcC,EAAGC,GAEjBD,EAAEjH,UAAkB,OAANkH,EAAapD,OAAO0D,OAAON,IAAMI,EAAGtH,UAAYkH,EAAElH,UAAW,GAAIsH,QAcnFmE,EAA4B,SAAU/D,GAOtC,QAAS+D,GAAW1I,GAChB,GAAI4E,GAAQD,EAAOE,KAAK9I,KAAMiE,IAAQjE,IAGtC,OAFA6I,GAAM+D,OAAS3I,EAAI2I,OACnB/D,EAAMgE,SAAW5I,EAAI4I,SACdhE,EAqCX,MA/CAZ,GAAU0E,EAAY/D,GAiBtB+D,EAAWzL,UAAU8H,QAAU,WAC3B,MAAO,SAUX2D,EAAWzL,UAAU4L,UAAY,WAC7B,MAAO9M,MAAK4M,QAOhBD,EAAWzL,UAAUiG,cAAgB,WACjC,MAAO,QAAUnH,KAAK6M,SAAW,IAAM,IAAM7M,KAAK4M,QAOtDD,EAAWzL,UAAU+F,cAAgB,WACjC,MAAOjH,MAAK4L,aAETe,GACTjB,GCzEEzD,EAAwC,WACxC,GAAIC,GAAgB,SAAUC,EAAGC,GAI7B,OAHAF,EAAgBlD,OAAOqD,iBAChBC,uBAA2BrH,QAAS,SAAUkH,EAAGC,GAAKD,EAAEG,UAAYF,IACvE,SAAUD,EAAGC,GAAK,IAAK,GAAIG,KAAKH,GAAOA,EAAE/H,eAAekI,KAAIJ,EAAEI,GAAKH,EAAEG,MACpDJ,EAAGC,GAE5B,OAAO,UAAUD,EAAGC,GAEhB,QAASI,KAAOxI,KAAKyI,YAAcN,EADnCD,EAAcC,EAAGC,GAEjBD,EAAEjH,UAAkB,OAANkH,EAAapD,OAAO0D,OAAON,IAAMI,EAAGtH,UAAYkH,EAAElH,UAAW,GAAIsH,QAYnFuE,EAA0B,SAAUnE,GAOpC,QAASmE,GAAS9I,GACd,GAAI4E,GAAQD,EAAOE,KAAK9I,KAAMiE,IAAQjE,IAuCtC,OA/BA6I,GAAMmE,kBAAoB,mBAO1BnE,EAAMoE,eAAiB,2BAQvBpE,EAAMqE,sBAAwB,QAQ9BrE,EAAMsE,mBAAoB,EAC1BtE,EAAMuE,aAAenJ,EAAImJ,aACzBvE,EAAM3G,IAAM+B,EAAI/B,IAChB2G,EAAMwE,iBAAmBpJ,EAAIoJ,iBAC7BxE,EAAMyE,sBAAwBrJ,EAAIqJ,sBAClCzE,EAAM0E,YAActJ,EAAIsJ,YACxB1E,EAAM2E,mBAAqBvJ,EAAIuJ,mBAC/B3E,EAAM4E,sBAAwBxJ,EAAIwJ,sBAC3B5E,EAgJX,MA9LAZ,GAAU8E,EAAUnE,GAqDpBmE,EAAS7L,UAAU8H,QAAU,WACzB,MAAO,OAaX+D,EAAS7L,UAAUwM,gBAAkB,WACjC,MAAO1N,MAAKoN,cAQhBL,EAAS7L,UAAUyM,OAAS,WACxB,GAAIzL,GAAMlC,KAAKkC,GAMf,OAJKlC,MAAKsN,uBAA0BtN,KAAKqN,kBAAqBrN,KAAKmN,oBAC/DjL,EAAMlC,KAAKkC,IAAM,UAAYA,EAC7BlC,KAAKmN,mBAAoB,GAEtBjL,GAOX6K,EAAS7L,UAAUiG,cAAgB,WAC/B,GAAIjF,GAAMlC,KAAK2N,QACf,OAAOzL,GAAIwB,QAAQ,SAAU,MAOjCqJ,EAAS7L,UAAU+F,cAAgB,WAC/B,GAAIlD,GAAa/D,KAAK6L,gBAiBtB,OAhBI7L,MAAKsN,wBAELvJ,EAAa/D,KAAK4N,4BAA4B7J,IAE9C/D,KAAKuN,YAAYhL,SACjBwB,EAAa/D,KAAK6N,kBAAkB9J,IAEpC/D,KAAKuN,YAAYO,MACjB/J,EAAa/D,KAAK+N,eAAehK,IAEjC/D,KAAKwN,qBACLzJ,EAAa/D,KAAKgO,oBAAoBjK,IAEtC/D,KAAKyN,wBACL1J,EAAa/D,KAAKiO,sBAAsBlK,IAErCA,GAaXgJ,EAAS7L,UAAU2M,kBAAoB,SAAU3L,GAC7C,MAAOA,GAAIwB,QAAQ1D,KAAKgN,kBAAmB,KAU/CD,EAAS7L,UAAU6M,eAAiB,SAAU7L,GAC1C,MAAOA,GAAIwB,QAAQ1D,KAAKiN,eAAgB,OAU5CF,EAAS7L,UAAU0M,4BAA8B,SAAU9F,GACvD,MAAOA,GAAKpE,QAAQ1D,KAAKkN,sBAAuB,KAUpDH,EAAS7L,UAAU8M,oBAAsB,SAAUjK,GAI/C,MAHiD,MAA7CA,EAAWmK,OAAOnK,EAAWnD,OAAS,KACtCmD,EAAaA,EAAWoK,MAAM,OAE3BpK,GASXgJ,EAAS7L,UAAU+M,sBAAwB,SAAUlK,GACjD,IACI,MAAOqK,oBAAmBrK,EACrBL,QAAQ,QAAS,UACjBA,QAAQ,QAAS,SACjBA,QAAQ,QAAS,SACjBA,QAAQ,QAAS,QACjBA,QAAQ,QAAS,SAE1B,MAAO2K,GAEH,MAAOtK,KAGRgJ,GACTrB,GC5ME4C,EAAyB,WAMzB,QAASA,GAAQrK,GACbjE,KAAK2L,WAAa1H,EAAI0H,WAE1B,MAAO2C,MCAAC,EAAgB,g8BAehBC,EAAoB,kHASpBC,EAAuBF,EAAgBC,EAE9CE,EAAQ,OAASF,EAAoB,iBAAmBA,EAAoB,SAE5EG,EAAiB,IAAMF,EAAuB,QAAUA,EAAuB,cAAgBA,EAAuB,MACtHG,EAAoB,SAAU3E,GAC9B,MAAO,OAAS0E,EAAiB,OAAS1E,GAMnC4E,EAAmB,SAAU5E,GACpC,MAAO,MAAQ2E,EAAkB3E,GAAS,SAAW2E,EAAkB3E,EAAQ,GAAK,YAAcyE,EAAQ,KCtDnGI,EAAW,4lVCFlB7G,EAAwC,WACxC,GAAIC,GAAgB,SAAUC,EAAGC,GAI7B,OAHAF,EAAgBlD,OAAOqD,iBAChBC,uBAA2BrH,QAAS,SAAUkH,EAAGC,GAAKD,EAAEG,UAAYF,IACvE,SAAUD,EAAGC,GAAK,IAAK,GAAIG,KAAKH,GAAOA,EAAE/H,eAAekI,KAAIJ,EAAEI,GAAKH,EAAEG,MACpDJ,EAAGC,GAE5B,OAAO,UAAUD,EAAGC,GAEhB,QAASI,KAAOxI,KAAKyI,YAAcN,EADnCD,EAAcC,EAAGC,GAEjBD,EAAEjH,UAAkB,OAANkH,EAAapD,OAAO0D,OAAON,IAAMI,EAAGtH,UAAYkH,EAAElH,UAAW,GAAIsH,QAenFuG,EAA8B,SAAUnG,GAExC,QAASmG,KACL,GAAIlG,GAAmB,OAAXD,GAAmBA,EAAOU,MAAMtJ,KAAMuJ,YAAcvJ,IAiBhE,OARA6I,GAAMmG,aAAe,WACjB,GAAIC,GAAoBR,EAAsBS,EAAoB,0BAA4BC,EAA8B,qBAAsBC,EAAkBH,EAAoBC,EAAmBG,EAA4BD,EAAkBD,EAA6BG,EAAa,GAAIpF,QAAO,OAASkF,EAAkB,QAAUA,EAAkB,wBAA0BC,EAA4B,WAC3Z,OAAO,IAAInF,SACPoF,EAAWvF,OACX8E,EAAiB,GACjB,MAAOC,EAAS/E,QAClBnE,KAAK,IAAK,SAETiD,EAkBX,MArCAZ,GAAU8G,EAAcnG,GAwBxBmG,EAAa7N,UAAUqO,aAAe,SAAUzH,GAE5C,IADA,GAAkFnG,GAA9EqN,EAAehP,KAAKgP,aAAcrD,EAAa3L,KAAK2L,WAAY6D,KACvB,QAArC7N,EAAQqN,EAAalN,KAAKgG,KAAiB,CAC/C,GAAI8D,GAAcjK,EAAM,EACxB6N,GAAQzN,KAAK,GAAIiK,IACbL,WAAYA,EACZC,YAAaA,EACb/D,OAAQlG,EAAMK,MACdiK,MAAOL,KAGf,MAAO4D,IAEJT,GACTT,GCjDEmB,EAAmC,WACnC,QAASA,MA6IT,MAlHAA,GAAkBC,QAAU,SAAUC,EAAUtC,GAC5C,QAAKA,IAAqBrN,KAAK4P,iBAAiBvC,IAC5CrN,KAAK6P,iCAAiCF,EAAUtC,IAC/CrN,KAAK8P,sCAAsCH,EAAUtC,KACjDrN,KAAK+P,iBAAiBJ,IAC3B3P,KAAKgQ,qBAAqBL,KAKlCF,EAAkBM,iBAAmB,SAAUE,GAC3C,GAAIC,GAAW,GAAIhG,QAAOlK,KAAKmQ,qBAAqBpG,OAAS/J,KAAKoQ,QAAQrG,QACtEsG,EAAYJ,EAAetO,MAAMuO,EACrC,OAAqB,QAAdG,GAEXZ,EAAkBO,qBAAuB,SAAUL,GAC/C,GAAIW,GAAoBX,CAIxB,OAHI3P,MAAKmQ,qBAAqBI,KAAKZ,KAC/BW,EAAoBX,EAASlK,MAAM,OAAO,IAEvC6K,EAAkB7K,MAAM,KAAK,GAAG3E,QAAQ,UAWnD2O,EAAkBG,iBAAmB,SAAUK,GAC3C,GAAIO,GAAoBP,EAAetO,MAAM3B,KAAKyQ,gBAAiBJ,EAAYG,GAAqBA,EAAkB,GAAG/E,aACzH,OAAsB,gBAAd4E,GAA6C,cAAdA,GAuB3CZ,EAAkBI,iCAAmC,SAAUF,EAAUtC,GACrE,SAAUsC,GAActC,GAAqBrN,KAAKmQ,qBAAqBI,KAAKlD,IAAsBsC,EAAS7O,QAAQ,YAmBvH2O,EAAkBK,sCAAwC,SAAUH,EAAUtC,GAC1E,SAAIsC,IAAYtC,KACJrN,KAAK0Q,8BAA8BH,KAAKZ,IAYxDF,EAAkBU,qBAAuB,gCASzCV,EAAkBgB,eAAiB,4BAOnChB,EAAkBiB,8BAAgC,GAAIxG,QAAO,aAAeqE,EAAgB,KAO5FkB,EAAkBW,QAAU,2FACrBX,KC7JPxH,EAAwC,WACxC,GAAIC,GAAgB,SAAUC,EAAGC,GAI7B,OAHAF,EAAgBlD,OAAOqD,iBAChBC,uBAA2BrH,QAAS,SAAUkH,EAAGC,GAAKD,EAAEG,UAAYF,IACvE,SAAUD,EAAGC,GAAK,IAAK,GAAIG,KAAKH,GAAOA,EAAE/H,eAAekI,KAAIJ,EAAEI,GAAKH,EAAEG,MACpDJ,EAAGC,GAE5B,OAAO,UAAUD,EAAGC,GAEhB,QAASI,KAAOxI,KAAKyI,YAAcN,EADnCD,EAAcC,EAAGC,GAEjBD,EAAEjH,UAAkB,OAANkH,EAAapD,OAAO0D,OAAON,IAAMI,EAAGtH,UAAYkH,EAAElH,UAAW,GAAIsH,QAgBnFmI,EAA4B,SAAU/H,GAOtC,QAAS+H,GAAW1M,GAChB,GAAI4E,GAAQD,EAAOE,KAAK9I,KAAMiE,IAAQjE,IAyGtC,OAtEA6I,GAAMmG,aAAe,WACjB,GAAI4B,GAAc,4FAClBC,EAAW,YAGXC,EAAiB,GAAI5G,QAAO,YAAcuE,EAAuB,qCAA6CA,EAAuB,+BACrI,OAAO,IAAIvE,SACP,MACA,IACA0G,EAAY7G,OACZ8E,EAAiB,GACjB,IACA,IACA,IACA,QACAgC,EAAS9G,OACT8E,EAAiB,GACjB,IACA,IACA,IACA,QACAA,EAAiB,IAAM,MACvBC,EAAS/E,OACT,QAAU0E,EAAuB,KACjC,IACA,IACA,eACA,MAAQqC,EAAe/G,OAAS,MAClCnE,KAAK,IAAK,SAehBiD,EAAMkI,eAAiB,GAAI7G,QAAO,IAAMuE,EAAuB,KAe/D5F,EAAMmI,aAAe,MAQrBnI,EAAMoI,cAAgB,MACtBpI,EAAM0E,YAActJ,EAAIsJ,YACxB1E,EAAM2E,mBAAqBvJ,EAAIuJ,mBAC/B3E,EAAM4E,sBAAwBxJ,EAAIwJ,sBAC3B5E,EA2HX,MA3OAZ,GAAU0I,EAAY/H,GAqHtB+H,EAAWzP,UAAUqO,aAAe,SAAUzH,GAE1C,IADA,GAAoNnG,GAAhNqN,EAAehP,KAAKgP,aAAczB,EAAcvN,KAAKuN,YAAaC,EAAqBxN,KAAKwN,mBAAoBC,EAAwBzN,KAAKyN,sBAAuB9B,EAAa3L,KAAK2L,WAAY6D,KACzJ,QAArC7N,EAAQqN,EAAalN,KAAKgG,KAAiB,CAC/C,GAAIoJ,GAAWvP,EAAM,GAAIwP,EAAiBxP,EAAM,GAAIyP,EAAczP,EAAM,GAAI0P,EAA2B1P,EAAM,GAE7G2P,EAA2B3P,EAAM,GAAIkG,EAASlG,EAAMK,MAAOsL,EAAwB+D,GAA4BC,EAA0BC,EAAWzJ,EAAKoG,OAAOrG,EAAS,EACzK,IAAK4H,EAAkBC,QAAQwB,EAAUC,MAKrCtJ,EAAS,GAAkB,MAAb0J,GAOd1J,EAAS,GAAKyF,GAAyBtN,KAAK+Q,eAAeR,KAAKgB,IAApE,CASA,GANI,MAAMhB,KAAKW,KACXA,EAAWA,EAAS1O,OAAO,EAAG0O,EAAStQ,OAAS,IAKhDZ,KAAKwR,+BAA+BN,GACpCA,EAAWA,EAAS1O,OAAO,EAAG0O,EAAStQ,OAAS,OAE/C,CAED,GAAI6Q,GAAMzR,KAAK0R,4BAA4BR,EAAUC,EACjDM,QACAP,EAAWA,EAAS1O,OAAO,EAAGiP,IAGtC,GAAIrE,GAAe+D,EAAiB,SAAYC,EAAc,MAAQ,MAAQ/D,IAAqB8D,CACnG3B,GAAQzN,KAAK,GAAIgL,IACbpB,WAAYA,EACZC,YAAasF,EACbrJ,OAAQA,EACRuF,aAAcA,EACdlL,IAAKgP,EACL7D,iBAAkBA,EAClBC,wBAAyBA,EACzBC,YAAaA,EACbC,mBAAoBA,EACpBC,sBAAuBA,MAG/B,MAAO+B,IAqBXmB,EAAWzP,UAAUsQ,+BAAiC,SAAUN,GAC5D,GAAIS,GAAWT,EAAShD,OAAOgD,EAAStQ,OAAS,EACjD,IAAiB,MAAb+Q,EAAkB,CAClB,GAAIC,GAAkBV,EAASvP,MAAM3B,KAAKgR,cAAea,EAAmBX,EAASvP,MAAM3B,KAAKiR,eAAgBa,EAAiBF,GAAmBA,EAAgBhR,QAAW,EAAGmR,EAAkBF,GAAoBA,EAAiBjR,QAAW,CACpP,IAAIkR,EAAgBC,EAChB,OAAO,EAGf,OAAO,GAiBXpB,EAAWzP,UAAUwQ,4BAA8B,SAAU/B,EAAUwB,GACnE,IAAKxB,EACD,QAEJ,IAAI9H,GAAS,CACTsJ,KACAtJ,EAAS8H,EAAS7O,QAAQ,KAC1B6O,EAAWA,EAASxB,MAAMtG,GAE9B,IAAImK,GAAK,GAAI9H,QAAO,eAAmBuE,EAAuB,OAASA,EAAuB,SAAWA,EAAuB,OAC5HwD,EAAMD,EAAGlQ,KAAK6N,EAClB,OAAY,QAARsC,MAGJpK,GAAUoK,EAAI,GAAGrR,OACjB+O,EAAWA,EAASxB,MAAM8D,EAAI,GAAGrR,QAC7B,uBAAuB2P,KAAKZ,GACrB9H;AAIR8I,GACTrC,GCvQErG,EAAwC,WACxC,GAAIC,GAAgB,SAAUC,EAAGC,GAI7B,OAHAF,EAAgBlD,OAAOqD,iBAChBC,uBAA2BrH,QAAS,SAAUkH,EAAGC,GAAKD,EAAEG,UAAYF,IACvE,SAAUD,EAAGC,GAAK,IAAK,GAAIG,KAAKH,GAAOA,EAAE/H,eAAekI,KAAIJ,EAAEI,GAAKH,EAAEG,MACpDJ,EAAGC,GAE5B,OAAO,UAAUD,EAAGC,GAEhB,QAASI,KAAOxI,KAAKyI,YAAcN,EADnCD,EAAcC,EAAGC,GAEjBD,EAAEjH,UAAkB,OAANkH,EAAapD,OAAO0D,OAAON,IAAMI,EAAGtH,UAAYkH,EAAElH,UAAW,GAAIsH,QAYnF0J,EAAgC,SAAUtJ,GAO1C,QAASsJ,GAAejO,GACpB,GAAI4E,GAAQD,EAAOE,KAAK9I,KAAMiE,IAAQjE,IAqBtC,OAZA6I,GAAMmG,aAAe,GAAI9E,QAAO,MAAQuE,EAAuB,WAAY,KAU3E5F,EAAMsJ,iBAAmB,GAAIjI,QAAO,KAAOuE,EAAuB,KAClE5F,EAAMuD,YAAcnI,EAAImI,YACjBvD,EAyBX,MArDAZ,GAAUiK,EAAgBtJ,GAiC1BsJ,EAAehR,UAAUqO,aAAe,SAAUzH,GAE9C,IADA,GAA4JnG,GAAxJqN,EAAehP,KAAKgP,aAAcmD,EAAmBnS,KAAKmS,iBAAkB/F,EAAcpM,KAAKoM,YAAaT,EAAa3L,KAAK2L,WAAY6D,KACjG,QAArC7N,EAAQqN,EAAalN,KAAKgG,KAAiB,CAC/C,GAAID,GAASlG,EAAMK,MAAOuP,EAAWzJ,EAAKoG,OAAOrG,EAAS,EAI1D,IAAe,IAAXA,GAAgBsK,EAAiB5B,KAAKgB,GAAW,CACjD,GAAI3F,GAAcjK,EAAM,GAAI0K,EAAU1K,EAAM,GAAGwM,MAAM,EACrDqB,GAAQzN,KAAK,GAAIoK,IACbR,WAAYA,EACZC,YAAaA,EACb/D,OAAQA,EACRuE,YAAaA,EACbC,QAASA,MAIrB,MAAOmD,IAEJ0C,GACT5D,GC7EErG,EAAwC,WACxC,GAAIC,GAAgB,SAAUC,EAAGC,GAI7B,OAHAF,EAAgBlD,OAAOqD,iBAChBC,uBAA2BrH,QAAS,SAAUkH,EAAGC,GAAKD,EAAEG,UAAYF,IACvE,SAAUD,EAAGC,GAAK,IAAK,GAAIG,KAAKH,GAAOA,EAAE/H,eAAekI,KAAIJ,EAAEI,GAAKH,EAAEG,MACpDJ,EAAGC,GAE5B,OAAO,UAAUD,EAAGC,GAEhB,QAASI,KAAOxI,KAAKyI,YAAcN,EADnCD,EAAcC,EAAGC,GAEjBD,EAAEjH,UAAkB,OAANkH,EAAapD,OAAO0D,OAAON,IAAMI,EAAGtH,UAAYkH,EAAElH,UAAW,GAAIsH,QAcnF4J,EAA8B,SAAUxJ,GAExC,QAASwJ,KACL,GAAIvJ,GAAmB,OAAXD,GAAmBA,EAAOU,MAAMtJ,KAAMuJ,YAAcvJ,IAchE,OADA6I,GAAMmG,aAAe,wRACdnG,EA6BX,MA7CAZ,GAAUmK,EAAcxJ,GAuBxBwJ,EAAalR,UAAUqO,aAAe,SAAUzH,GAE5C,IADA,GAAkFnG,GAA9EqN,EAAehP,KAAKgP,aAAcrD,EAAa3L,KAAK2L,WAAY6D,KACvB,QAArC7N,EAAQqN,EAAalN,KAAKgG,KAAiB,CAE/C,GAAI8D,GAAcjK,EAAM,GAAI0Q,EAAczG,EAAYlI,QAAQ,aAAc,IAC5EmJ,KAAclL,EAAM,KAAMA,EAAM,IAChC2Q,EAAwB,GAAf3Q,EAAMK,MAAa,GAAK8F,EAAKtF,OAAOb,EAAMK,MAAQ,EAAG,GAAIuQ,EAAQzK,EAAKtF,OAAOb,EAAMK,MAAQ4J,EAAYhL,OAAQ,GAAI4R,GAAgBF,EAAO3Q,MAAM,QAAU4Q,EAAM5Q,MAAM,KAC3K3B,MAAKyS,UAAU9Q,EAAM,KAAO3B,KAAKyS,UAAU7G,IAAgB4G,GAC3DhD,EAAQzN,KAAK,GAAI4K,IACbhB,WAAYA,EACZC,YAAaA,EACb/D,OAAQlG,EAAMK,MACd4K,OAAQyF,EACRxF,SAAUA,KAItB,MAAO2C,IAEX4C,EAAalR,UAAUuR,UAAY,SAAU3K,GACzC,MAAO,KAAKyI,KAAKzI,IAEdsK,GACT9D,GCvEErG,EAAwC,WACxC,GAAIC,GAAgB,SAAUC,EAAGC,GAI7B,OAHAF,EAAgBlD,OAAOqD,iBAChBC,uBAA2BrH,QAAS,SAAUkH,EAAGC,GAAKD,EAAEG,UAAYF,IACvE,SAAUD,EAAGC,GAAK,IAAK,GAAIG,KAAKH,GAAOA,EAAE/H,eAAekI,KAAIJ,EAAEI,GAAKH,EAAEG,MACpDJ,EAAGC,GAE5B,OAAO,UAAUD,EAAGC,GAEhB,QAASI,KAAOxI,KAAKyI,YAAcN,EADnCD,EAAcC,EAAGC,GAEjBD,EAAEjH,UAAkB,OAANkH,EAAapD,OAAO0D,OAAON,IAAMI,EAAGtH,UAAYkH,EAAElH,UAAW,GAAIsH,QAYnFkK,EAAgC,SAAU9J,GAO1C,QAAS8J,GAAezO,GACpB,GAAI4E,GAAQD,EAAOE,KAAK9I,KAAMiE,IAAQjE,IAyBtC,OAhBA6I,GAAM8J,gBACFC,QAAW,GAAI1I,QAAO,MAAQuE,EAAuB,UAAW,KAChEoE,UAAa,GAAI3I,QAAO,OAASuE,EAAuB,UAAW,KACnEqE,WAAc,GAAI5I,QAAO,OAASuE,EAAuB,WAAkB,MAW/E5F,EAAMsJ,iBAAmB,GAAIjI,QAAO,KAAOuE,EAAuB,KAClE5F,EAAMuD,YAAcnI,EAAImI,YACjBvD,EA6BX,MA7DAZ,GAAUyK,EAAgB9J,GAqC1B8J,EAAexR,UAAUqO,aAAe,SAAUzH,GAC9C,GAAgLnG,GAA5KyK,EAAcpM,KAAKoM,YAAa4C,EAAehP,KAAK2S,eAAe3S,KAAKoM,aAAc+F,EAAmBnS,KAAKmS,iBAAkBxG,EAAa3L,KAAK2L,WAAY6D,IAClK,KAAKR,EACD,MAAOQ,EAEX,MAA6C,QAArC7N,EAAQqN,EAAalN,KAAKgG,KAAiB,CAC/C,GAAID,GAASlG,EAAMK,MAAOuP,EAAWzJ,EAAKoG,OAAOrG,EAAS,EAI1D,IAAe,IAAXA,GAAgBsK,EAAiB5B,KAAKgB,GAAW,CACjD,GAAI3F,GAAcjK,EAAM,GAAG+B,QAAQ,QAAS,IAC5C+I,EAAUb,EAAYuC,MAAM,EAC5BqB,GAAQzN,KAAK,GAAIyK,IACbb,WAAYA,EACZC,YAAaA,EACb/D,OAAQA,EACRuE,YAAaA,EACbK,QAASA,MAIrB,MAAO+C,IAEJkD,GACTpE,GCyCEvO,EAA4B,WAC5B,QAASA,GAAWkE,GACJ,SAARA,IAAkBA,MAMtBjE,KAAK+S,QAAUhT,EAAWgT,QAC1B/S,KAAKgT,KAAOhT,KAAKiT,iBAAiBhP,EAAI+O,MACtChT,KAAKiM,MAA6B,iBAAdhI,GAAIgI,OAAsBhI,EAAIgI,MAClDjM,KAAKkT,MAA6B,iBAAdjP,GAAIiP,OAAsBjP,EAAIiP,MAClDlT,KAAKqM,QAAUpI,EAAIoI,UAAW,EAC9BrM,KAAKyM,QAAUxI,EAAIwI,UAAW,EAC9BzM,KAAK2G,UAAqC,iBAAlB1C,GAAI0C,WAA0B1C,EAAI0C,UAC1D3G,KAAKuN,YAAcvN,KAAKmT,wBAAwBlP,EAAIsJ,aACpDvN,KAAKwN,mBAAuD,iBAA3BvJ,GAAIuJ,oBAAmCvJ,EAAIuJ,mBAC5ExN,KAAKyN,sBAA6D,iBAA9BxJ,GAAIwJ,uBAAsCxJ,EAAIwJ,qBAElF,IAAIhB,GAAUzM,KAAKyM,OACnB,IAAIA,KAAY,GAAqB,YAAZA,GAAqC,cAAZA,EAC9C,KAAM,IAAI/K,OAAM,mCAGpB,IAAI2K,GAAUrM,KAAKqM,OACnB,IAAIA,KAAY,GAAqB,YAAZA,GAAqC,aAAZA,GAAsC,cAAZA,EACxE,KAAM,IAAI3K,OAAM,mCAEpB1B,MAAK4G,SAAW5G,KAAKoT,qBAAqBnP,EAAI2C,UAC9C5G,KAAK6G,UAAY5C,EAAI4C,WAAa,GAClC7G,KAAKqT,UAAYpP,EAAIoP,WAAa,KAClCrT,KAAKsT,QAAUrP,EAAIqP,SAAWtT,KAC9BA,KAAKuT,WAAa,GAAInJ,GACtBpK,KAAKwT,SAAW,KAChBxT,KAAK2L,WAAa,KA6ctB,MArbA5L,GAAW0T,KAAO,SAAUC,EAAYC,GACpC,GAAIC,GAAa,GAAI7T,GAAW4T,EAChC,OAAOC,GAAWH,KAAKC,IAmC3B3T,EAAWsK,MAAQ,SAAUqJ,EAAYC,GACrC,GAAIC,GAAa,GAAI7T,GAAW4T,EAChC,OAAOC,GAAWvJ,MAAMqJ,IAW5B3T,EAAWmB,UAAU+R,iBAAmB,SAAUD,GAG9C,MAFY,OAARA,IACAA,GAAO,GACS,iBAATA,IACEa,cAAeb,EAAMc,WAAYd,EAAMe,WAAYf,IAIxDa,cAA6C,iBAAvBb,GAAKa,eAA8Bb,EAAKa,cAC9DC,WAAuC,iBAApBd,GAAKc,YAA2Bd,EAAKc,WACxDC,WAAuC,iBAApBf,GAAKe,YAA2Bf,EAAKe,aAcpEhU,EAAWmB,UAAUiS,wBAA0B,SAAU5F,GAGrD,MAFmB,OAAfA,IACAA,GAAc,GACS,iBAAhBA,IACEhL,OAAQgL,EAAaO,IAAKP,IAI/BhL,OAAsC,iBAAvBgL,GAAYhL,QAAuBgL,EAAYhL,OAC9DuL,IAAgC,iBAApBP,GAAYO,KAAoBP,EAAYO,MAcpE/N,EAAWmB,UAAUkS,qBAAuB,SAAUxM,GAClD,MAAwB,gBAAbA,IACEhG,OAAQgG,EAAUe,SAAU,OAG9B1H,EAAS2G,OACZhG,OAAQoT,OAAOC,kBACftM,SAAU,SAmCtB5H,EAAWmB,UAAUmJ,MAAQ,SAAUqJ,GAKnC,IAAK,GAJDQ,GAAYlU,KAAKuT,WAAWlJ,MAAMqJ,GAAaS,EAAsB,EACzE3E,KAGSrO,EAAI,EAAGC,EAAM8S,EAAUtT,OAAQO,EAAIC,EAAKD,IAAK,CAClD,GAAI+J,GAAOgJ,EAAU/S,GAAIiT,EAAWlJ,EAAKlC,SACzC,IAAiB,YAAboL,IAA2B,IAAK,QAAS,UAAUtT,QAAQoK,EAAK1G,mBAC3D0G,EAAK9B,YAIN+K,EAAsBhR,KAAKkR,IAAIF,EAAsB,EAAG,GAHxDA,QAMH,IAAiB,SAAbC,GAA+C,IAAxBD,EAA2B,CACvD,GAAIG,GAAkBtU,KAAKuU,UAAUrJ,EAAKlD,UAAWkD,EAAKnD,YAC1DyH,GAAQzN,KAAKuH,MAAMkG,EAAS8E,IAYpC,MANA9E,GAAUxP,KAAKwU,eAAehF,GAK9BA,EAAUxP,KAAKyU,sBAAsBjF,IAczCzP,EAAWmB,UAAUsT,eAAiB,SAAUhF,GAE5CA,EAAQkF,KAAK,SAAUC,EAAGvM,GAAK,MAAOuM,GAAE5M,YAAcK,EAAEL,aACxD,KAAK,GAAI5G,GAAI,EAAGA,EAAIqO,EAAQ5O,OAAS,EAAGO,IAAK,CACzC,GAAIQ,GAAQ6N,EAAQrO,GAAI0G,EAASlG,EAAMoG,YAAa6M,EAAoBjT,EAAMkK,iBAAiBjL,OAAQiU,EAAShN,EAAS+M,CACzH,IAAIzT,EAAI,EAAIqO,EAAQ5O,OAAQ,CAExB,GAAI4O,EAAQrO,EAAI,GAAG4G,cAAgBF,EAAQ,CACvC,GAAIiN,GAAYtF,EAAQrO,EAAI,GAAG0K,iBAAiBjL,OAASgU,EAAoBzT,EAAIA,EAAI,CACrFqO,GAAQjO,OAAOuT,EAAW,EAC1B,UAGAtF,EAAQrO,EAAI,GAAG4G,YAAc8M,GAC7BrF,EAAQjO,OAAOJ,EAAI,EAAG,IAIlC,MAAOqO,IAoBXzP,EAAWmB,UAAUuT,sBAAwB,SAAUjF,GAkBnD,MAjBKxP,MAAKqM,SACNhL,EAAOmO,EAAS,SAAU7N,GAAS,MAA2B,YAApBA,EAAMqH,YAC/ChJ,KAAKiM,OACN5K,EAAOmO,EAAS,SAAU7N,GAAS,MAA2B,UAApBA,EAAMqH,YAC/ChJ,KAAKkT,OACN7R,EAAOmO,EAAS,SAAU7N,GAAS,MAA2B,UAApBA,EAAMqH,YAC/ChJ,KAAKyM,SACNpL,EAAOmO,EAAS,SAAU7N,GAAS,MAA2B,YAApBA,EAAMqH,YAC/ChJ,KAAKgT,KAAKa,eACXxS,EAAOmO,EAAS,SAAUuF,GAAK,MAAuB,QAAhBA,EAAE/L,WAA+C,WAAxB+L,EAAErH,oBAEhE1N,KAAKgT,KAAKc,YACXzS,EAAOmO,EAAS,SAAUuF,GAAK,MAAuB,QAAhBA,EAAE/L,WAA+C,QAAxB+L,EAAErH,oBAEhE1N,KAAKgT,KAAKe,YACX1S,EAAOmO,EAAS,SAAUuF,GAAK,MAAuB,QAAhBA,EAAE/L,WAA+C,QAAxB+L,EAAErH,oBAE9D8B,GAuBXzP,EAAWmB,UAAUqT,UAAY,SAAUzM,EAAMD,GAC9B,SAAXA,IAAqBA,EAAS,GAClCA,EAASA,GAAU,CAEnB,KAAK,GADD2L,GAAWxT,KAAKgV,cAAexF,KAC1BrO,EAAI,EAAG8T,EAAczB,EAAS5S,OAAQO,EAAI8T,EAAa9T,IAAK,CAMjE,IAAK,GALD+T,GAAc1B,EAASrS,GAAGoO,aAAazH,GAKlCqN,EAAI,EAAGC,EAAiBF,EAAYtU,OAAQuU,EAAIC,EAAgBD,IACrED,EAAYC,GAAGrJ,UAAUjE,EAASqN,EAAYC,GAAGpN,YAErDyH,GAAQzN,KAAKuH,MAAMkG,EAAS0F,GAEhC,MAAO1F,IAoBXzP,EAAWmB,UAAUuS,KAAO,SAAUC,GAClC,IAAKA,EACD,MAAO,EAGX,KAAK,GADDlE,GAAUxP,KAAKqK,MAAMqJ,GAAa2B,KAAc7K,EAAY,EACvDrJ,EAAI,EAAGC,EAAMoO,EAAQ5O,OAAQO,EAAIC,EAAKD,IAAK,CAChD,GAAIQ,GAAQ6N,EAAQrO,EACpBkU,GAAQtT,KAAK2R,EAAW7S,UAAU2J,EAAW7I,EAAMoG,cACnDsN,EAAQtT,KAAK/B,KAAKsV,qBAAqB3T,IACvC6I,EAAY7I,EAAMoG,YAAcpG,EAAMkK,iBAAiBjL,OAG3D,MADAyU,GAAQtT,KAAK2R,EAAW7S,UAAU2J,IAC3B6K,EAAQzP,KAAK,KAcxB7F,EAAWmB,UAAUoU,qBAAuB,SAAU3T,GAElD,GAAI4T,EAIJ,IAHIvV,KAAKqT,YACLkC,EAAkBvV,KAAKqT,UAAUvK,KAAK9I,KAAKsT,QAAS3R,IAEzB,gBAApB4T,GACP,MAAOA,EAEN,IAAIA,KAAoB,EACzB,MAAO5T,GAAMkK,gBAEZ,IAAI0J,YAA2BvR,GAChC,MAAOuR,GAAgBjP,gBAIvB,IAAIkP,GAAY7T,EAAMoK,UACtB,OAAOyJ,GAAUlP,kBAUzBvG,EAAWmB,UAAU8T,YAAc,WAC/B,GAAKhV,KAAKwT,SAYN,MAAOxT,MAAKwT,QAXZ,IAAI7H,GAAa3L,KAAKyV,gBAClBjC,GACA,GAAItB,IAAiBvG,WAAYA,EAAYS,YAAapM,KAAKqM,UAC/D,GAAI0C,IAAepD,WAAYA,IAC/B,GAAIyG,IAAezG,WAAYA,IAC/B,GAAI+G,IAAiB/G,WAAYA,EAAYS,YAAapM,KAAKyM,UAC/D,GAAIkE,IAAahF,WAAYA,EAAY4B,YAAavN,KAAKuN,YAAaC,mBAAoBxN,KAAKwN,mBAAoBC,sBAAuBzN,KAAKyN,wBAErJ,OAAQzN,MAAKwT,SAAWA,GA2BhCzT,EAAWmB,UAAUuU,cAAgB,WACjC,GAAI9J,GAAa3L,KAAK2L,UAQtB,OAPKA,KACDA,EAAa3L,KAAK2L,WAAa,GAAIjF,IAC/BC,UAAW3G,KAAK2G,UAChBC,SAAU5G,KAAK4G,SACfC,UAAW7G,KAAK6G,aAGjB8E,GAOX5L,EAAWgT,QAAU,QAKrBhT,EAAW2G,iBAAmBA,EAK9B3G,EAAWiE,QAAUA,EAKrBjE,EAAW2V,SACPC,MAAO5G,EACP6G,QAAS1D,EACT5D,QAASA,EACTuH,QAASnD,EACToD,MAAO1D,EACP2D,IAAKpF,GAMT5Q,EAAW4B,OACPgU,MAAO3J,EACP4J,QAASzJ,EACTT,MAAOA,EACPmK,QAASrJ,EACTsJ,MAAOnJ,EACPoJ,IAAKhJ,GAEFhN,I5BklFP,OAAOA","file":"Autolinker.min.js","sourcesContent":["/*!\n * Autolinker.js\n * 1.8.3\n *\n * Copyright(c) 2018 Gregory Jacobs <greg@greg-jacobs.com>\n * MIT License\n *\n * https://github.com/gregjacobs/Autolinker.js\n */\n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    (global = global || self, global.Autolinker = factory());\n}(this, function () { 'use strict';\n\n    /**\n     * Assigns (shallow copies) the properties of `src` onto `dest`, if the\n     * corresponding property on `dest` === `undefined`.\n     *\n     * @param {Object} dest The destination object.\n     * @param {Object} src The source object.\n     * @return {Object} The destination object (`dest`)\n     */\n    function defaults(dest, src) {\n        for (var prop in src) {\n            if (src.hasOwnProperty(prop) && dest[prop] === undefined) {\n                dest[prop] = src[prop];\n            }\n        }\n        return dest;\n    }\n    /**\n     * Truncates the `str` at `len - ellipsisChars.length`, and adds the `ellipsisChars` to the\n     * end of the string (by default, two periods: '..'). If the `str` length does not exceed\n     * `len`, the string will be returned unchanged.\n     *\n     * @param {String} str The string to truncate and add an ellipsis to.\n     * @param {Number} truncateLen The length to truncate the string at.\n     * @param {String} [ellipsisChars=...] The ellipsis character(s) to add to the end of `str`\n     *   when truncated. Defaults to '...'\n     */\n    function ellipsis(str, truncateLen, ellipsisChars) {\n        var ellipsisLength;\n        if (str.length > truncateLen) {\n            if (ellipsisChars == null) {\n                ellipsisChars = '&hellip;';\n                ellipsisLength = 3;\n            }\n            else {\n                ellipsisLength = ellipsisChars.length;\n            }\n            str = str.substring(0, truncateLen - ellipsisLength) + ellipsisChars;\n        }\n        return str;\n    }\n    /**\n     * Supports `Array.prototype.indexOf()` functionality for old IE (IE8 and below).\n     *\n     * @param {Array} arr The array to find an element of.\n     * @param {*} element The element to find in the array, and return the index of.\n     * @return {Number} The index of the `element`, or -1 if it was not found.\n     */\n    function indexOf(arr, element) {\n        if (Array.prototype.indexOf) {\n            return arr.indexOf(element);\n        }\n        else {\n            for (var i = 0, len = arr.length; i < len; i++) {\n                if (arr[i] === element)\n                    return i;\n            }\n            return -1;\n        }\n    }\n    /**\n     * Removes array elements based on a filtering function. Mutates the input\n     * array.\n     *\n     * Using this instead of the ES5 Array.prototype.filter() function, to allow\n     * Autolinker compatibility with IE8, and also to prevent creating many new\n     * arrays in memory for filtering.\n     *\n     * @param {Array} arr The array to remove elements from. This array is\n     *   mutated.\n     * @param {Function} fn A function which should return `true` to\n     *   remove an element.\n     * @return {Array} The mutated input `arr`.\n     */\n    function remove(arr, fn) {\n        for (var i = arr.length - 1; i >= 0; i--) {\n            if (fn(arr[i]) === true) {\n                arr.splice(i, 1);\n            }\n        }\n    }\n    /**\n     * Performs the functionality of what modern browsers do when `String.prototype.split()` is called\n     * with a regular expression that contains capturing parenthesis.\n     *\n     * For example:\n     *\n     *     // Modern browsers:\n     *     \"a,b,c\".split( /(,)/ );  // --> [ 'a', ',', 'b', ',', 'c' ]\n     *\n     *     // Old IE (including IE8):\n     *     \"a,b,c\".split( /(,)/ );  // --> [ 'a', 'b', 'c' ]\n     *\n     * This method emulates the functionality of modern browsers for the old IE case.\n     *\n     * @param {String} str The string to split.\n     * @param {RegExp} splitRegex The regular expression to split the input `str` on. The splitting\n     *   character(s) will be spliced into the array, as in the \"modern browsers\" example in the\n     *   description of this method.\n     *   Note #1: the supplied regular expression **must** have the 'g' flag specified.\n     *   Note #2: for simplicity's sake, the regular expression does not need\n     *   to contain capturing parenthesis - it will be assumed that any match has them.\n     * @return {String[]} The split array of strings, with the splitting character(s) included.\n     */\n    function splitAndCapture(str, splitRegex) {\n        if (!splitRegex.global)\n            throw new Error(\"`splitRegex` must have the 'g' flag set\");\n        var result = [], lastIdx = 0, match;\n        while (match = splitRegex.exec(str)) {\n            result.push(str.substring(lastIdx, match.index));\n            result.push(match[0]); // push the splitting char(s)\n            lastIdx = match.index + match[0].length;\n        }\n        result.push(str.substring(lastIdx));\n        return result;\n    }\n\n    /**\n     * @class Autolinker.HtmlTag\n     * @extends Object\n     *\n     * Represents an HTML tag, which can be used to easily build/modify HTML tags programmatically.\n     *\n     * Autolinker uses this abstraction to create HTML tags, and then write them out as strings. You may also use\n     * this class in your code, especially within a {@link Autolinker#replaceFn replaceFn}.\n     *\n     * ## Examples\n     *\n     * Example instantiation:\n     *\n     *     var tag = new Autolinker.HtmlTag( {\n     *         tagName : 'a',\n     *         attrs   : { 'href': 'http://google.com', 'class': 'external-link' },\n     *         innerHtml : 'Google'\n     *     } );\n     *\n     *     tag.toAnchorString();  // <a href=\"http://google.com\" class=\"external-link\">Google</a>\n     *\n     *     // Individual accessor methods\n     *     tag.getTagName();                 // 'a'\n     *     tag.getAttr( 'href' );            // 'http://google.com'\n     *     tag.hasClass( 'external-link' );  // true\n     *\n     *\n     * Using mutator methods (which may be used in combination with instantiation config properties):\n     *\n     *     var tag = new Autolinker.HtmlTag();\n     *     tag.setTagName( 'a' );\n     *     tag.setAttr( 'href', 'http://google.com' );\n     *     tag.addClass( 'external-link' );\n     *     tag.setInnerHtml( 'Google' );\n     *\n     *     tag.getTagName();                 // 'a'\n     *     tag.getAttr( 'href' );            // 'http://google.com'\n     *     tag.hasClass( 'external-link' );  // true\n     *\n     *     tag.toAnchorString();  // <a href=\"http://google.com\" class=\"external-link\">Google</a>\n     *\n     *\n     * ## Example use within a {@link Autolinker#replaceFn replaceFn}\n     *\n     *     var html = Autolinker.link( \"Test google.com\", {\n     *         replaceFn : function( match ) {\n     *             var tag = match.buildTag();  // returns an {@link Autolinker.HtmlTag} instance, configured with the Match's href and anchor text\n     *             tag.setAttr( 'rel', 'nofollow' );\n     *\n     *             return tag;\n     *         }\n     *     } );\n     *\n     *     // generated html:\n     *     //   Test <a href=\"http://google.com\" target=\"_blank\" rel=\"nofollow\">google.com</a>\n     *\n     *\n     * ## Example use with a new tag for the replacement\n     *\n     *     var html = Autolinker.link( \"Test google.com\", {\n     *         replaceFn : function( match ) {\n     *             var tag = new Autolinker.HtmlTag( {\n     *                 tagName : 'button',\n     *                 attrs   : { 'title': 'Load URL: ' + match.getAnchorHref() },\n     *                 innerHtml : 'Load URL: ' + match.getAnchorText()\n     *             } );\n     *\n     *             return tag;\n     *         }\n     *     } );\n     *\n     *     // generated html:\n     *     //   Test <button title=\"Load URL: http://google.com\">Load URL: google.com</button>\n     */\n    var HtmlTag = /** @class */ (function () {\n        /**\n         * @constructor\n         * @param {Object} [cfg] The configuration properties for this class, in an Object (map)\n         */\n        function HtmlTag(cfg) {\n            if (cfg === void 0) { cfg = {}; }\n            /**\n             * @protected\n             * @property {RegExp} whitespaceRegex\n             *\n             * Regular expression used to match whitespace in a string of CSS classes.\n             */\n            this.whitespaceRegex = /\\s+/;\n            this.tagName = cfg.tagName || '';\n            this.attrs = cfg.attrs || {};\n            this.innerHTML = cfg.innerHtml || cfg.innerHTML || ''; // accept either the camelCased form or the fully capitalized acronym as in the DOM\n        }\n        /**\n         * Sets the tag name that will be used to generate the tag with.\n         *\n         * @param {String} tagName\n         * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n         */\n        HtmlTag.prototype.setTagName = function (tagName) {\n            this.tagName = tagName;\n            return this;\n        };\n        /**\n         * Retrieves the tag name.\n         *\n         * @return {String}\n         */\n        HtmlTag.prototype.getTagName = function () {\n            return this.tagName || '';\n        };\n        /**\n         * Sets an attribute on the HtmlTag.\n         *\n         * @param {String} attrName The attribute name to set.\n         * @param {String} attrValue The attribute value to set.\n         * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n         */\n        HtmlTag.prototype.setAttr = function (attrName, attrValue) {\n            var tagAttrs = this.getAttrs();\n            tagAttrs[attrName] = attrValue;\n            return this;\n        };\n        /**\n         * Retrieves an attribute from the HtmlTag. If the attribute does not exist, returns `undefined`.\n         *\n         * @param {String} attrName The attribute name to retrieve.\n         * @return {String} The attribute's value, or `undefined` if it does not exist on the HtmlTag.\n         */\n        HtmlTag.prototype.getAttr = function (attrName) {\n            return this.getAttrs()[attrName];\n        };\n        /**\n         * Sets one or more attributes on the HtmlTag.\n         *\n         * @param {Object.<String, String>} attrs A key/value Object (map) of the attributes to set.\n         * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n         */\n        HtmlTag.prototype.setAttrs = function (attrs) {\n            Object.assign(this.getAttrs(), attrs);\n            return this;\n        };\n        /**\n         * Retrieves the attributes Object (map) for the HtmlTag.\n         *\n         * @return {Object.<String, String>} A key/value object of the attributes for the HtmlTag.\n         */\n        HtmlTag.prototype.getAttrs = function () {\n            return this.attrs || (this.attrs = {});\n        };\n        /**\n         * Sets the provided `cssClass`, overwriting any current CSS classes on the HtmlTag.\n         *\n         * @param {String} cssClass One or more space-separated CSS classes to set (overwrite).\n         * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n         */\n        HtmlTag.prototype.setClass = function (cssClass) {\n            return this.setAttr('class', cssClass);\n        };\n        /**\n         * Convenience method to add one or more CSS classes to the HtmlTag. Will not add duplicate CSS classes.\n         *\n         * @param {String} cssClass One or more space-separated CSS classes to add.\n         * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n         */\n        HtmlTag.prototype.addClass = function (cssClass) {\n            var classAttr = this.getClass(), whitespaceRegex = this.whitespaceRegex, classes = (!classAttr) ? [] : classAttr.split(whitespaceRegex), newClasses = cssClass.split(whitespaceRegex), newClass;\n            while (newClass = newClasses.shift()) {\n                if (indexOf(classes, newClass) === -1) {\n                    classes.push(newClass);\n                }\n            }\n            this.getAttrs()['class'] = classes.join(\" \");\n            return this;\n        };\n        /**\n         * Convenience method to remove one or more CSS classes from the HtmlTag.\n         *\n         * @param {String} cssClass One or more space-separated CSS classes to remove.\n         * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n         */\n        HtmlTag.prototype.removeClass = function (cssClass) {\n            var classAttr = this.getClass(), whitespaceRegex = this.whitespaceRegex, classes = (!classAttr) ? [] : classAttr.split(whitespaceRegex), removeClasses = cssClass.split(whitespaceRegex), removeClass;\n            while (classes.length && (removeClass = removeClasses.shift())) {\n                var idx = indexOf(classes, removeClass);\n                if (idx !== -1) {\n                    classes.splice(idx, 1);\n                }\n            }\n            this.getAttrs()['class'] = classes.join(\" \");\n            return this;\n        };\n        /**\n         * Convenience method to retrieve the CSS class(es) for the HtmlTag, which will each be separated by spaces when\n         * there are multiple.\n         *\n         * @return {String}\n         */\n        HtmlTag.prototype.getClass = function () {\n            return this.getAttrs()['class'] || \"\";\n        };\n        /**\n         * Convenience method to check if the tag has a CSS class or not.\n         *\n         * @param {String} cssClass The CSS class to check for.\n         * @return {Boolean} `true` if the HtmlTag has the CSS class, `false` otherwise.\n         */\n        HtmlTag.prototype.hasClass = function (cssClass) {\n            return (' ' + this.getClass() + ' ').indexOf(' ' + cssClass + ' ') !== -1;\n        };\n        /**\n         * Sets the inner HTML for the tag.\n         *\n         * @param {String} html The inner HTML to set.\n         * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n         */\n        HtmlTag.prototype.setInnerHTML = function (html) {\n            this.innerHTML = html;\n            return this;\n        };\n        /**\n         * Backwards compatibility method name.\n         *\n         * @param {String} html The inner HTML to set.\n         * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n         */\n        HtmlTag.prototype.setInnerHtml = function (html) {\n            return this.setInnerHTML(html);\n        };\n        /**\n         * Retrieves the inner HTML for the tag.\n         *\n         * @return {String}\n         */\n        HtmlTag.prototype.getInnerHTML = function () {\n            return this.innerHTML || \"\";\n        };\n        /**\n         * Backward compatibility method name.\n         *\n         * @return {String}\n         */\n        HtmlTag.prototype.getInnerHtml = function () {\n            return this.getInnerHTML();\n        };\n        /**\n         * Override of superclass method used to generate the HTML string for the tag.\n         *\n         * @return {String}\n         */\n        HtmlTag.prototype.toAnchorString = function () {\n            var tagName = this.getTagName(), attrsStr = this.buildAttrsStr();\n            attrsStr = (attrsStr) ? ' ' + attrsStr : ''; // prepend a space if there are actually attributes\n            return ['<', tagName, attrsStr, '>', this.getInnerHtml(), '</', tagName, '>'].join(\"\");\n        };\n        /**\n         * Support method for {@link #toAnchorString}, returns the string space-separated key=\"value\" pairs, used to populate\n         * the stringified HtmlTag.\n         *\n         * @protected\n         * @return {String} Example return: `attr1=\"value1\" attr2=\"value2\"`\n         */\n        HtmlTag.prototype.buildAttrsStr = function () {\n            if (!this.attrs)\n                return \"\"; // no `attrs` Object (map) has been set, return empty string\n            var attrs = this.getAttrs(), attrsArr = [];\n            for (var prop in attrs) {\n                if (attrs.hasOwnProperty(prop)) {\n                    attrsArr.push(prop + '=\"' + attrs[prop] + '\"');\n                }\n            }\n            return attrsArr.join(\" \");\n        };\n        return HtmlTag;\n    }());\n\n    /**\n     * Date: 2015-10-05\n     * Author: Kasper Sfren <soefritz@gmail.com> (https://github.com/kafoso)\n     *\n     * A truncation feature, where the ellipsis will be placed at a section within\n     * the URL making it still somewhat human readable.\n     *\n     * @param {String} url\t\t\t\t\t\t A URL.\n     * @param {Number} truncateLen\t\t The maximum length of the truncated output URL string.\n     * @param {String} ellipsisChars\t The characters to place within the url, e.g. \"...\".\n     * @return {String} The truncated URL.\n     */\n    function truncateSmart(url, truncateLen, ellipsisChars) {\n        var ellipsisLengthBeforeParsing;\n        var ellipsisLength;\n        if (ellipsisChars == null) {\n            ellipsisChars = '&hellip;';\n            ellipsisLength = 3;\n            ellipsisLengthBeforeParsing = 8;\n        }\n        else {\n            ellipsisLength = ellipsisChars.length;\n            ellipsisLengthBeforeParsing = ellipsisChars.length;\n        }\n        var parse_url = function (url) {\n            var urlObj = {};\n            var urlSub = url;\n            var match = urlSub.match(/^([a-z]+):\\/\\//i);\n            if (match) {\n                urlObj.scheme = match[1];\n                urlSub = urlSub.substr(match[0].length);\n            }\n            match = urlSub.match(/^(.*?)(?=(\\?|#|\\/|$))/i);\n            if (match) {\n                urlObj.host = match[1];\n                urlSub = urlSub.substr(match[0].length);\n            }\n            match = urlSub.match(/^\\/(.*?)(?=(\\?|#|$))/i);\n            if (match) {\n                urlObj.path = match[1];\n                urlSub = urlSub.substr(match[0].length);\n            }\n            match = urlSub.match(/^\\?(.*?)(?=(#|$))/i);\n            if (match) {\n                urlObj.query = match[1];\n                urlSub = urlSub.substr(match[0].length);\n            }\n            match = urlSub.match(/^#(.*?)$/i);\n            if (match) {\n                urlObj.fragment = match[1];\n                //urlSub = urlSub.substr(match[0].length);  -- not used. Uncomment if adding another block.\n            }\n            return urlObj;\n        };\n        var buildUrl = function (urlObj) {\n            var url = \"\";\n            if (urlObj.scheme && urlObj.host) {\n                url += urlObj.scheme + \"://\";\n            }\n            if (urlObj.host) {\n                url += urlObj.host;\n            }\n            if (urlObj.path) {\n                url += \"/\" + urlObj.path;\n            }\n            if (urlObj.query) {\n                url += \"?\" + urlObj.query;\n            }\n            if (urlObj.fragment) {\n                url += \"#\" + urlObj.fragment;\n            }\n            return url;\n        };\n        var buildSegment = function (segment, remainingAvailableLength) {\n            var remainingAvailableLengthHalf = remainingAvailableLength / 2, startOffset = Math.ceil(remainingAvailableLengthHalf), endOffset = (-1) * Math.floor(remainingAvailableLengthHalf), end = \"\";\n            if (endOffset < 0) {\n                end = segment.substr(endOffset);\n            }\n            return segment.substr(0, startOffset) + ellipsisChars + end;\n        };\n        if (url.length <= truncateLen) {\n            return url;\n        }\n        var availableLength = truncateLen - ellipsisLength;\n        var urlObj = parse_url(url);\n        // Clean up the URL\n        if (urlObj.query) {\n            var matchQuery = urlObj.query.match(/^(.*?)(?=(\\?|\\#))(.*?)$/i);\n            if (matchQuery) {\n                // Malformed URL; two or more \"?\". Removed any content behind the 2nd.\n                urlObj.query = urlObj.query.substr(0, matchQuery[1].length);\n                url = buildUrl(urlObj);\n            }\n        }\n        if (url.length <= truncateLen) {\n            return url;\n        }\n        if (urlObj.host) {\n            urlObj.host = urlObj.host.replace(/^www\\./, \"\");\n            url = buildUrl(urlObj);\n        }\n        if (url.length <= truncateLen) {\n            return url;\n        }\n        // Process and build the URL\n        var str = \"\";\n        if (urlObj.host) {\n            str += urlObj.host;\n        }\n        if (str.length >= availableLength) {\n            if (urlObj.host.length == truncateLen) {\n                return (urlObj.host.substr(0, (truncateLen - ellipsisLength)) + ellipsisChars).substr(0, availableLength + ellipsisLengthBeforeParsing);\n            }\n            return buildSegment(str, availableLength).substr(0, availableLength + ellipsisLengthBeforeParsing);\n        }\n        var pathAndQuery = \"\";\n        if (urlObj.path) {\n            pathAndQuery += \"/\" + urlObj.path;\n        }\n        if (urlObj.query) {\n            pathAndQuery += \"?\" + urlObj.query;\n        }\n        if (pathAndQuery) {\n            if ((str + pathAndQuery).length >= availableLength) {\n                if ((str + pathAndQuery).length == truncateLen) {\n                    return (str + pathAndQuery).substr(0, truncateLen);\n                }\n                var remainingAvailableLength = availableLength - str.length;\n                return (str + buildSegment(pathAndQuery, remainingAvailableLength)).substr(0, availableLength + ellipsisLengthBeforeParsing);\n            }\n            else {\n                str += pathAndQuery;\n            }\n        }\n        if (urlObj.fragment) {\n            var fragment = \"#\" + urlObj.fragment;\n            if ((str + fragment).length >= availableLength) {\n                if ((str + fragment).length == truncateLen) {\n                    return (str + fragment).substr(0, truncateLen);\n                }\n                var remainingAvailableLength2 = availableLength - str.length;\n                return (str + buildSegment(fragment, remainingAvailableLength2)).substr(0, availableLength + ellipsisLengthBeforeParsing);\n            }\n            else {\n                str += fragment;\n            }\n        }\n        if (urlObj.scheme && urlObj.host) {\n            var scheme = urlObj.scheme + \"://\";\n            if ((str + scheme).length < availableLength) {\n                return (scheme + str).substr(0, truncateLen);\n            }\n        }\n        if (str.length <= truncateLen) {\n            return str;\n        }\n        var end = \"\";\n        if (availableLength > 0) {\n            end = str.substr((-1) * Math.floor(availableLength / 2));\n        }\n        return (str.substr(0, Math.ceil(availableLength / 2)) + ellipsisChars + end).substr(0, availableLength + ellipsisLengthBeforeParsing);\n    }\n\n    /**\n     * Date: 2015-10-05\n     * Author: Kasper Sfren <soefritz@gmail.com> (https://github.com/kafoso)\n     *\n     * A truncation feature, where the ellipsis will be placed in the dead-center of the URL.\n     *\n     * @param {String} url             A URL.\n     * @param {Number} truncateLen     The maximum length of the truncated output URL string.\n     * @param {String} ellipsisChars   The characters to place within the url, e.g. \"..\".\n     * @return {String} The truncated URL.\n     */\n    function truncateMiddle(url, truncateLen, ellipsisChars) {\n        if (url.length <= truncateLen) {\n            return url;\n        }\n        var ellipsisLengthBeforeParsing;\n        var ellipsisLength;\n        if (ellipsisChars == null) {\n            ellipsisChars = '&hellip;';\n            ellipsisLengthBeforeParsing = 8;\n            ellipsisLength = 3;\n        }\n        else {\n            ellipsisLengthBeforeParsing = ellipsisChars.length;\n            ellipsisLength = ellipsisChars.length;\n        }\n        var availableLength = truncateLen - ellipsisLength;\n        var end = \"\";\n        if (availableLength > 0) {\n            end = url.substr((-1) * Math.floor(availableLength / 2));\n        }\n        return (url.substr(0, Math.ceil(availableLength / 2)) + ellipsisChars + end).substr(0, availableLength + ellipsisLengthBeforeParsing);\n    }\n\n    /**\n     * A truncation feature where the ellipsis will be placed at the end of the URL.\n     *\n     * @param {String} anchorText\n     * @param {Number} truncateLen The maximum length of the truncated output URL string.\n     * @param {String} ellipsisChars The characters to place within the url, e.g. \"..\".\n     * @return {String} The truncated URL.\n     */\n    function truncateEnd(anchorText, truncateLen, ellipsisChars) {\n        return ellipsis(anchorText, truncateLen, ellipsisChars);\n    }\n\n    /**\n     * @protected\n     * @class Autolinker.AnchorTagBuilder\n     * @extends Object\n     *\n     * Builds anchor (&lt;a&gt;) tags for the Autolinker utility when a match is\n     * found.\n     *\n     * Normally this class is instantiated, configured, and used internally by an\n     * {@link Autolinker} instance, but may actually be used indirectly in a\n     * {@link Autolinker#replaceFn replaceFn} to create {@link Autolinker.HtmlTag HtmlTag}\n     * instances which may be modified before returning from the\n     * {@link Autolinker#replaceFn replaceFn}. For example:\n     *\n     *     var html = Autolinker.link( \"Test google.com\", {\n     *         replaceFn : function( match ) {\n     *             var tag = match.buildTag();  // returns an {@link Autolinker.HtmlTag} instance\n     *             tag.setAttr( 'rel', 'nofollow' );\n     *\n     *             return tag;\n     *         }\n     *     } );\n     *\n     *     // generated html:\n     *     //   Test <a href=\"http://google.com\" target=\"_blank\" rel=\"nofollow\">google.com</a>\n     */\n    var AnchorTagBuilder = /** @class */ (function () {\n        /**\n         * @constructor\n         * @param {Object} [cfg] The configuration options for the AnchorTagBuilder instance, specified in an Object (map).\n         */\n        function AnchorTagBuilder(cfg) {\n            if (cfg === void 0) { cfg = {}; }\n            this.newWindow = cfg.newWindow || false;\n            this.truncate = cfg.truncate || {};\n            this.className = cfg.className || '';\n        }\n        /**\n         * Generates the actual anchor (&lt;a&gt;) tag to use in place of the\n         * matched text, via its `match` object.\n         *\n         * @param {Autolinker.match.Match} match The Match instance to generate an\n         *   anchor tag from.\n         * @return {Autolinker.HtmlTag} The HtmlTag instance for the anchor tag.\n         */\n        AnchorTagBuilder.prototype.build = function (match) {\n            return new HtmlTag({\n                tagName: 'a',\n                attrs: this.createAttrs(match),\n                innerHtml: this.processAnchorText(match.getAnchorText())\n            });\n        };\n        /**\n         * Creates the Object (map) of the HTML attributes for the anchor (&lt;a&gt;)\n         *   tag being generated.\n         *\n         * @protected\n         * @param {Autolinker.match.Match} match The Match instance to generate an\n         *   anchor tag from.\n         * @return {Object} A key/value Object (map) of the anchor tag's attributes.\n         */\n        AnchorTagBuilder.prototype.createAttrs = function (match) {\n            var attrs = {\n                'href': match.getAnchorHref() // we'll always have the `href` attribute\n            };\n            var cssClass = this.createCssClass(match);\n            if (cssClass) {\n                attrs['class'] = cssClass;\n            }\n            if (this.newWindow) {\n                attrs['target'] = \"_blank\";\n                attrs['rel'] = \"noopener noreferrer\";\n            }\n            if (this.truncate) {\n                if (this.truncate.length && this.truncate.length < match.getAnchorText().length) {\n                    attrs['title'] = match.getAnchorHref();\n                }\n            }\n            return attrs;\n        };\n        /**\n         * Creates the CSS class that will be used for a given anchor tag, based on\n         * the `matchType` and the {@link #className} config.\n         *\n         * Example returns:\n         *\n         * - \"\"                                      // no {@link #className}\n         * - \"myLink myLink-url\"                     // url match\n         * - \"myLink myLink-email\"                   // email match\n         * - \"myLink myLink-phone\"                   // phone match\n         * - \"myLink myLink-hashtag\"                 // hashtag match\n         * - \"myLink myLink-mention myLink-twitter\"  // mention match with Twitter service\n         *\n         * @private\n         * @param {Autolinker.match.Match} match The Match instance to generate an\n         *   anchor tag from.\n         * @return {String} The CSS class string for the link. Example return:\n         *   \"myLink myLink-url\". If no {@link #className} was configured, returns\n         *   an empty string.\n         */\n        AnchorTagBuilder.prototype.createCssClass = function (match) {\n            var className = this.className;\n            if (!className) {\n                return \"\";\n            }\n            else {\n                var returnClasses = [className], cssClassSuffixes = match.getCssClassSuffixes();\n                for (var i = 0, len = cssClassSuffixes.length; i < len; i++) {\n                    returnClasses.push(className + '-' + cssClassSuffixes[i]);\n                }\n                return returnClasses.join(' ');\n            }\n        };\n        /**\n         * Processes the `anchorText` by truncating the text according to the\n         * {@link #truncate} config.\n         *\n         * @private\n         * @param {String} anchorText The anchor tag's text (i.e. what will be\n         *   displayed).\n         * @return {String} The processed `anchorText`.\n         */\n        AnchorTagBuilder.prototype.processAnchorText = function (anchorText) {\n            anchorText = this.doTruncate(anchorText);\n            return anchorText;\n        };\n        /**\n         * Performs the truncation of the `anchorText` based on the {@link #truncate}\n         * option. If the `anchorText` is longer than the length specified by the\n         * {@link #truncate} option, the truncation is performed based on the\n         * `location` property. See {@link #truncate} for details.\n         *\n         * @private\n         * @param {String} anchorText The anchor tag's text (i.e. what will be\n         *   displayed).\n         * @return {String} The truncated anchor text.\n         */\n        AnchorTagBuilder.prototype.doTruncate = function (anchorText) {\n            var truncate = this.truncate;\n            if (!truncate || !truncate.length)\n                return anchorText;\n            var truncateLength = truncate.length, truncateLocation = truncate.location;\n            if (truncateLocation === 'smart') {\n                return truncateSmart(anchorText, truncateLength);\n            }\n            else if (truncateLocation === 'middle') {\n                return truncateMiddle(anchorText, truncateLength);\n            }\n            else {\n                return truncateEnd(anchorText, truncateLength);\n            }\n        };\n        return AnchorTagBuilder;\n    }());\n\n    /**\n     * @abstract\n     * @class Autolinker.htmlParser.HtmlNode\n     *\n     * Represents an HTML node found in an input string. An HTML node is one of the\n     * following:\n     *\n     * 1. An {@link Autolinker.htmlParser.ElementNode ElementNode}, which represents\n     *    HTML tags.\n     * 2. A {@link Autolinker.htmlParser.CommentNode CommentNode}, which represents\n     *    HTML comments.\n     * 3. A {@link Autolinker.htmlParser.TextNode TextNode}, which represents text\n     *    outside or within HTML tags.\n     * 4. A {@link Autolinker.htmlParser.EntityNode EntityNode}, which represents\n     *    one of the known HTML entities that Autolinker looks for. This includes\n     *    common ones such as &amp;quot; and &amp;nbsp;\n     */\n    var HtmlNode = /** @class */ (function () {\n        /**\n         * @constructor\n         * @param {Object} cfg The configuration properties for the Match instance,\n         * specified in an Object (map).\n         */\n        function HtmlNode(cfg) {\n            this.offset = cfg.offset;\n            this.text = cfg.text;\n        }\n        /**\n         * Retrieves the {@link #offset} of the HtmlNode. This is the offset of the\n         * HTML node in the original string that was parsed.\n         *\n         * @return {Number}\n         */\n        HtmlNode.prototype.getOffset = function () {\n            return this.offset;\n        };\n        /**\n         * Retrieves the {@link #text} for the HtmlNode.\n         *\n         * @return {String}\n         */\n        HtmlNode.prototype.getText = function () {\n            return this.text;\n        };\n        return HtmlNode;\n    }());\n\n    var __extends = (undefined && undefined.__extends) || (function () {\n        var extendStatics = function (d, b) {\n            extendStatics = Object.setPrototypeOf ||\n                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n            return extendStatics(d, b);\n        };\n        return function (d, b) {\n            extendStatics(d, b);\n            function __() { this.constructor = d; }\n            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n        };\n    })();\n    /**\n     * @class Autolinker.htmlParser.CommentNode\n     * @extends Autolinker.htmlParser.HtmlNode\n     *\n     * Represents an HTML comment node that has been parsed by the\n     * {@link Autolinker.htmlParser.HtmlParser}.\n     *\n     * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more\n     * details.\n     */\n    var CommentNode = /** @class */ (function (_super) {\n        __extends(CommentNode, _super);\n        function CommentNode(cfg) {\n            var _this = _super.call(this, cfg) || this;\n            _this.comment = cfg.comment;\n            return _this;\n        }\n        /**\n         * Returns a string name for the type of node that this class represents.\n         *\n         * @return {String}\n         */\n        CommentNode.prototype.getType = function () {\n            return 'comment';\n        };\n        /**\n         * Returns the comment inside the comment tag.\n         *\n         * @return {String}\n         */\n        CommentNode.prototype.getComment = function () {\n            return this.comment;\n        };\n        return CommentNode;\n    }(HtmlNode));\n\n    var __extends$1 = (undefined && undefined.__extends) || (function () {\n        var extendStatics = function (d, b) {\n            extendStatics = Object.setPrototypeOf ||\n                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n            return extendStatics(d, b);\n        };\n        return function (d, b) {\n            extendStatics(d, b);\n            function __() { this.constructor = d; }\n            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n        };\n    })();\n    var ElementNode = /** @class */ (function (_super) {\n        __extends$1(ElementNode, _super);\n        function ElementNode(cfg) {\n            var _this = _super.call(this, cfg) || this;\n            _this.tagName = cfg.tagName;\n            _this.closing = cfg.closing;\n            return _this;\n        }\n        /**\n         * Returns a string name for the type of node that this class represents.\n         *\n         * @return {String}\n         */\n        ElementNode.prototype.getType = function () {\n            return 'element';\n        };\n        /**\n         * Returns the HTML element's (tag's) name. Ex: for an &lt;img&gt; tag,\n         * returns \"img\".\n         *\n         * @return {String}\n         */\n        ElementNode.prototype.getTagName = function () {\n            return this.tagName;\n        };\n        /**\n         * Determines if the HTML element (tag) is a closing tag. Ex: &lt;div&gt;\n         * returns `false`, while &lt;/div&gt; returns `true`.\n         *\n         * @return {Boolean}\n         */\n        ElementNode.prototype.isClosing = function () {\n            return this.closing;\n        };\n        return ElementNode;\n    }(HtmlNode));\n\n    var __extends$2 = (undefined && undefined.__extends) || (function () {\n        var extendStatics = function (d, b) {\n            extendStatics = Object.setPrototypeOf ||\n                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n            return extendStatics(d, b);\n        };\n        return function (d, b) {\n            extendStatics(d, b);\n            function __() { this.constructor = d; }\n            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n        };\n    })();\n    var EntityNode = /** @class */ (function (_super) {\n        __extends$2(EntityNode, _super);\n        function EntityNode() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        /**\n         * Returns a string name for the type of node that this class represents.\n         *\n         * @return {String}\n         */\n        EntityNode.prototype.getType = function () {\n            return 'entity';\n        };\n        return EntityNode;\n    }(HtmlNode));\n\n    var __extends$3 = (undefined && undefined.__extends) || (function () {\n        var extendStatics = function (d, b) {\n            extendStatics = Object.setPrototypeOf ||\n                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n            return extendStatics(d, b);\n        };\n        return function (d, b) {\n            extendStatics(d, b);\n            function __() { this.constructor = d; }\n            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n        };\n    })();\n    /**\n     * @class Autolinker.htmlParser.TextNode\n     * @extends Autolinker.htmlParser.HtmlNode\n     *\n     * Represents a text node that has been parsed by the {@link Autolinker.htmlParser.HtmlParser}.\n     *\n     * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more\n     * details.\n     */\n    var TextNode = /** @class */ (function (_super) {\n        __extends$3(TextNode, _super);\n        function TextNode() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        /**\n         * Returns a string name for the type of node that this class represents.\n         *\n         * @return {String}\n         */\n        TextNode.prototype.getType = function () {\n            return 'text';\n        };\n        return TextNode;\n    }(HtmlNode));\n\n    /**\n     * @private\n     * @property {RegExp} htmlRegex\n     *\n     * The regular expression used to pull out HTML tags from a string. Handles namespaced HTML tags and\n     * attribute names, as specified by http://www.w3.org/TR/html-markup/syntax.html.\n     *\n     * Capturing groups:\n     *\n     * 1. The \"!DOCTYPE\" tag name, if a tag is a &lt;!DOCTYPE&gt; tag.\n     * 2. If it is an end tag, this group will have the '/'.\n     * 3. If it is a comment tag, this group will hold the comment text (i.e.\n     *    the text inside the `&lt;!--` and `--&gt;`.\n     * 4. The tag name for a tag without attributes (other than the &lt;!DOCTYPE&gt; tag)\n     * 5. The tag name for a tag with attributes (other than the &lt;!DOCTYPE&gt; tag)\n     */\n    var htmlRegex = (function () {\n        var commentTagRegex = /!--([\\s\\S]+?)--/, tagNameRegex = /[0-9a-zA-Z][0-9a-zA-Z:]*/, attrNameRegex = /[^\\s\"'>\\/=\\x00-\\x1F\\x7F]+/, // the unicode range accounts for excluding control chars, and the delete char\n        attrValueRegex = /(?:\"[^\"]*?\"|'[^']*?'|[^'\"=<>`\\s]+)/, // double quoted, single quoted, or unquoted attribute values\n        optionalAttrValueRegex = '(?:\\\\s*?=\\\\s*?' + attrValueRegex.source + ')?'; // optional '=[value]'\n        var getNameEqualsValueRegex = function (group) {\n            return '(?=(' + attrNameRegex.source + '))\\\\' + group + optionalAttrValueRegex;\n        };\n        return new RegExp([\n            // for <!DOCTYPE> tag. Ex: <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">)\n            '(?:',\n            '<(!DOCTYPE)',\n            // Zero or more attributes following the tag name\n            '(?:',\n            '\\\\s+',\n            // Either:\n            // A. attr=\"value\", or\n            // B. \"value\" alone (To cover example doctype tag: <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">)\n            // *** Capturing Group 2 - Pseudo-atomic group for attrNameRegex\n            '(?:', getNameEqualsValueRegex(2), '|', attrValueRegex.source + ')',\n            ')*',\n            '>',\n            ')',\n            '|',\n            // All other HTML tags (i.e. tags that are not <!DOCTYPE>)\n            '(?:',\n            '<(/)?',\n            // *** Capturing Group 3: The slash or an empty string. Slash ('/') for end tag, empty string for start or self-closing tag.\n            '(?:',\n            commentTagRegex.source,\n            '|',\n            // Handle tag without attributes.\n            // Doing this separately from a tag that has attributes\n            // to fix a regex time complexity issue seen with the\n            // example in https://github.com/gregjacobs/Autolinker.js/issues/172\n            '(?:',\n            // *** Capturing Group 5 - The tag name for a tag without attributes\n            '(' + tagNameRegex.source + ')',\n            '\\\\s*/?',\n            ')',\n            '|',\n            // Handle tag with attributes\n            // Doing this separately from a tag with no attributes\n            // to fix a regex time complexity issue seen with the\n            // example in https://github.com/gregjacobs/Autolinker.js/issues/172\n            '(?:',\n            // *** Capturing Group 6 - The tag name for a tag with attributes\n            '(' + tagNameRegex.source + ')',\n            '\\\\s+',\n            // Zero or more attributes following the tag name\n            '(?:',\n            '(?:\\\\s+|\\\\b)',\n            // *** Capturing Group 7 - Pseudo-atomic group for attrNameRegex\n            getNameEqualsValueRegex(7),\n            ')*',\n            '\\\\s*/?',\n            ')',\n            ')',\n            '>',\n            ')'\n        ].join(\"\"), 'gi');\n    })();\n    /**\n     * @private\n     * @property {RegExp} htmlCharacterEntitiesRegex\n     *\n     * The regular expression that matches common HTML character entities.\n     *\n     * Ignoring &amp; as it could be part of a query string -- handling it separately.\n     */\n    var htmlCharacterEntitiesRegex = /(&nbsp;|&#160;|&lt;|&#60;|&gt;|&#62;|&quot;|&#34;|&#39;)/gi;\n    /**\n     * @class Autolinker.htmlParser.HtmlParser\n     * @extends Object\n     *\n     * An HTML parser implementation which simply walks an HTML string and returns an array of\n     * {@link Autolinker.htmlParser.HtmlNode HtmlNodes} that represent the basic HTML structure of the input string.\n     *\n     * Autolinker uses this to only link URLs/emails/mentions within text nodes, effectively ignoring / \"walking\n     * around\" HTML tags.\n     */\n    var HtmlParser = /** @class */ (function () {\n        function HtmlParser() {\n        }\n        /**\n         * Parses an HTML string and returns a simple array of {@link Autolinker.htmlParser.HtmlNode HtmlNodes}\n         * to represent the HTML structure of the input string.\n         *\n         * @param {String} html The HTML to parse.\n         * @return {Autolinker.htmlParser.HtmlNode[]}\n         */\n        HtmlParser.prototype.parse = function (html) {\n            var currentResult, lastIndex = 0, textAndEntityNodes, nodes = []; // will be the result of the method\n            while ((currentResult = htmlRegex.exec(html)) !== null) {\n                var tagText = currentResult[0], commentText = currentResult[4], // if we've matched a comment\n                tagName = currentResult[1] || currentResult[5] || currentResult[6], // The <!DOCTYPE> tag (ex: \"!DOCTYPE\"), or another tag (ex: \"a\" or \"img\")\n                isClosingTag = !!currentResult[3], offset = currentResult.index, inBetweenTagsText = html.substring(lastIndex, offset);\n                // Push TextNodes and EntityNodes for any text found between tags\n                if (inBetweenTagsText) {\n                    textAndEntityNodes = this.parseTextAndEntityNodes(lastIndex, inBetweenTagsText);\n                    nodes.push.apply(nodes, textAndEntityNodes);\n                }\n                // Push the CommentNode or ElementNode\n                if (commentText) {\n                    nodes.push(this.createCommentNode(offset, tagText, commentText));\n                }\n                else {\n                    nodes.push(this.createElementNode(offset, tagText, tagName, isClosingTag));\n                }\n                lastIndex = offset + tagText.length;\n            }\n            // Process any remaining text after the last HTML element. Will process all of the text if there were no HTML elements.\n            if (lastIndex < html.length) {\n                var text = html.substring(lastIndex);\n                // Push TextNodes and EntityNodes for any text found between tags\n                if (text) {\n                    textAndEntityNodes = this.parseTextAndEntityNodes(lastIndex, text);\n                    // Note: the following 3 lines were previously:\n                    //   nodes.push.apply( nodes, textAndEntityNodes );\n                    // but this was causing a \"Maximum Call Stack Size Exceeded\"\n                    // error on inputs with a large number of html entities.\n                    textAndEntityNodes.forEach(function (node) { return nodes.push(node); });\n                }\n            }\n            return nodes;\n        };\n        /**\n         * Parses text and HTML entity nodes from a given string. The input string\n         * should not have any HTML tags (elements) within it.\n         *\n         * @private\n         * @param {Number} offset The offset of the text node match within the\n         *   original HTML string.\n         * @param {String} text The string of text to parse. This is from an HTML\n         *   text node.\n         * @return {Autolinker.htmlParser.HtmlNode[]} An array of HtmlNodes to\n         *   represent the {@link Autolinker.htmlParser.TextNode TextNodes} and\n         *   {@link Autolinker.htmlParser.EntityNode EntityNodes} found.\n         */\n        HtmlParser.prototype.parseTextAndEntityNodes = function (offset, text) {\n            var nodes = [], textAndEntityTokens = splitAndCapture(text, htmlCharacterEntitiesRegex); // split at HTML entities, but include the HTML entities in the results array\n            // Every even numbered token is a TextNode, and every odd numbered token is an EntityNode\n            // For example: an input `text` of \"Test &quot;this&quot; today\" would turn into the\n            //   `textAndEntityTokens`: [ 'Test ', '&quot;', 'this', '&quot;', ' today' ]\n            for (var i = 0, len = textAndEntityTokens.length; i < len; i += 2) {\n                var textToken = textAndEntityTokens[i], entityToken = textAndEntityTokens[i + 1];\n                if (textToken) {\n                    nodes.push(this.createTextNode(offset, textToken));\n                    offset += textToken.length;\n                }\n                if (entityToken) {\n                    nodes.push(this.createEntityNode(offset, entityToken));\n                    offset += entityToken.length;\n                }\n            }\n            return nodes;\n        };\n        /**\n         * Factory method to create an {@link Autolinker.htmlParser.CommentNode CommentNode}.\n         *\n         * @private\n         * @param {Number} offset The offset of the match within the original HTML\n         *   string.\n         * @param {String} tagText The full text of the tag (comment) that was\n         *   matched, including its &lt;!-- and --&gt;.\n         * @param {String} commentText The full text of the comment that was matched.\n         */\n        HtmlParser.prototype.createCommentNode = function (offset, tagText, commentText) {\n            return new CommentNode({\n                offset: offset,\n                text: tagText,\n                comment: commentText.trim()\n            });\n        };\n        /**\n         * Factory method to create an {@link Autolinker.htmlParser.ElementNode ElementNode}.\n         *\n         * @private\n         * @param {Number} offset The offset of the match within the original HTML\n         *   string.\n         * @param {String} tagText The full text of the tag (element) that was\n         *   matched, including its attributes.\n         * @param {String} tagName The name of the tag. Ex: An &lt;img&gt; tag would\n         *   be passed to this method as \"img\".\n         * @param {Boolean} isClosingTag `true` if it's a closing tag, false\n         *   otherwise.\n         * @return {Autolinker.htmlParser.ElementNode}\n         */\n        HtmlParser.prototype.createElementNode = function (offset, tagText, tagName, isClosingTag) {\n            return new ElementNode({\n                offset: offset,\n                text: tagText,\n                tagName: tagName.toLowerCase(),\n                closing: isClosingTag\n            });\n        };\n        /**\n         * Factory method to create a {@link Autolinker.htmlParser.EntityNode EntityNode}.\n         *\n         * @private\n         * @param {Number} offset The offset of the match within the original HTML\n         *   string.\n         * @param {String} text The text that was matched for the HTML entity (such\n         *   as '&amp;nbsp;').\n         * @return {Autolinker.htmlParser.EntityNode}\n         */\n        HtmlParser.prototype.createEntityNode = function (offset, text) {\n            return new EntityNode({ offset: offset, text: text });\n        };\n        /**\n         * Factory method to create a {@link Autolinker.htmlParser.TextNode TextNode}.\n         *\n         * @private\n         * @param {Number} offset The offset of the match within the original HTML\n         *   string.\n         * @param {String} text The text that was matched.\n         * @return {Autolinker.htmlParser.TextNode}\n         */\n        HtmlParser.prototype.createTextNode = function (offset, text) {\n            return new TextNode({ offset: offset, text: text });\n        };\n        return HtmlParser;\n    }());\n\n    var Match = /** @class */ (function () {\n        /**\n         * @constructor\n         * @param {Object} cfg The configuration properties for the Match\n         *   instance, specified in an Object (map).\n         */\n        function Match(cfg) {\n            this.tagBuilder = cfg.tagBuilder;\n            this.matchedText = cfg.matchedText;\n            this.offset = cfg.offset;\n        }\n        /**\n         * Returns the original text that was matched.\n         *\n         * @return {String}\n         */\n        Match.prototype.getMatchedText = function () {\n            return this.matchedText;\n        };\n        /**\n         * Sets the {@link #offset} of where the match was made in the input string.\n         *\n         * A {@link Autolinker.matcher.Matcher} will be fed only HTML text nodes,\n         * and will therefore set an original offset that is relative to the HTML\n         * text node itself. However, we want this offset to be relative to the full\n         * HTML input string, and thus if using {@link Autolinker#parse} (rather\n         * than calling a {@link Autolinker.matcher.Matcher} directly), then this\n         * offset is corrected after the Matcher itself has done its job.\n         *\n         * @param {Number} offset\n         */\n        Match.prototype.setOffset = function (offset) {\n            this.offset = offset;\n        };\n        /**\n         * Returns the offset of where the match was made in the input string. This\n         * is the 0-based index of the match.\n         *\n         * @return {Number}\n         */\n        Match.prototype.getOffset = function () {\n            return this.offset;\n        };\n        /**\n         * Returns the CSS class suffix(es) for this match.\n         *\n         * A CSS class suffix is appended to the {@link Autolinker#className} in\n         * the {@link Autolinker.AnchorTagBuilder} when a match is translated into\n         * an anchor tag.\n         *\n         * For example, if {@link Autolinker#className} was configured as 'myLink',\n         * and this method returns `[ 'url' ]`, the final class name of the element\n         * will become: 'myLink myLink-url'.\n         *\n         * The match may provide multiple CSS class suffixes to be appended to the\n         * {@link Autolinker#className} in order to facilitate better styling\n         * options for different match criteria. See {@link Autolinker.match.Mention}\n         * for an example.\n         *\n         * By default, this method returns a single array with the match's\n         * {@link #getType type} name, but may be overridden by subclasses.\n         *\n         * @return {String[]}\n         */\n        Match.prototype.getCssClassSuffixes = function () {\n            return [this.getType()];\n        };\n        /**\n         * Builds and returns an {@link Autolinker.HtmlTag} instance based on the\n         * Match.\n         *\n         * This can be used to easily generate anchor tags from matches, and either\n         * return their HTML string, or modify them before doing so.\n         *\n         * Example Usage:\n         *\n         *     var tag = match.buildTag();\n         *     tag.addClass( 'cordova-link' );\n         *     tag.setAttr( 'target', '_system' );\n         *\n         *     tag.toAnchorString();  // <a href=\"http://google.com\" class=\"cordova-link\" target=\"_system\">Google</a>\n         */\n        Match.prototype.buildTag = function () {\n            return this.tagBuilder.build(this);\n        };\n        return Match;\n    }());\n\n    var __extends$4 = (undefined && undefined.__extends) || (function () {\n        var extendStatics = function (d, b) {\n            extendStatics = Object.setPrototypeOf ||\n                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n            return extendStatics(d, b);\n        };\n        return function (d, b) {\n            extendStatics(d, b);\n            function __() { this.constructor = d; }\n            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n        };\n    })();\n    /**\n     * @class Autolinker.match.Email\n     * @extends Autolinker.match.Match\n     *\n     * Represents a Email match found in an input string which should be Autolinked.\n     *\n     * See this class's superclass ({@link Autolinker.match.Match}) for more details.\n     */\n    var EmailMatch = /** @class */ (function (_super) {\n        __extends$4(EmailMatch, _super);\n        /**\n         * @constructor\n         * @param {Object} cfg The configuration properties for the Match\n         *   instance, specified in an Object (map).\n         */\n        function EmailMatch(cfg) {\n            var _this = _super.call(this, cfg) || this;\n            _this.email = cfg.email;\n            return _this;\n        }\n        /**\n         * Returns a string name for the type of match that this class represents.\n         *\n         * @return {String}\n         */\n        EmailMatch.prototype.getType = function () {\n            return 'email';\n        };\n        /**\n         * Returns the email address that was matched.\n         *\n         * @return {String}\n         */\n        EmailMatch.prototype.getEmail = function () {\n            return this.email;\n        };\n        /**\n         * Returns the anchor href that should be generated for the match.\n         *\n         * @return {String}\n         */\n        EmailMatch.prototype.getAnchorHref = function () {\n            return 'mailto:' + this.email;\n        };\n        /**\n         * Returns the anchor text that should be generated for the match.\n         *\n         * @return {String}\n         */\n        EmailMatch.prototype.getAnchorText = function () {\n            return this.email;\n        };\n        return EmailMatch;\n    }(Match));\n\n    var __extends$5 = (undefined && undefined.__extends) || (function () {\n        var extendStatics = function (d, b) {\n            extendStatics = Object.setPrototypeOf ||\n                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n            return extendStatics(d, b);\n        };\n        return function (d, b) {\n            extendStatics(d, b);\n            function __() { this.constructor = d; }\n            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n        };\n    })();\n    /**\n     * @class Autolinker.match.Hashtag\n     * @extends Autolinker.match.Match\n     *\n     * Represents a HashtagMatch match found in an input string which should be\n     * Autolinked.\n     *\n     * See this class's superclass ({@link Autolinker.match.Match}) for more\n     * details.\n     */\n    var HashtagMatch = /** @class */ (function (_super) {\n        __extends$5(HashtagMatch, _super);\n        /**\n         * @constructor\n         * @param {Object} cfg The configuration properties for the Match\n         *   instance, specified in an Object (map).\n         */\n        function HashtagMatch(cfg) {\n            var _this = _super.call(this, cfg) || this;\n            _this.serviceName = cfg.serviceName;\n            _this.hashtag = cfg.hashtag;\n            return _this;\n        }\n        /**\n         * Returns the type of match that this class represents.\n         *\n         * @return {String}\n         */\n        HashtagMatch.prototype.getType = function () {\n            return 'hashtag';\n        };\n        /**\n         * Returns the configured {@link #serviceName} to point the HashtagMatch to.\n         * Ex: 'facebook', 'twitter'.\n         *\n         * @return {String}\n         */\n        HashtagMatch.prototype.getServiceName = function () {\n            return this.serviceName;\n        };\n        /**\n         * Returns the matched hashtag, without the '#' character.\n         *\n         * @return {String}\n         */\n        HashtagMatch.prototype.getHashtag = function () {\n            return this.hashtag;\n        };\n        /**\n         * Returns the anchor href that should be generated for the match.\n         *\n         * @return {String}\n         */\n        HashtagMatch.prototype.getAnchorHref = function () {\n            var serviceName = this.serviceName, hashtag = this.hashtag;\n            switch (serviceName) {\n                case 'twitter':\n                    return 'https://twitter.com/hashtag/' + hashtag;\n                case 'facebook':\n                    return 'https://www.facebook.com/hashtag/' + hashtag;\n                case 'instagram':\n                    return 'https://instagram.com/explore/tags/' + hashtag;\n                default: // Shouldn't happen because Autolinker's constructor should block any invalid values, but just in case.\n                    throw new Error('Unknown service name to point hashtag to: ' + serviceName);\n            }\n        };\n        /**\n         * Returns the anchor text that should be generated for the match.\n         *\n         * @return {String}\n         */\n        HashtagMatch.prototype.getAnchorText = function () {\n            return '#' + this.hashtag;\n        };\n        return HashtagMatch;\n    }(Match));\n\n    var __extends$6 = (undefined && undefined.__extends) || (function () {\n        var extendStatics = function (d, b) {\n            extendStatics = Object.setPrototypeOf ||\n                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n            return extendStatics(d, b);\n        };\n        return function (d, b) {\n            extendStatics(d, b);\n            function __() { this.constructor = d; }\n            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n        };\n    })();\n    /**\n     * @class Autolinker.match.Mention\n     * @extends Autolinker.match.Match\n     *\n     * Represents a Mention match found in an input string which should be Autolinked.\n     *\n     * See this class's superclass ({@link Autolinker.match.Match}) for more details.\n     */\n    var MentionMatch = /** @class */ (function (_super) {\n        __extends$6(MentionMatch, _super);\n        /**\n         * @constructor\n         * @param {Object} cfg The configuration properties for the Match\n         *   instance, specified in an Object (map).\n         */\n        function MentionMatch(cfg) {\n            var _this = _super.call(this, cfg) || this;\n            _this.mention = cfg.mention;\n            _this.serviceName = cfg.serviceName;\n            return _this;\n        }\n        /**\n         * Returns the type of match that this class represents.\n         *\n         * @return {String}\n         */\n        MentionMatch.prototype.getType = function () {\n            return 'mention';\n        };\n        /**\n         * Returns the mention, without the '@' character.\n         *\n         * @return {String}\n         */\n        MentionMatch.prototype.getMention = function () {\n            return this.mention;\n        };\n        /**\n         * Returns the configured {@link #serviceName} to point the mention to.\n         * Ex: 'instagram', 'twitter', 'soundcloud'.\n         *\n         * @return {String}\n         */\n        MentionMatch.prototype.getServiceName = function () {\n            return this.serviceName;\n        };\n        /**\n         * Returns the anchor href that should be generated for the match.\n         *\n         * @return {String}\n         */\n        MentionMatch.prototype.getAnchorHref = function () {\n            switch (this.serviceName) {\n                case 'twitter':\n                    return 'https://twitter.com/' + this.mention;\n                case 'instagram':\n                    return 'https://instagram.com/' + this.mention;\n                case 'soundcloud':\n                    return 'https://soundcloud.com/' + this.mention;\n                default: // Shouldn't happen because Autolinker's constructor should block any invalid values, but just in case.\n                    throw new Error('Unknown service name to point mention to: ' + this.serviceName);\n            }\n        };\n        /**\n         * Returns the anchor text that should be generated for the match.\n         *\n         * @return {String}\n         */\n        MentionMatch.prototype.getAnchorText = function () {\n            return '@' + this.mention;\n        };\n        /**\n         * Returns the CSS class suffixes that should be used on a tag built with\n         * the match. See {@link Autolinker.match.Match#getCssClassSuffixes} for\n         * details.\n         *\n         * @return {String[]}\n         */\n        MentionMatch.prototype.getCssClassSuffixes = function () {\n            var cssClassSuffixes = _super.prototype.getCssClassSuffixes.call(this), serviceName = this.getServiceName();\n            if (serviceName) {\n                cssClassSuffixes.push(serviceName);\n            }\n            return cssClassSuffixes;\n        };\n        return MentionMatch;\n    }(Match));\n\n    var __extends$7 = (undefined && undefined.__extends) || (function () {\n        var extendStatics = function (d, b) {\n            extendStatics = Object.setPrototypeOf ||\n                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n            return extendStatics(d, b);\n        };\n        return function (d, b) {\n            extendStatics(d, b);\n            function __() { this.constructor = d; }\n            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n        };\n    })();\n    /**\n     * @class Autolinker.match.Phone\n     * @extends Autolinker.match.Match\n     *\n     * Represents a Phone number match found in an input string which should be\n     * Autolinked.\n     *\n     * See this class's superclass ({@link Autolinker.match.Match}) for more\n     * details.\n     */\n    var PhoneMatch = /** @class */ (function (_super) {\n        __extends$7(PhoneMatch, _super);\n        /**\n         * @constructor\n         * @param {Object} cfg The configuration properties for the Match\n         *   instance, specified in an Object (map).\n         */\n        function PhoneMatch(cfg) {\n            var _this = _super.call(this, cfg) || this;\n            _this.number = cfg.number;\n            _this.plusSign = cfg.plusSign;\n            return _this;\n        }\n        /**\n         * Returns a string name for the type of match that this class represents.\n         *\n         * @return {String}\n         */\n        PhoneMatch.prototype.getType = function () {\n            return 'phone';\n        };\n        /**\n         * Returns the phone number that was matched as a string, without any\n         * delimiter characters.\n         *\n         * Note: This is a string to allow for prefixed 0's.\n         *\n         * @return {String}\n         */\n        PhoneMatch.prototype.getNumber = function () {\n            return this.number;\n        };\n        /**\n         * Returns the anchor href that should be generated for the match.\n         *\n         * @return {String}\n         */\n        PhoneMatch.prototype.getAnchorHref = function () {\n            return 'tel:' + (this.plusSign ? '+' : '') + this.number;\n        };\n        /**\n         * Returns the anchor text that should be generated for the match.\n         *\n         * @return {String}\n         */\n        PhoneMatch.prototype.getAnchorText = function () {\n            return this.matchedText;\n        };\n        return PhoneMatch;\n    }(Match));\n\n    var __extends$8 = (undefined && undefined.__extends) || (function () {\n        var extendStatics = function (d, b) {\n            extendStatics = Object.setPrototypeOf ||\n                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n            return extendStatics(d, b);\n        };\n        return function (d, b) {\n            extendStatics(d, b);\n            function __() { this.constructor = d; }\n            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n        };\n    })();\n    /**\n     * @class Autolinker.match.Url\n     * @extends Autolinker.match.Match\n     *\n     * Represents a Url match found in an input string which should be Autolinked.\n     *\n     * See this class's superclass ({@link Autolinker.match.Match}) for more details.\n     */\n    var UrlMatch = /** @class */ (function (_super) {\n        __extends$8(UrlMatch, _super);\n        /**\n         * @constructor\n         * @param {Object} cfg The configuration properties for the Match\n         *   instance, specified in an Object (map).\n         */\n        function UrlMatch(cfg) {\n            var _this = _super.call(this, cfg) || this;\n            /**\n             * @private\n             * @property {RegExp} schemePrefixRegex\n             *\n             * A regular expression used to remove the 'http://' or 'https://' from\n             * URLs.\n             */\n            _this.schemePrefixRegex = /^(https?:\\/\\/)?/i;\n            /**\n             * @private\n             * @property {RegExp} wwwPrefixRegex\n             *\n             * A regular expression used to remove the 'www.' from URLs.\n             */\n            _this.wwwPrefixRegex = /^(https?:\\/\\/)?(www\\.)?/i;\n            /**\n             * @private\n             * @property {RegExp} protocolRelativeRegex\n             *\n             * The regular expression used to remove the protocol-relative '//' from the {@link #url} string, for purposes\n             * of {@link #getAnchorText}. A protocol-relative URL is, for example, \"//yahoo.com\"\n             */\n            _this.protocolRelativeRegex = /^\\/\\//;\n            /**\n             * @private\n             * @property {Boolean} protocolPrepended\n             *\n             * Will be set to `true` if the 'http://' protocol has been prepended to the {@link #url} (because the\n             * {@link #url} did not have a protocol)\n             */\n            _this.protocolPrepended = false;\n            _this.urlMatchType = cfg.urlMatchType;\n            _this.url = cfg.url;\n            _this.protocolUrlMatch = cfg.protocolUrlMatch;\n            _this.protocolRelativeMatch = cfg.protocolRelativeMatch;\n            _this.stripPrefix = cfg.stripPrefix;\n            _this.stripTrailingSlash = cfg.stripTrailingSlash;\n            _this.decodePercentEncoding = cfg.decodePercentEncoding;\n            return _this;\n        }\n        /**\n         * Returns a string name for the type of match that this class represents.\n         *\n         * @return {String}\n         */\n        UrlMatch.prototype.getType = function () {\n            return 'url';\n        };\n        /**\n         * Returns a string name for the type of URL match that this class\n         * represents.\n         *\n         * This helps to determine if the match was made in the original text with a\n         * prefixed scheme (ex: 'http://www.google.com'), a prefixed 'www' (ex:\n         * 'www.google.com'), or was matched by a known top-level domain (ex:\n         * 'google.com').\n         *\n         * @return {\"scheme\"/\"www\"/\"tld\"}\n         */\n        UrlMatch.prototype.getUrlMatchType = function () {\n            return this.urlMatchType;\n        };\n        /**\n         * Returns the url that was matched, assuming the protocol to be 'http://' if the original\n         * match was missing a protocol.\n         *\n         * @return {String}\n         */\n        UrlMatch.prototype.getUrl = function () {\n            var url = this.url;\n            // if the url string doesn't begin with a protocol, assume 'http://'\n            if (!this.protocolRelativeMatch && !this.protocolUrlMatch && !this.protocolPrepended) {\n                url = this.url = 'http://' + url;\n                this.protocolPrepended = true;\n            }\n            return url;\n        };\n        /**\n         * Returns the anchor href that should be generated for the match.\n         *\n         * @return {String}\n         */\n        UrlMatch.prototype.getAnchorHref = function () {\n            var url = this.getUrl();\n            return url.replace(/&amp;/g, '&'); // any &amp;'s in the URL should be converted back to '&' if they were displayed as &amp; in the source html\n        };\n        /**\n         * Returns the anchor text that should be generated for the match.\n         *\n         * @return {String}\n         */\n        UrlMatch.prototype.getAnchorText = function () {\n            var anchorText = this.getMatchedText();\n            if (this.protocolRelativeMatch) {\n                // Strip off any protocol-relative '//' from the anchor text\n                anchorText = this.stripProtocolRelativePrefix(anchorText);\n            }\n            if (this.stripPrefix.scheme) {\n                anchorText = this.stripSchemePrefix(anchorText);\n            }\n            if (this.stripPrefix.www) {\n                anchorText = this.stripWwwPrefix(anchorText);\n            }\n            if (this.stripTrailingSlash) {\n                anchorText = this.removeTrailingSlash(anchorText); // remove trailing slash, if there is one\n            }\n            if (this.decodePercentEncoding) {\n                anchorText = this.removePercentEncoding(anchorText);\n            }\n            return anchorText;\n        };\n        // ---------------------------------------\n        // Utility Functionality\n        /**\n         * Strips the scheme prefix (such as \"http://\" or \"https://\") from the given\n         * `url`.\n         *\n         * @private\n         * @param {String} url The text of the anchor that is being generated, for\n         *   which to strip off the url scheme.\n         * @return {String} The `url`, with the scheme stripped.\n         */\n        UrlMatch.prototype.stripSchemePrefix = function (url) {\n            return url.replace(this.schemePrefixRegex, '');\n        };\n        /**\n         * Strips the 'www' prefix from the given `url`.\n         *\n         * @private\n         * @param {String} url The text of the anchor that is being generated, for\n         *   which to strip off the 'www' if it exists.\n         * @return {String} The `url`, with the 'www' stripped.\n         */\n        UrlMatch.prototype.stripWwwPrefix = function (url) {\n            return url.replace(this.wwwPrefixRegex, '$1'); // leave any scheme ($1), it one exists\n        };\n        /**\n         * Strips any protocol-relative '//' from the anchor text.\n         *\n         * @private\n         * @param {String} text The text of the anchor that is being generated, for which to strip off the\n         *   protocol-relative prefix (such as stripping off \"//\")\n         * @return {String} The `anchorText`, with the protocol-relative prefix stripped.\n         */\n        UrlMatch.prototype.stripProtocolRelativePrefix = function (text) {\n            return text.replace(this.protocolRelativeRegex, '');\n        };\n        /**\n         * Removes any trailing slash from the given `anchorText`, in preparation for the text to be displayed.\n         *\n         * @private\n         * @param {String} anchorText The text of the anchor that is being generated, for which to remove any trailing\n         *   slash ('/') that may exist.\n         * @return {String} The `anchorText`, with the trailing slash removed.\n         */\n        UrlMatch.prototype.removeTrailingSlash = function (anchorText) {\n            if (anchorText.charAt(anchorText.length - 1) === '/') {\n                anchorText = anchorText.slice(0, -1);\n            }\n            return anchorText;\n        };\n        /**\n         * Decodes percent-encoded characters from the given `anchorText`, in preparation for the text to be displayed.\n         *\n         * @private\n         * @param {String} anchorText The text of the anchor that is being generated, for which to decode any percent-encoded characters.\n         * @return {String} The `anchorText`, with the percent-encoded characters decoded.\n         */\n        UrlMatch.prototype.removePercentEncoding = function (anchorText) {\n            try {\n                return decodeURIComponent(anchorText\n                    .replace(/%22/gi, '&quot;')\n                    .replace(/%26/gi, '&amp;')\n                    .replace(/%27/gi, '&#39;')\n                    .replace(/%3C/gi, '&lt;')\n                    .replace(/%3E/gi, '&gt;'));\n            }\n            catch (e) {\n                // Invalid escape sequence.\n                return anchorText;\n            }\n        };\n        return UrlMatch;\n    }(Match));\n\n    /**\n     * @abstract\n     * @class Autolinker.matcher.Matcher\n     *\n     * An abstract class and interface for individual matchers to find matches in\n     * an input string with linkified versions of them.\n     *\n     * Note that Matchers do not take HTML into account - they must be fed the text\n     * nodes of any HTML string, which is handled by {@link Autolinker#parse}.\n     */\n    var Matcher = /** @class */ (function () {\n        /**\n         * @constructor\n         * @param {Object} cfg The configuration properties for the Matcher\n         *   instance, specified in an Object (map).\n         */\n        function Matcher(cfg) {\n            this.tagBuilder = cfg.tagBuilder;\n        }\n        return Matcher;\n    }());\n\n    /*\n     * This file builds and stores a library of the common regular expressions used\n     * by the Autolinker utility.\n     *\n     * Other regular expressions may exist ad-hoc, but these are generally the\n     * regular expressions that are shared between source files.\n     */\n    /**\n     * The string form of a regular expression that would match all of the\n     * alphabetic (\"letter\") chars in the unicode character set when placed in a\n     * RegExp character class (`[]`). This includes all international alphabetic\n     * characters.\n     *\n     * These would be the characters matched by unicode regex engines `\\p{L}`\n     * escape (\"all letters\").\n     *\n     * Taken from the XRegExp library: http://xregexp.com/\n     * Specifically: http://xregexp.com/v/3.0.0/unicode-categories.js\n     */\n    var alphaCharsStr = 'A-Za-z\\\\xAA\\\\xB5\\\\xBA\\\\xC0-\\\\xD6\\\\xD8-\\\\xF6\\\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B4\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16F1-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2183\\u2184\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005\\u3006\\u3031-\\u3035\\u303B\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6E5\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AD\\uA7B0-\\uA7B7\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC';\n    /**\n     * The string form of a regular expression that would match all of the\n     * decimal number chars in the unicode character set when placed in a RegExp\n     * character class (`[]`).\n     *\n     * These would be the characters matched by unicode regex engines `\\p{Nd}`\n     * escape (\"all decimal numbers\")\n     *\n     * Taken from the XRegExp library: http://xregexp.com/\n     * Specifically: http://xregexp.com/v/3.0.0/unicode-categories.js\n     *\n     * @private\n     * @type {String}\n     */\n    var decimalNumbersStr = '0-9\\u0660-\\u0669\\u06F0-\\u06F9\\u07C0-\\u07C9\\u0966-\\u096F\\u09E6-\\u09EF\\u0A66-\\u0A6F\\u0AE6-\\u0AEF\\u0B66-\\u0B6F\\u0BE6-\\u0BEF\\u0C66-\\u0C6F\\u0CE6-\\u0CEF\\u0D66-\\u0D6F\\u0DE6-\\u0DEF\\u0E50-\\u0E59\\u0ED0-\\u0ED9\\u0F20-\\u0F29\\u1040-\\u1049\\u1090-\\u1099\\u17E0-\\u17E9\\u1810-\\u1819\\u1946-\\u194F\\u19D0-\\u19D9\\u1A80-\\u1A89\\u1A90-\\u1A99\\u1B50-\\u1B59\\u1BB0-\\u1BB9\\u1C40-\\u1C49\\u1C50-\\u1C59\\uA620-\\uA629\\uA8D0-\\uA8D9\\uA900-\\uA909\\uA9D0-\\uA9D9\\uA9F0-\\uA9F9\\uAA50-\\uAA59\\uABF0-\\uABF9\\uFF10-\\uFF19';\n    /**\n     * The string form of a regular expression that would match all of the\n     * letters and decimal number chars in the unicode character set when placed\n     * in a RegExp character class (`[]`).\n     *\n     * These would be the characters matched by unicode regex engines `[\\p{L}\\p{Nd}]`\n     * escape (\"all letters and decimal numbers\")\n     */\n    var alphaNumericCharsStr = alphaCharsStr + decimalNumbersStr;\n    // Simplified IP regular expression\n    var ipStr = '(?:[' + decimalNumbersStr + ']{1,3}\\\\.){3}[' + decimalNumbersStr + ']{1,3}';\n    // Protected domain label which do not allow \"-\" character on the beginning and the end of a single label\n    var domainLabelStr = '[' + alphaNumericCharsStr + '](?:[' + alphaNumericCharsStr + '\\\\-]{0,61}[' + alphaNumericCharsStr + '])?';\n    var getDomainLabelStr = function (group) {\n        return '(?=(' + domainLabelStr + '))\\\\' + group;\n    };\n    /**\n     * A function to match domain names of a URL or email address.\n     * Ex: 'google', 'yahoo', 'some-other-company', etc.\n     */\n    var getDomainNameStr = function (group) {\n        return '(?:' + getDomainLabelStr(group) + '(?:\\\\.' + getDomainLabelStr(group + 1) + '){0,126}|' + ipStr + ')';\n    };\n\n    // NOTE: THIS IS A GENERATED FILE\n    // To update with the latest TLD list, run `gulp update-tld-list`\n    var tldRegex = /(?:xn--vermgensberatung-pwb|xn--vermgensberater-ctb|xn--clchc0ea0b2g2a9gcd|xn--w4r85el8fhu5dnra|northwesternmutual|travelersinsurance|vermgensberatung|xn--3oq18vl8pn36a|xn--5su34j936bgsg|xn--bck1b9a5dre4c|xn--mgbai9azgqp6j|xn--mgberp4a5d4ar|xn--xkc2dl3a5ee0h|vermgensberater|xn--fzys8d69uvgm|xn--mgba7c0bbn0a|xn--xkc2al3hye2a|americanexpress|kerryproperties|sandvikcoromant|xn--i1b6b1a6a2e|xn--kcrx77d1x4a|xn--lgbbat1ad8j|xn--mgba3a4f16a|xn--mgbc0a9azcg|xn--nqv7fs00ema|afamilycompany|americanfamily|bananarepublic|cancerresearch|cookingchannel|kerrylogistics|weatherchannel|xn--54b7fta0cc|xn--6qq986b3xl|xn--80aqecdr1a|xn--b4w605ferd|xn--fiq228c5hs|xn--jlq61u9w7b|xn--mgba3a3ejt|xn--mgbaam7a8h|xn--mgbayh7gpa|xn--mgbb9fbpob|xn--mgbbh1a71e|xn--mgbca7dzdo|xn--mgbi4ecexp|xn--mgbx4cd0ab|international|lifeinsurance|orientexpress|spreadbetting|travelchannel|wolterskluwer|xn--eckvdtc9d|xn--fpcrj9c3d|xn--fzc2c9e2c|xn--tiq49xqyj|xn--yfro4i67o|xn--ygbi2ammx|construction|lplfinancial|pamperedchef|scholarships|versicherung|xn--3e0b707e|xn--80adxhks|xn--80asehdb|xn--8y0a063a|xn--gckr3f0f|xn--mgb9awbf|xn--mgbab2bd|xn--mgbpl2fh|xn--mgbt3dhd|xn--mk1bu44c|xn--ngbc5azd|xn--ngbe9e0a|xn--ogbpf8fl|xn--qcka1pmc|accountants|barclaycard|blackfriday|blockbuster|bridgestone|calvinklein|contractors|creditunion|engineering|enterprises|foodnetwork|investments|kerryhotels|lamborghini|motorcycles|olayangroup|photography|playstation|productions|progressive|redumbrella|rightathome|williamhill|xn--11b4c3d|xn--1ck2e1b|xn--1qqw23a|xn--3bst00m|xn--3ds443g|xn--42c2d9a|xn--45brj9c|xn--55qw42g|xn--6frz82g|xn--80ao21a|xn--9krt00a|xn--cck2b3b|xn--czr694b|xn--d1acj3b|xn--efvy88h|xn--estv75g|xn--fct429k|xn--fjq720a|xn--flw351e|xn--g2xx48c|xn--gecrj9c|xn--gk3at1e|xn--h2brj9c|xn--hxt814e|xn--imr513n|xn--j6w193g|xn--jvr189m|xn--kprw13d|xn--kpry57d|xn--kpu716f|xn--mgbtx2b|xn--mix891f|xn--nyqy26a|xn--pbt977c|xn--pgbs0dh|xn--q9jyb4c|xn--rhqv96g|xn--rovu88b|xn--s9brj9c|xn--ses554g|xn--t60b56a|xn--vuq861b|xn--w4rs40l|xn--xhq521b|xn--zfr164b||accountant|apartments|associates|basketball|bnpparibas|boehringer|capitalone|consulting|creditcard|cuisinella|eurovision|extraspace|foundation|healthcare|immobilien|industries|management|mitsubishi|nationwide|newholland|nextdirect|onyourside|properties|protection|prudential|realestate|republican|restaurant|schaeffler|swiftcover|tatamotors|technology|telefonica|university|vistaprint|vlaanderen|volkswagen|xn--30rr7y|xn--3pxu8k|xn--45q11c|xn--4gbrim|xn--55qx5d|xn--5tzm5g|xn--80aswg|xn--90a3ac|xn--9dbq2a|xn--9et52u|xn--c2br7g|xn--cg4bki|xn--czrs0t|xn--czru2d|xn--fiq64b|xn--fiqs8s|xn--fiqz9s|xn--io0a7i|xn--kput3i|xn--mxtq1m|xn--o3cw4h|xn--pssy2u|xn--unup4y|xn--wgbh1c|xn--wgbl6a|xn--y9a3aq|accenture|alfaromeo|allfinanz|amsterdam|analytics|aquarelle|barcelona|bloomberg|christmas|community|directory|education|equipment|fairwinds|financial|firestone|fresenius|frontdoor|fujixerox|furniture|goldpoint|goodhands|hisamitsu|homedepot|homegoods|homesense|honeywell|institute|insurance|kuokgroup|ladbrokes|lancaster|landrover|lifestyle|marketing|marshalls|mcdonalds|melbourne|microsoft|montblanc|panasonic|passagens|pramerica|richardli|scjohnson|shangrila|solutions|statebank|statefarm|stockholm|travelers|vacations|xn--90ais|xn--c1avg|xn--d1alf|xn--e1a4c|xn--fhbei|xn--j1aef|xn--j1amh|xn--l1acc|xn--nqv7f|xn--p1acf|xn--tckwe|xn--vhquv|yodobashi|abudhabi|airforce|allstate|attorney|barclays|barefoot|bargains|baseball|boutique|bradesco|broadway|brussels|budapest|builders|business|capetown|catering|catholic|chrysler|cipriani|cityeats|cleaning|clinique|clothing|commbank|computer|delivery|deloitte|democrat|diamonds|discount|discover|download|engineer|ericsson|esurance|everbank|exchange|feedback|fidelity|firmdale|football|frontier|goodyear|grainger|graphics|guardian|hdfcbank|helsinki|holdings|hospital|infiniti|ipiranga|istanbul|jpmorgan|lighting|lundbeck|marriott|maserati|mckinsey|memorial|mortgage|movistar|observer|partners|pharmacy|pictures|plumbing|property|redstone|reliance|saarland|samsclub|security|services|shopping|showtime|softbank|software|stcgroup|supplies|symantec|telecity|training|uconnect|vanguard|ventures|verisign|woodside|xn--90ae|xn--node|xn--p1ai|xn--qxam|yokohama||abogado|academy|agakhan|alibaba|android|athleta|auction|audible|auspost|avianca|banamex|bauhaus|bentley|bestbuy|booking|brother|bugatti|capital|caravan|careers|cartier|channel|chintai|citadel|clubmed|college|cologne|comcast|company|compare|contact|cooking|corsica|country|coupons|courses|cricket|cruises|dentist|digital|domains|exposed|express|farmers|fashion|ferrari|ferrero|finance|fishing|fitness|flights|florist|flowers|forsale|frogans|fujitsu|gallery|genting|godaddy|guitars|hamburg|hangout|hitachi|holiday|hosting|hoteles|hotmail|hyundai|iselect|ismaili|jewelry|juniper|kitchen|komatsu|lacaixa|lancome|lanxess|lasalle|latrobe|leclerc|liaison|limited|lincoln|markets|metlife|monster|netbank|netflix|network|neustar|okinawa|oldnavy|organic|origins|panerai|philips|pioneer|politie|realtor|recipes|rentals|reviews|rexroth|samsung|sandvik|schmidt|schwarz|science|shiksha|shriram|singles|spiegel|staples|starhub|statoil|storage|support|surgery|systems|temasek|theater|theatre|tickets|tiffany|toshiba|trading|walmart|wanggou|watches|weather|website|wedding|whoswho|windows|winners|xfinity|yamaxun|youtube|zuerich||||||||abarth|abbott|abbvie|active|africa|agency|airbus|airtel|alipay|alsace|alstom|anquan|aramco|author|bayern|beauty|berlin|bharti|blanco|bostik|boston|broker|camera|career|caseih|casino|center|chanel|chrome|church|circle|claims|clinic|coffee|comsec|condos|coupon|credit|cruise|dating|datsun|dealer|degree|dental|design|direct|doctor|dunlop|dupont|durban|emerck|energy|estate|events|expert|family|flickr|futbol|gallup|garden|george|giving|global|google|gratis|health|hermes|hiphop|hockey|hughes|imamat|insure|intuit|jaguar|joburg|juegos|kaufen|kinder|kindle|kosher|lancia|latino|lawyer|lefrak|living|locker|london|luxury|madrid|maison|makeup|market|mattel|mobile|mobily|monash|mormon|moscow|museum|mutual|nagoya|natura|nissan|nissay|norton|nowruz|office|olayan|online|oracle|orange|otsuka|pfizer|photos|physio|piaget|pictet|quebec|racing|realty|reisen|repair|report|review|rocher|rogers|ryukyu|safety|sakura|sanofi|school|schule|secure|select|shouji|soccer|social|stream|studio|supply|suzuki|swatch|sydney|taipei|taobao|target|tattoo|tennis|tienda|tjmaxx|tkmaxx|toyota|travel|unicom|viajes|viking|villas|virgin|vision|voting|voyage|vuelos|walter|warman|webcam|xihuan|xperia|yachts|yandex|zappos||||||||||||actor|adult|aetna|amfam|amica|apple|archi|audio|autos|azure|baidu|beats|bible|bingo|black|boats|boots|bosch|build|canon|cards|chase|cheap|chloe|cisco|citic|click|cloud|coach|codes|crown|cymru|dabur|dance|deals|delta|dodge|drive|dubai|earth|edeka|email|epost|epson|faith|fedex|final|forex|forum|gallo|games|gifts|gives|glade|glass|globo|gmail|green|gripe|group|gucci|guide|homes|honda|horse|house|hyatt|ikano|intel|irish|iveco|jetzt|koeln|kyoto|lamer|lease|legal|lexus|lilly|linde|lipsy|lixil|loans|locus|lotte|lotto|lupin|macys|mango|media|miami|money|mopar|movie|nadex|nexus|nikon|ninja|nokia|nowtv|omega|osaka|paris|parts|party|phone|photo|pizza|place|poker|praxi|press|prime|promo|quest|radio|rehab|reise|ricoh|rocks|rodeo|salon|sener|seven|sharp|shell|shoes|skype|sling|smart|smile|solar|space|stada|store|study|style|sucks|swiss|tatar|tires|tirol|tmall|today|tokyo|tools|toray|total|tours|trade|trust|tunes|tushu|ubank|vegas|video|vista|vodka|volvo|wales|watch|weber|weibo|works|world|xerox|yahoo|zippo|||||||||||aarp|able|adac|aero|aigo|akdn|ally|amex|army|arpa|arte|asda|asia|audi|auto|baby|band|bank|bbva|beer|best|bike|bing|blog|blue|bofa|bond|book|buzz|cafe|call|camp|care|cars|casa|case|cash|cbre|cern|chat|citi|city|club|cool|coop|cyou|data|date|dclk|deal|dell|desi|diet|dish|docs|doha|duck|duns|dvag|erni|fage|fail|fans|farm|fast|fiat|fido|film|fire|fish|flir|food|ford|free|fund|game|gbiz|gent|ggee|gift|gmbh|gold|golf|goog|guge|guru|hair|haus|hdfc|help|here|hgtv|host|hsbc|icbc|ieee|imdb|immo|info|itau|java|jeep|jobs|jprs|kddi|kiwi|kpmg|kred|land|lego|lgbt|lidl|life|like|limo|link|live|loan|loft|love|ltda|luxe|maif|meet|meme|menu|mini|mint|mobi|moda|moto|mtpc|name|navy|news|next|nico|nike|ollo|open|page|pars|pccw|pics|ping|pink|play|plus|pohl|porn|post|prod|prof|qpon|raid|read|reit|rent|rest|rich|rmit|room|rsvp|ruhr|safe|sale|sapo|sarl|save|saxo|scor|scot|seat|seek|sexy|shaw|shia|shop|show|silk|sina|site|skin|sncf|sohu|song|sony|spot|star|surf|talk|taxi|team|tech|teva|tiaa|tips|town|toys|tube|vana|visa|viva|vivo|vote|voto|wang|weir|wien|wiki|wine|work|xbox|yoga|zara|zero|zone|||||||||||||||||||||aaa|abb|abc|aco|ads|aeg|afl|aig|anz|aol|app|art|aws|axa|bar|bbc|bbt|bcg|bcn|bet|bid|bio|biz|bms|bmw|bnl|bom|boo|bot|box|buy|bzh|cab|cal|cam|car|cat|cba|cbn|cbs|ceb|ceo|cfa|cfd|com|crs|csc|dad|day|dds|dev|dhl|diy|dnp|dog|dot|dtv|dvr|eat|eco|edu|esq|eus|fan|fit|fly|foo|fox|frl|ftr|fun|fyi|gal|gap|gdn|gea|gle|gmo|gmx|goo|gop|got|gov|hbo|hiv|hkt|hot|how|htc|ibm|ice|icu|ifm|ing|ink|int|ist|itv|iwc|jcb|jcp|jio|jlc|jll|jmp|jnj|jot|joy|kfh|kia|kim|kpn|krd|lat|law|lds|lol|lpl|ltd|man|mba|mcd|med|men|meo|mil|mit|mlb|mls|mma|moe|moi|mom|mov|msd|mtn|mtr|nab|nba|nec|net|new|nfl|ngo|nhk|now|nra|nrw|ntt|nyc|obi|off|one|ong|onl|ooo|org|ott|ovh|pay|pet|pid|pin|pnc|pro|pru|pub|pwc|qvc|red|ren|ril|rio|rip|run|rwe|sap|sas|sbi|sbs|sca|scb|ses|sew|sex|sfr|ski|sky|soy|srl|srt|stc|tab|tax|tci|tdk|tel|thd|tjx|top|trv|tui|tvs|ubs|uno|uol|ups|vet|vig|vin|vip|wed|win|wme|wow|wtc|wtf|xin|xxx|xyz|you|yun|zip|||||||||||||||||||||||||||||ac|ad|ae|af|ag|ai|al|am|ao|aq|ar|as|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cw|cx|cy|cz|de|dj|dk|dm|do|dz|ec|ee|eg|er|es|et|eu|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|py|qa|re|ro|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sk|sl|sm|sn|so|sr|st|su|sv|sx|sy|sz|tc|td|tf|tg|th|tj|tk|tl|tm|tn|to|tr|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|za|zm|zw||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||)/;\n\n    var __extends$9 = (undefined && undefined.__extends) || (function () {\n        var extendStatics = function (d, b) {\n            extendStatics = Object.setPrototypeOf ||\n                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n            return extendStatics(d, b);\n        };\n        return function (d, b) {\n            extendStatics(d, b);\n            function __() { this.constructor = d; }\n            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n        };\n    })();\n    /**\n     * @class Autolinker.matcher.Email\n     * @extends Autolinker.matcher.Matcher\n     *\n     * Matcher to find email matches in an input string.\n     *\n     * See this class's superclass ({@link Autolinker.matcher.Matcher}) for more details.\n     */\n    var EmailMatcher = /** @class */ (function (_super) {\n        __extends$9(EmailMatcher, _super);\n        function EmailMatcher() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            /**\n             * The regular expression to match email addresses. Example match:\n             *\n             *     person@place.com\n             *\n             * @private\n             * @property {RegExp} matcherRegex\n             */\n            _this.matcherRegex = (function () {\n                var alphaNumericChars = alphaNumericCharsStr, specialCharacters = '!#$%&\\'*+\\\\-\\\\/=?^_`{|}~', restrictedSpecialCharacters = '\\\\s\"(),:;<>@\\\\[\\\\]', validCharacters = alphaNumericChars + specialCharacters, validRestrictedCharacters = validCharacters + restrictedSpecialCharacters, emailRegex = new RegExp('(?:[' + validCharacters + '](?:[' + validCharacters + ']|\\\\.(?!\\\\.|@))*|\\\\\"[' + validRestrictedCharacters + '.]+\\\\\")@');\n                return new RegExp([\n                    emailRegex.source,\n                    getDomainNameStr(1),\n                    '\\\\.', tldRegex.source // '.com', '.net', etc\n                ].join(\"\"), 'gi');\n            })();\n            return _this;\n        }\n        /**\n         * @inheritdoc\n         */\n        EmailMatcher.prototype.parseMatches = function (text) {\n            var matcherRegex = this.matcherRegex, tagBuilder = this.tagBuilder, matches = [], match;\n            while ((match = matcherRegex.exec(text)) !== null) {\n                var matchedText = match[0];\n                matches.push(new EmailMatch({\n                    tagBuilder: tagBuilder,\n                    matchedText: matchedText,\n                    offset: match.index,\n                    email: matchedText\n                }));\n            }\n            return matches;\n        };\n        return EmailMatcher;\n    }(Matcher));\n\n    /**\n     * @private\n     * @class Autolinker.matcher.UrlMatchValidator\n     * @singleton\n     *\n     * Used by Autolinker to filter out false URL positives from the\n     * {@link Autolinker.matcher.Url UrlMatcher}.\n     *\n     * Due to the limitations of regular expressions (including the missing feature\n     * of look-behinds in JS regular expressions), we cannot always determine the\n     * validity of a given match. This class applies a bit of additional logic to\n     * filter out any false positives that have been matched by the\n     * {@link Autolinker.matcher.Url UrlMatcher}.\n     */\n    var UrlMatchValidator = /** @class */ (function () {\n        function UrlMatchValidator() {\n        }\n        /**\n         * Determines if a given URL match found by the {@link Autolinker.matcher.Url UrlMatcher}\n         * is valid. Will return `false` for:\n         *\n         * 1) URL matches which do not have at least have one period ('.') in the\n         *    domain name (effectively skipping over matches like \"abc:def\").\n         *    However, URL matches with a protocol will be allowed (ex: 'http://localhost')\n         * 2) URL matches which do not have at least one word character in the\n         *    domain name (effectively skipping over matches like \"git:1.0\").\n         * 3) A protocol-relative url match (a URL beginning with '//') whose\n         *    previous character is a word character (effectively skipping over\n         *    strings like \"abc//google.com\")\n         *\n         * Otherwise, returns `true`.\n         *\n         * @param {String} urlMatch The matched URL, if there was one. Will be an\n         *   empty string if the match is not a URL match.\n         * @param {String} protocolUrlMatch The match URL string for a protocol\n         *   match. Ex: 'http://yahoo.com'. This is used to match something like\n         *   'http://localhost', where we won't double check that the domain name\n         *   has at least one '.' in it.\n         * @return {Boolean} `true` if the match given is valid and should be\n         *   processed, or `false` if the match is invalid and/or should just not be\n         *   processed.\n         */\n        UrlMatchValidator.isValid = function (urlMatch, protocolUrlMatch) {\n            if ((protocolUrlMatch && !this.isValidUriScheme(protocolUrlMatch)) ||\n                this.urlMatchDoesNotHaveProtocolOrDot(urlMatch, protocolUrlMatch) || // At least one period ('.') must exist in the URL match for us to consider it an actual URL, *unless* it was a full protocol match (like 'http://localhost')\n                (this.urlMatchDoesNotHaveAtLeastOneWordChar(urlMatch, protocolUrlMatch) && // At least one letter character must exist in the domain name after a protocol match. Ex: skip over something like \"git:1.0\"\n                    !this.isValidIpAddress(urlMatch)) || // Except if it's an IP address\n                this.containsMultipleDots(urlMatch)) {\n                return false;\n            }\n            return true;\n        };\n        UrlMatchValidator.isValidIpAddress = function (uriSchemeMatch) {\n            var newRegex = new RegExp(this.hasFullProtocolRegex.source + this.ipRegex.source);\n            var uriScheme = uriSchemeMatch.match(newRegex);\n            return uriScheme !== null;\n        };\n        UrlMatchValidator.containsMultipleDots = function (urlMatch) {\n            var stringBeforeSlash = urlMatch;\n            if (this.hasFullProtocolRegex.test(urlMatch)) {\n                stringBeforeSlash = urlMatch.split('://')[1];\n            }\n            return stringBeforeSlash.split('/')[0].indexOf(\"..\") > -1;\n        };\n        /**\n         * Determines if the URI scheme is a valid scheme to be autolinked. Returns\n         * `false` if the scheme is 'javascript:' or 'vbscript:'\n         *\n         * @private\n         * @param {String} uriSchemeMatch The match URL string for a full URI scheme\n         *   match. Ex: 'http://yahoo.com' or 'mailto:a@a.com'.\n         * @return {Boolean} `true` if the scheme is a valid one, `false` otherwise.\n         */\n        UrlMatchValidator.isValidUriScheme = function (uriSchemeMatch) {\n            var uriSchemeMatchArr = uriSchemeMatch.match(this.uriSchemeRegex), uriScheme = uriSchemeMatchArr && uriSchemeMatchArr[0].toLowerCase();\n            return (uriScheme !== 'javascript:' && uriScheme !== 'vbscript:');\n        };\n        /**\n         * Determines if a URL match does not have either:\n         *\n         * a) a full protocol (i.e. 'http://'), or\n         * b) at least one dot ('.') in the domain name (for a non-full-protocol\n         *    match).\n         *\n         * Either situation is considered an invalid URL (ex: 'git:d' does not have\n         * either the '://' part, or at least one dot in the domain name. If the\n         * match was 'git:abc.com', we would consider this valid.)\n         *\n         * @private\n         * @param {String} urlMatch The matched URL, if there was one. Will be an\n         *   empty string if the match is not a URL match.\n         * @param {String} protocolUrlMatch The match URL string for a protocol\n         *   match. Ex: 'http://yahoo.com'. This is used to match something like\n         *   'http://localhost', where we won't double check that the domain name\n         *   has at least one '.' in it.\n         * @return {Boolean} `true` if the URL match does not have a full protocol,\n         *   or at least one dot ('.') in a non-full-protocol match.\n         */\n        UrlMatchValidator.urlMatchDoesNotHaveProtocolOrDot = function (urlMatch, protocolUrlMatch) {\n            return (!!urlMatch && (!protocolUrlMatch || !this.hasFullProtocolRegex.test(protocolUrlMatch)) && urlMatch.indexOf('.') === -1);\n        };\n        /**\n         * Determines if a URL match does not have at least one word character after\n         * the protocol (i.e. in the domain name).\n         *\n         * At least one letter character must exist in the domain name after a\n         * protocol match. Ex: skip over something like \"git:1.0\"\n         *\n         * @private\n         * @param {String} urlMatch The matched URL, if there was one. Will be an\n         *   empty string if the match is not a URL match.\n         * @param {String} protocolUrlMatch The match URL string for a protocol\n         *   match. Ex: 'http://yahoo.com'. This is used to know whether or not we\n         *   have a protocol in the URL string, in order to check for a word\n         *   character after the protocol separator (':').\n         * @return {Boolean} `true` if the URL match does not have at least one word\n         *   character in it after the protocol, `false` otherwise.\n         */\n        UrlMatchValidator.urlMatchDoesNotHaveAtLeastOneWordChar = function (urlMatch, protocolUrlMatch) {\n            if (urlMatch && protocolUrlMatch) {\n                return !this.hasWordCharAfterProtocolRegex.test(urlMatch);\n            }\n            else {\n                return false;\n            }\n        };\n        /**\n         * Regex to test for a full protocol, with the two trailing slashes. Ex: 'http://'\n         *\n         * @private\n         * @property {RegExp} hasFullProtocolRegex\n         */\n        UrlMatchValidator.hasFullProtocolRegex = /^[A-Za-z][-.+A-Za-z0-9]*:\\/\\//;\n        /**\n         * Regex to find the URI scheme, such as 'mailto:'.\n         *\n         * This is used to filter out 'javascript:' and 'vbscript:' schemes.\n         *\n         * @private\n         * @property {RegExp} uriSchemeRegex\n         */\n        UrlMatchValidator.uriSchemeRegex = /^[A-Za-z][-.+A-Za-z0-9]*:/;\n        /**\n         * Regex to determine if at least one word char exists after the protocol (i.e. after the ':')\n         *\n         * @private\n         * @property {RegExp} hasWordCharAfterProtocolRegex\n         */\n        UrlMatchValidator.hasWordCharAfterProtocolRegex = new RegExp(\":[^\\\\s]*?[\" + alphaCharsStr + \"]\");\n        /**\n         * Regex to determine if the string is a valid IP address\n         *\n         * @private\n         * @property {RegExp} ipRegex\n         */\n        UrlMatchValidator.ipRegex = /[0-9][0-9]?[0-9]?\\.[0-9][0-9]?[0-9]?\\.[0-9][0-9]?[0-9]?\\.[0-9][0-9]?[0-9]?(:[0-9]*)?\\/?$/;\n        return UrlMatchValidator;\n    }());\n\n    var __extends$a = (undefined && undefined.__extends) || (function () {\n        var extendStatics = function (d, b) {\n            extendStatics = Object.setPrototypeOf ||\n                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n            return extendStatics(d, b);\n        };\n        return function (d, b) {\n            extendStatics(d, b);\n            function __() { this.constructor = d; }\n            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n        };\n    })();\n    /**\n     * @class Autolinker.matcher.Url\n     * @extends Autolinker.matcher.Matcher\n     *\n     * Matcher to find URL matches in an input string.\n     *\n     * See this class's superclass ({@link Autolinker.matcher.Matcher}) for more details.\n     */\n    var UrlMatcher = /** @class */ (function (_super) {\n        __extends$a(UrlMatcher, _super);\n        /**\n         * @constructor\n         * @param {Object} cfg The configuration properties for the Match instance,\n         *   specified in an Object (map).\n         */\n        function UrlMatcher(cfg) {\n            var _this = _super.call(this, cfg) || this;\n            /**\n             * @private\n             * @property {RegExp} matcherRegex\n             *\n             * The regular expression to match URLs with an optional scheme, port\n             * number, path, query string, and hash anchor.\n             *\n             * Example matches:\n             *\n             *     http://google.com\n             *     www.google.com\n             *     google.com/path/to/file?q1=1&q2=2#myAnchor\n             *\n             *\n             * This regular expression will have the following capturing groups:\n             *\n             * 1.  Group that matches a scheme-prefixed URL (i.e. 'http://google.com').\n             *     This is used to match scheme URLs with just a single word, such as\n             *     'http://localhost', where we won't double check that the domain name\n             *     has at least one dot ('.') in it.\n             * 2.  Group that matches a 'www.' prefixed URL. This is only matched if the\n             *     'www.' text was not prefixed by a scheme (i.e.: not prefixed by\n             *     'http://', 'ftp:', etc.)\n             * 3.  A protocol-relative ('//') match for the case of a 'www.' prefixed\n             *     URL. Will be an empty string if it is not a protocol-relative match.\n             *     We need to know the character before the '//' in order to determine\n             *     if it is a valid match or the // was in a string we don't want to\n             *     auto-link.\n             * 4.  Group that matches a known TLD (top level domain), when a scheme\n             *     or 'www.'-prefixed domain is not matched.\n             * 5.  A protocol-relative ('//') match for the case of a known TLD prefixed\n             *     URL. Will be an empty string if it is not a protocol-relative match.\n             *     See #3 for more info.\n             */\n            _this.matcherRegex = (function () {\n                var schemeRegex = /(?:[A-Za-z][-.+A-Za-z0-9]{0,63}:(?![A-Za-z][-.+A-Za-z0-9]{0,63}:\\/\\/)(?!\\d+\\/?)(?:\\/\\/)?)/, // match protocol, allow in format \"http://\" or \"mailto:\". However, do not match the first part of something like 'link:http://www.google.com' (i.e. don't match \"link:\"). Also, make sure we don't interpret 'google.com:8000' as if 'google.com' was a protocol here (i.e. ignore a trailing port number in this regex)\n                wwwRegex = /(?:www\\.)/, // starting with 'www.'\n                // Allow optional path, query string, and hash anchor, not ending in the following characters: \"?!:,.;\"\n                // http://blog.codinghorror.com/the-problem-with-urls/\n                urlSuffixRegex = new RegExp('[/?#](?:[' + alphaNumericCharsStr + '\\\\-+&@#/%=~_()|\\'$*\\\\[\\\\]?!:,.;\\u2713]*[' + alphaNumericCharsStr + '\\\\-+&@#/%=~_()|\\'$*\\\\[\\\\]\\u2713])?');\n                return new RegExp([\n                    '(?:',\n                    '(',\n                    schemeRegex.source,\n                    getDomainNameStr(2),\n                    ')',\n                    '|',\n                    '(',\n                    '(//)?',\n                    wwwRegex.source,\n                    getDomainNameStr(6),\n                    ')',\n                    '|',\n                    '(',\n                    '(//)?',\n                    getDomainNameStr(10) + '\\\\.',\n                    tldRegex.source,\n                    '(?![-' + alphaNumericCharsStr + '])',\n                    ')',\n                    ')',\n                    '(?::[0-9]+)?',\n                    '(?:' + urlSuffixRegex.source + ')?' // match for path, query string, and/or hash anchor - optional\n                ].join(\"\"), 'gi');\n            })();\n            /**\n             * A regular expression to use to check the character before a protocol-relative\n             * URL match. We don't want to match a protocol-relative URL if it is part\n             * of another word.\n             *\n             * For example, we want to match something like \"Go to: //google.com\",\n             * but we don't want to match something like \"abc//google.com\"\n             *\n             * This regular expression is used to test the character before the '//'.\n             *\n             * @private\n             * @type {RegExp} wordCharRegExp\n             */\n            _this.wordCharRegExp = new RegExp('[' + alphaNumericCharsStr + ']');\n            /**\n             * The regular expression to match opening parenthesis in a URL match.\n             *\n             * This is to determine if we have unbalanced parenthesis in the URL, and to\n             * drop the final parenthesis that was matched if so.\n             *\n             * Ex: The text \"(check out: wikipedia.com/something_(disambiguation))\"\n             * should only autolink the inner \"wikipedia.com/something_(disambiguation)\"\n             * part, so if we find that we have unbalanced parenthesis, we will drop the\n             * last one for the match.\n             *\n             * @private\n             * @property {RegExp}\n             */\n            _this.openParensRe = /\\(/g;\n            /**\n             * The regular expression to match closing parenthesis in a URL match. See\n             * {@link #openParensRe} for more information.\n             *\n             * @private\n             * @property {RegExp}\n             */\n            _this.closeParensRe = /\\)/g;\n            _this.stripPrefix = cfg.stripPrefix;\n            _this.stripTrailingSlash = cfg.stripTrailingSlash;\n            _this.decodePercentEncoding = cfg.decodePercentEncoding;\n            return _this;\n        }\n        /**\n         * @inheritdoc\n         */\n        UrlMatcher.prototype.parseMatches = function (text) {\n            var matcherRegex = this.matcherRegex, stripPrefix = this.stripPrefix, stripTrailingSlash = this.stripTrailingSlash, decodePercentEncoding = this.decodePercentEncoding, tagBuilder = this.tagBuilder, matches = [], match;\n            while ((match = matcherRegex.exec(text)) !== null) {\n                var matchStr = match[0], schemeUrlMatch = match[1], wwwUrlMatch = match[4], wwwProtocolRelativeMatch = match[5], \n                //tldUrlMatch = match[ 8 ],  -- not needed at the moment\n                tldProtocolRelativeMatch = match[9], offset = match.index, protocolRelativeMatch = wwwProtocolRelativeMatch || tldProtocolRelativeMatch, prevChar = text.charAt(offset - 1);\n                if (!UrlMatchValidator.isValid(matchStr, schemeUrlMatch)) {\n                    continue;\n                }\n                // If the match is preceded by an '@' character, then it is either\n                // an email address or a username. Skip these types of matches.\n                if (offset > 0 && prevChar === '@') {\n                    continue;\n                }\n                // If it's a protocol-relative '//' match, but the character before the '//'\n                // was a word character (i.e. a letter/number), then we found the '//' in the\n                // middle of another word (such as \"asdf//asdf.com\"). In this case, skip the\n                // match.\n                if (offset > 0 && protocolRelativeMatch && this.wordCharRegExp.test(prevChar)) {\n                    continue;\n                }\n                if (/\\?$/.test(matchStr)) {\n                    matchStr = matchStr.substr(0, matchStr.length - 1);\n                }\n                // Handle a closing parenthesis at the end of the match, and exclude\n                // it if there is not a matching open parenthesis in the match\n                // itself.\n                if (this.matchHasUnbalancedClosingParen(matchStr)) {\n                    matchStr = matchStr.substr(0, matchStr.length - 1); // remove the trailing \")\"\n                }\n                else {\n                    // Handle an invalid character after the TLD\n                    var pos = this.matchHasInvalidCharAfterTld(matchStr, schemeUrlMatch);\n                    if (pos > -1) {\n                        matchStr = matchStr.substr(0, pos); // remove the trailing invalid chars\n                    }\n                }\n                var urlMatchType = schemeUrlMatch ? 'scheme' : (wwwUrlMatch ? 'www' : 'tld'), protocolUrlMatch = !!schemeUrlMatch;\n                matches.push(new UrlMatch({\n                    tagBuilder: tagBuilder,\n                    matchedText: matchStr,\n                    offset: offset,\n                    urlMatchType: urlMatchType,\n                    url: matchStr,\n                    protocolUrlMatch: protocolUrlMatch,\n                    protocolRelativeMatch: !!protocolRelativeMatch,\n                    stripPrefix: stripPrefix,\n                    stripTrailingSlash: stripTrailingSlash,\n                    decodePercentEncoding: decodePercentEncoding,\n                }));\n            }\n            return matches;\n        };\n        /**\n         * Determines if a match found has an unmatched closing parenthesis. If so,\n         * this parenthesis will be removed from the match itself, and appended\n         * after the generated anchor tag.\n         *\n         * A match may have an extra closing parenthesis at the end of the match\n         * because the regular expression must include parenthesis for URLs such as\n         * \"wikipedia.com/something_(disambiguation)\", which should be auto-linked.\n         *\n         * However, an extra parenthesis *will* be included when the URL itself is\n         * wrapped in parenthesis, such as in the case of \"(wikipedia.com/something_(disambiguation))\".\n         * In this case, the last closing parenthesis should *not* be part of the\n         * URL itself, and this method will return `true`.\n         *\n         * @private\n         * @param {String} matchStr The full match string from the {@link #matcherRegex}.\n         * @return {Boolean} `true` if there is an unbalanced closing parenthesis at\n         *   the end of the `matchStr`, `false` otherwise.\n         */\n        UrlMatcher.prototype.matchHasUnbalancedClosingParen = function (matchStr) {\n            var lastChar = matchStr.charAt(matchStr.length - 1);\n            if (lastChar === ')') {\n                var openParensMatch = matchStr.match(this.openParensRe), closeParensMatch = matchStr.match(this.closeParensRe), numOpenParens = (openParensMatch && openParensMatch.length) || 0, numCloseParens = (closeParensMatch && closeParensMatch.length) || 0;\n                if (numOpenParens < numCloseParens) {\n                    return true;\n                }\n            }\n            return false;\n        };\n        /**\n         * Determine if there's an invalid character after the TLD in a URL. Valid\n         * characters after TLD are ':/?#'. Exclude scheme matched URLs from this\n         * check.\n         *\n         * @private\n         * @param {String} urlMatch The matched URL, if there was one. Will be an\n         *   empty string if the match is not a URL match.\n         * @param {String} schemeUrlMatch The match URL string for a scheme\n         *   match. Ex: 'http://yahoo.com'. This is used to match something like\n         *   'http://localhost', where we won't double check that the domain name\n         *   has at least one '.' in it.\n         * @return {Number} the position where the invalid character was found. If\n         *   no such character was found, returns -1\n         */\n        UrlMatcher.prototype.matchHasInvalidCharAfterTld = function (urlMatch, schemeUrlMatch) {\n            if (!urlMatch) {\n                return -1;\n            }\n            var offset = 0;\n            if (schemeUrlMatch) {\n                offset = urlMatch.indexOf(':');\n                urlMatch = urlMatch.slice(offset);\n            }\n            var re = new RegExp(\"^((.?\\/\\/)?[-.\" + alphaNumericCharsStr + \"]*[-\" + alphaNumericCharsStr + \"]\\\\.[-\" + alphaNumericCharsStr + \"]+)\");\n            var res = re.exec(urlMatch);\n            if (res === null) {\n                return -1;\n            }\n            offset += res[1].length;\n            urlMatch = urlMatch.slice(res[1].length);\n            if (/^[^-.A-Za-z0-9:\\/?#]/.test(urlMatch)) {\n                return offset;\n            }\n            return -1;\n        };\n        return UrlMatcher;\n    }(Matcher));\n\n    var __extends$b = (undefined && undefined.__extends) || (function () {\n        var extendStatics = function (d, b) {\n            extendStatics = Object.setPrototypeOf ||\n                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n            return extendStatics(d, b);\n        };\n        return function (d, b) {\n            extendStatics(d, b);\n            function __() { this.constructor = d; }\n            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n        };\n    })();\n    /**\n     * @class Autolinker.matcher.Hashtag\n     * @extends Autolinker.matcher.Matcher\n     *\n     * Matcher to find HashtagMatch matches in an input string.\n     */\n    var HashtagMatcher = /** @class */ (function (_super) {\n        __extends$b(HashtagMatcher, _super);\n        /**\n         * @constructor\n         * @param {Object} cfg The configuration properties for the Match instance,\n         *   specified in an Object (map).\n         */\n        function HashtagMatcher(cfg) {\n            var _this = _super.call(this, cfg) || this;\n            /**\n             * The regular expression to match Hashtags. Example match:\n             *\n             *     #asdf\n             *\n             * @private\n             * @property {RegExp} matcherRegex\n             */\n            _this.matcherRegex = new RegExp('#[_' + alphaNumericCharsStr + ']{1,139}', 'g');\n            /**\n             * The regular expression to use to check the character before a username match to\n             * make sure we didn't accidentally match an email address.\n             *\n             * For example, the string \"asdf@asdf.com\" should not match \"@asdf\" as a username.\n             *\n             * @private\n             * @property {RegExp} nonWordCharRegex\n             */\n            _this.nonWordCharRegex = new RegExp('[^' + alphaNumericCharsStr + ']');\n            _this.serviceName = cfg.serviceName;\n            return _this;\n        }\n        /**\n         * @inheritdoc\n         */\n        HashtagMatcher.prototype.parseMatches = function (text) {\n            var matcherRegex = this.matcherRegex, nonWordCharRegex = this.nonWordCharRegex, serviceName = this.serviceName, tagBuilder = this.tagBuilder, matches = [], match;\n            while ((match = matcherRegex.exec(text)) !== null) {\n                var offset = match.index, prevChar = text.charAt(offset - 1);\n                // If we found the match at the beginning of the string, or we found the match\n                // and there is a whitespace char in front of it (meaning it is not a '#' char\n                // in the middle of a word), then it is a hashtag match.\n                if (offset === 0 || nonWordCharRegex.test(prevChar)) {\n                    var matchedText = match[0], hashtag = match[0].slice(1); // strip off the '#' character at the beginning\n                    matches.push(new HashtagMatch({\n                        tagBuilder: tagBuilder,\n                        matchedText: matchedText,\n                        offset: offset,\n                        serviceName: serviceName,\n                        hashtag: hashtag\n                    }));\n                }\n            }\n            return matches;\n        };\n        return HashtagMatcher;\n    }(Matcher));\n\n    var __extends$c = (undefined && undefined.__extends) || (function () {\n        var extendStatics = function (d, b) {\n            extendStatics = Object.setPrototypeOf ||\n                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n            return extendStatics(d, b);\n        };\n        return function (d, b) {\n            extendStatics(d, b);\n            function __() { this.constructor = d; }\n            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n        };\n    })();\n    /**\n     * @class Autolinker.matcher.Phone\n     * @extends Autolinker.matcher.Matcher\n     *\n     * Matcher to find Phone number matches in an input string.\n     *\n     * See this class's superclass ({@link Autolinker.matcher.Matcher}) for more\n     * details.\n     */\n    var PhoneMatcher = /** @class */ (function (_super) {\n        __extends$c(PhoneMatcher, _super);\n        function PhoneMatcher() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            /**\n             * The regular expression to match Phone numbers. Example match:\n             *\n             *     (123) 456-7890\n             *\n             * This regular expression has the following capturing groups:\n             *\n             * 1 or 2. The prefixed '+' sign, if there is one.\n             *\n             * @private\n             * @property {RegExp} matcherRegex\n             */\n            _this.matcherRegex = /(?:(?:(?:(\\+)?\\d{1,3}[-\\040.]?)?\\(?\\d{3}\\)?[-\\040.]?\\d{3}[-\\040.]?\\d{4})|(?:(\\+)(?:9[976]\\d|8[987530]\\d|6[987]\\d|5[90]\\d|42\\d|3[875]\\d|2[98654321]\\d|9[8543210]|8[6421]|6[6543210]|5[87654321]|4[987654310]|3[9643210]|2[70]|7|1)[-\\040.]?(?:\\d[-\\040.]?){6,12}\\d+))([,;]+[0-9]+#?)*/g;\n            return _this;\n        }\n        // ex: (123) 456-7890, 123 456 7890, 123-456-7890, +18004441234,,;,10226420346#,\n        // +1 (800) 444 1234, 10226420346#, 1-800-444-1234,1022,64,20346#\n        /**\n         * @inheritdoc\n         */\n        PhoneMatcher.prototype.parseMatches = function (text) {\n            var matcherRegex = this.matcherRegex, tagBuilder = this.tagBuilder, matches = [], match;\n            while ((match = matcherRegex.exec(text)) !== null) {\n                // Remove non-numeric values from phone number string\n                var matchedText = match[0], cleanNumber = matchedText.replace(/[^0-9,;#]/g, ''), // strip out non-digit characters exclude comma semicolon and #\n                plusSign = !!(match[1] || match[2]), // match[ 1 ] or match[ 2 ] is the prefixed plus sign, if there is one\n                before = match.index == 0 ? '' : text.substr(match.index - 1, 1), after = text.substr(match.index + matchedText.length, 1), contextClear = !before.match(/\\d/) && !after.match(/\\d/);\n                if (this.testMatch(match[3]) && this.testMatch(matchedText) && contextClear) {\n                    matches.push(new PhoneMatch({\n                        tagBuilder: tagBuilder,\n                        matchedText: matchedText,\n                        offset: match.index,\n                        number: cleanNumber,\n                        plusSign: plusSign\n                    }));\n                }\n            }\n            return matches;\n        };\n        PhoneMatcher.prototype.testMatch = function (text) {\n            return /\\D/.test(text);\n        };\n        return PhoneMatcher;\n    }(Matcher));\n\n    var __extends$d = (undefined && undefined.__extends) || (function () {\n        var extendStatics = function (d, b) {\n            extendStatics = Object.setPrototypeOf ||\n                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n            return extendStatics(d, b);\n        };\n        return function (d, b) {\n            extendStatics(d, b);\n            function __() { this.constructor = d; }\n            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n        };\n    })();\n    /**\n     * @class Autolinker.matcher.Mention\n     * @extends Autolinker.matcher.Matcher\n     *\n     * Matcher to find/replace username matches in an input string.\n     */\n    var MentionMatcher = /** @class */ (function (_super) {\n        __extends$d(MentionMatcher, _super);\n        /**\n         * @constructor\n         * @param {Object} cfg The configuration properties for the Match instance,\n         *   specified in an Object (map).\n         */\n        function MentionMatcher(cfg) {\n            var _this = _super.call(this, cfg) || this;\n            /**\n             * Hash of regular expression to match username handles. Example match:\n             *\n             *     @asdf\n             *\n             * @private\n             * @property {Object} matcherRegexes\n             */\n            _this.matcherRegexes = {\n                'twitter': new RegExp('@[_' + alphaNumericCharsStr + ']{1,20}', 'g'),\n                'instagram': new RegExp('@[_.' + alphaNumericCharsStr + ']{1,50}', 'g'),\n                'soundcloud': new RegExp('@[_.' + alphaNumericCharsStr + \"\\-\" + ']{1,50}', 'g')\n            };\n            /**\n             * The regular expression to use to check the character before a username match to\n             * make sure we didn't accidentally match an email address.\n             *\n             * For example, the string \"asdf@asdf.com\" should not match \"@asdf\" as a username.\n             *\n             * @private\n             * @property {RegExp} nonWordCharRegex\n             */\n            _this.nonWordCharRegex = new RegExp('[^' + alphaNumericCharsStr + ']');\n            _this.serviceName = cfg.serviceName;\n            return _this;\n        }\n        /**\n         * @inheritdoc\n         */\n        MentionMatcher.prototype.parseMatches = function (text) {\n            var serviceName = this.serviceName, matcherRegex = this.matcherRegexes[this.serviceName], nonWordCharRegex = this.nonWordCharRegex, tagBuilder = this.tagBuilder, matches = [], match;\n            if (!matcherRegex) {\n                return matches;\n            }\n            while ((match = matcherRegex.exec(text)) !== null) {\n                var offset = match.index, prevChar = text.charAt(offset - 1);\n                // If we found the match at the beginning of the string, or we found the match\n                // and there is a whitespace char in front of it (meaning it is not an email\n                // address), then it is a username match.\n                if (offset === 0 || nonWordCharRegex.test(prevChar)) {\n                    var matchedText = match[0].replace(/\\.+$/g, ''), // strip off trailing .\n                    mention = matchedText.slice(1); // strip off the '@' character at the beginning\n                    matches.push(new MentionMatch({\n                        tagBuilder: tagBuilder,\n                        matchedText: matchedText,\n                        offset: offset,\n                        serviceName: serviceName,\n                        mention: mention\n                    }));\n                }\n            }\n            return matches;\n        };\n        return MentionMatcher;\n    }(Matcher));\n\n    /**\n     * @class Autolinker\n     * @extends Object\n     *\n     * Utility class used to process a given string of text, and wrap the matches in\n     * the appropriate anchor (&lt;a&gt;) tags to turn them into links.\n     *\n     * Any of the configuration options may be provided in an Object (map) provided\n     * to the Autolinker constructor, which will configure how the {@link #link link()}\n     * method will process the links.\n     *\n     * For example:\n     *\n     *     var autolinker = new Autolinker( {\n     *         newWindow : false,\n     *         truncate  : 30\n     *     } );\n     *\n     *     var html = autolinker.link( \"Joe went to www.yahoo.com\" );\n     *     // produces: 'Joe went to <a href=\"http://www.yahoo.com\">yahoo.com</a>'\n     *\n     *\n     * The {@link #static-link static link()} method may also be used to inline\n     * options into a single call, which may be more convenient for one-off uses.\n     * For example:\n     *\n     *     var html = Autolinker.link( \"Joe went to www.yahoo.com\", {\n     *         newWindow : false,\n     *         truncate  : 30\n     *     } );\n     *     // produces: 'Joe went to <a href=\"http://www.yahoo.com\">yahoo.com</a>'\n     *\n     *\n     * ## Custom Replacements of Links\n     *\n     * If the configuration options do not provide enough flexibility, a {@link #replaceFn}\n     * may be provided to fully customize the output of Autolinker. This function is\n     * called once for each URL/Email/Phone#/Hashtag/Mention (Twitter, Instagram, Soundcloud)\n     * match that is encountered.\n     *\n     * For example:\n     *\n     *     var input = \"...\";  // string with URLs, Email Addresses, Phone #s, Hashtags, and Mentions (Twitter, Instagram, Soundcloud)\n     *\n     *     var linkedText = Autolinker.link( input, {\n     *         replaceFn : function( match ) {\n     *             console.log( \"href = \", match.getAnchorHref() );\n     *             console.log( \"text = \", match.getAnchorText() );\n     *\n     *             switch( match.getType() ) {\n     *                 case 'url' :\n     *                     console.log( \"url: \", match.getUrl() );\n     *\n     *                     if( match.getUrl().indexOf( 'mysite.com' ) === -1 ) {\n     *                         var tag = match.buildTag();  // returns an `Autolinker.HtmlTag` instance, which provides mutator methods for easy changes\n     *                         tag.setAttr( 'rel', 'nofollow' );\n     *                         tag.addClass( 'external-link' );\n     *\n     *                         return tag;\n     *\n     *                     } else {\n     *                         return true;  // let Autolinker perform its normal anchor tag replacement\n     *                     }\n     *\n     *                 case 'email' :\n     *                     var email = match.getEmail();\n     *                     console.log( \"email: \", email );\n     *\n     *                     if( email === \"my@own.address\" ) {\n     *                         return false;  // don't auto-link this particular email address; leave as-is\n     *                     } else {\n     *                         return;  // no return value will have Autolinker perform its normal anchor tag replacement (same as returning `true`)\n     *                     }\n     *\n     *                 case 'phone' :\n     *                     var phoneNumber = match.getPhoneNumber();\n     *                     console.log( phoneNumber );\n     *\n     *                     return '<a href=\"http://newplace.to.link.phone.numbers.to/\">' + phoneNumber + '</a>';\n     *\n     *                 case 'hashtag' :\n     *                     var hashtag = match.getHashtag();\n     *                     console.log( hashtag );\n     *\n     *                     return '<a href=\"http://newplace.to.link.hashtag.handles.to/\">' + hashtag + '</a>';\n     *\n     *                 case 'mention' :\n     *                     var mention = match.getMention();\n     *                     console.log( mention );\n     *\n     *                     return '<a href=\"http://newplace.to.link.mention.to/\">' + mention + '</a>';\n     *             }\n     *         }\n     *     } );\n     *\n     *\n     * The function may return the following values:\n     *\n     * - `true` (Boolean): Allow Autolinker to replace the match as it normally\n     *   would.\n     * - `false` (Boolean): Do not replace the current match at all - leave as-is.\n     * - Any String: If a string is returned from the function, the string will be\n     *   used directly as the replacement HTML for the match.\n     * - An {@link Autolinker.HtmlTag} instance, which can be used to build/modify\n     *   an HTML tag before writing out its HTML text.\n     *\n     * @constructor\n     * @param {Object} [cfg] The configuration options for the Autolinker instance,\n     *   specified in an Object (map).\n     */\n    var Autolinker = /** @class */ (function () {\n        function Autolinker(cfg) {\n            if (cfg === void 0) { cfg = {}; }\n            /**\n             * The Autolinker version number exposed on the instance itself.\n             *\n             * Ex: 0.25.1\n             */\n            this.version = Autolinker.version;\n            this.urls = this.normalizeUrlsCfg(cfg.urls);\n            this.email = typeof cfg.email === 'boolean' ? cfg.email : true;\n            this.phone = typeof cfg.phone === 'boolean' ? cfg.phone : true;\n            this.hashtag = cfg.hashtag || false;\n            this.mention = cfg.mention || false;\n            this.newWindow = typeof cfg.newWindow === 'boolean' ? cfg.newWindow : true;\n            this.stripPrefix = this.normalizeStripPrefixCfg(cfg.stripPrefix);\n            this.stripTrailingSlash = typeof cfg.stripTrailingSlash === 'boolean' ? cfg.stripTrailingSlash : true;\n            this.decodePercentEncoding = typeof cfg.decodePercentEncoding === 'boolean' ? cfg.decodePercentEncoding : true;\n            // Validate the value of the `mention` cfg\n            var mention = this.mention;\n            if (mention !== false && mention !== 'twitter' && mention !== 'instagram') {\n                throw new Error(\"invalid `mention` cfg - see docs\");\n            }\n            // Validate the value of the `hashtag` cfg\n            var hashtag = this.hashtag;\n            if (hashtag !== false && hashtag !== 'twitter' && hashtag !== 'facebook' && hashtag !== 'instagram') {\n                throw new Error(\"invalid `hashtag` cfg - see docs\");\n            }\n            this.truncate = this.normalizeTruncateCfg(cfg.truncate);\n            this.className = cfg.className || '';\n            this.replaceFn = cfg.replaceFn || null;\n            this.context = cfg.context || this;\n            this.htmlParser = new HtmlParser();\n            this.matchers = null;\n            this.tagBuilder = null;\n        }\n        /**\n         * Automatically links URLs, Email addresses, Phone Numbers, Twitter handles,\n         * Hashtags, and Mentions found in the given chunk of HTML. Does not link URLs\n         * found within HTML tags.\n         *\n         * For instance, if given the text: `You should go to http://www.yahoo.com`,\n         * then the result will be `You should go to &lt;a href=\"http://www.yahoo.com\"&gt;http://www.yahoo.com&lt;/a&gt;`\n         *\n         * Example:\n         *\n         *     var linkedText = Autolinker.link( \"Go to google.com\", { newWindow: false } );\n         *     // Produces: \"Go to <a href=\"http://google.com\">google.com</a>\"\n         *\n         * @static\n         * @param {String} textOrHtml The HTML or text to find matches within (depending\n         *   on if the {@link #urls}, {@link #email}, {@link #phone}, {@link #mention},\n         *   {@link #hashtag}, and {@link #mention} options are enabled).\n         * @param {Object} [options] Any of the configuration options for the Autolinker\n         *   class, specified in an Object (map). See the class description for an\n         *   example call.\n         * @return {String} The HTML text, with matches automatically linked.\n         */\n        Autolinker.link = function (textOrHtml, options) {\n            var autolinker = new Autolinker(options);\n            return autolinker.link(textOrHtml);\n        };\n        /**\n         * Parses the input `textOrHtml` looking for URLs, email addresses, phone\n         * numbers, username handles, and hashtags (depending on the configuration\n         * of the Autolinker instance), and returns an array of {@link Autolinker.match.Match}\n         * objects describing those matches (without making any replacements).\n         *\n         * Note that if parsing multiple pieces of text, it is slightly more efficient\n         * to create an Autolinker instance, and use the instance-level {@link #parse}\n         * method.\n         *\n         * Example:\n         *\n         *     var matches = Autolinker.parse( \"Hello google.com, I am asdf@asdf.com\", {\n         *         urls: true,\n         *         email: true\n         *     } );\n         *\n         *     console.log( matches.length );           // 2\n         *     console.log( matches[ 0 ].getType() );   // 'url'\n         *     console.log( matches[ 0 ].getUrl() );    // 'google.com'\n         *     console.log( matches[ 1 ].getType() );   // 'email'\n         *     console.log( matches[ 1 ].getEmail() );  // 'asdf@asdf.com'\n         *\n         * @static\n         * @param {String} textOrHtml The HTML or text to find matches within\n         *   (depending on if the {@link #urls}, {@link #email}, {@link #phone},\n         *   {@link #hashtag}, and {@link #mention} options are enabled).\n         * @param {Object} [options] Any of the configuration options for the Autolinker\n         *   class, specified in an Object (map). See the class description for an\n         *   example call.\n         * @return {Autolinker.match.Match[]} The array of Matches found in the\n         *   given input `textOrHtml`.\n         */\n        Autolinker.parse = function (textOrHtml, options) {\n            var autolinker = new Autolinker(options);\n            return autolinker.parse(textOrHtml);\n        };\n        /**\n         * Normalizes the {@link #urls} config into an Object with 3 properties:\n         * `schemeMatches`, `wwwMatches`, and `tldMatches`, all Booleans.\n         *\n         * See {@link #urls} config for details.\n         *\n         * @param {Boolean/Object} urls\n         * @return {Object}\n         */\n        Autolinker.prototype.normalizeUrlsCfg = function (urls) {\n            if (urls == null)\n                urls = true; // default to `true`\n            if (typeof urls === 'boolean') {\n                return { schemeMatches: urls, wwwMatches: urls, tldMatches: urls };\n            }\n            else { // object form\n                return {\n                    schemeMatches: typeof urls.schemeMatches === 'boolean' ? urls.schemeMatches : true,\n                    wwwMatches: typeof urls.wwwMatches === 'boolean' ? urls.wwwMatches : true,\n                    tldMatches: typeof urls.tldMatches === 'boolean' ? urls.tldMatches : true\n                };\n            }\n        };\n        /**\n         * Normalizes the {@link #stripPrefix} config into an Object with 2\n         * properties: `scheme`, and `www` - both Booleans.\n         *\n         * See {@link #stripPrefix} config for details.\n         *\n         * @private\n         * @param {Boolean/Object} stripPrefix\n         * @return {Object}\n         */\n        Autolinker.prototype.normalizeStripPrefixCfg = function (stripPrefix) {\n            if (stripPrefix == null)\n                stripPrefix = true; // default to `true`\n            if (typeof stripPrefix === 'boolean') {\n                return { scheme: stripPrefix, www: stripPrefix };\n            }\n            else { // object form\n                return {\n                    scheme: typeof stripPrefix.scheme === 'boolean' ? stripPrefix.scheme : true,\n                    www: typeof stripPrefix.www === 'boolean' ? stripPrefix.www : true\n                };\n            }\n        };\n        /**\n         * Normalizes the {@link #truncate} config into an Object with 2 properties:\n         * `length` (Number), and `location` (String).\n         *\n         * See {@link #truncate} config for details.\n         *\n         * @private\n         * @param {Number/Object} truncate\n         * @return {Object}\n         */\n        Autolinker.prototype.normalizeTruncateCfg = function (truncate) {\n            if (typeof truncate === 'number') {\n                return { length: truncate, location: 'end' };\n            }\n            else { // object, or undefined/null\n                return defaults(truncate || {}, {\n                    length: Number.POSITIVE_INFINITY,\n                    location: 'end'\n                });\n            }\n        };\n        /**\n         * Parses the input `textOrHtml` looking for URLs, email addresses, phone\n         * numbers, username handles, and hashtags (depending on the configuration\n         * of the Autolinker instance), and returns an array of {@link Autolinker.match.Match}\n         * objects describing those matches (without making any replacements).\n         *\n         * This method is used by the {@link #link} method, but can also be used to\n         * simply do parsing of the input in order to discover what kinds of links\n         * there are and how many.\n         *\n         * Example usage:\n         *\n         *     var autolinker = new Autolinker( {\n         *         urls: true,\n         *         email: true\n         *     } );\n         *\n         *     var matches = autolinker.parse( \"Hello google.com, I am asdf@asdf.com\" );\n         *\n         *     console.log( matches.length );           // 2\n         *     console.log( matches[ 0 ].getType() );   // 'url'\n         *     console.log( matches[ 0 ].getUrl() );    // 'google.com'\n         *     console.log( matches[ 1 ].getType() );   // 'email'\n         *     console.log( matches[ 1 ].getEmail() );  // 'asdf@asdf.com'\n         *\n         * @param {String} textOrHtml The HTML or text to find matches within\n         *   (depending on if the {@link #urls}, {@link #email}, {@link #phone},\n         *   {@link #hashtag}, and {@link #mention} options are enabled).\n         * @return {Autolinker.match.Match[]} The array of Matches found in the\n         *   given input `textOrHtml`.\n         */\n        Autolinker.prototype.parse = function (textOrHtml) {\n            var htmlNodes = this.htmlParser.parse(textOrHtml), anchorTagStackCount = 0, // used to only process text around anchor tags, and any inner text/html they may have;\n            matches = [];\n            // Find all matches within the `textOrHtml` (but not matches that are\n            // already nested within <a>, <style> and <script> tags)\n            for (var i = 0, len = htmlNodes.length; i < len; i++) {\n                var node = htmlNodes[i], nodeType = node.getType();\n                if (nodeType === 'element' && ['a', 'style', 'script'].indexOf(node.getTagName()) !== -1) { // Process HTML anchor, style and script element nodes in the input `textOrHtml` to find out when we're within an <a>, <style> or <script> tag\n                    if (!node.isClosing()) { // it's the start <a>, <style> or <script> tag\n                        anchorTagStackCount++;\n                    }\n                    else { // it's the end </a>, </style> or </script> tag\n                        anchorTagStackCount = Math.max(anchorTagStackCount - 1, 0); // attempt to handle extraneous </a> tags by making sure the stack count never goes below 0\n                    }\n                }\n                else if (nodeType === 'text' && anchorTagStackCount === 0) { // Process text nodes that are not within an <a>, <style> and <script> tag\n                    var textNodeMatches = this.parseText(node.getText(), node.getOffset());\n                    matches.push.apply(matches, textNodeMatches);\n                }\n            }\n            // After we have found all matches, remove subsequent matches that\n            // overlap with a previous match. This can happen for instance with URLs,\n            // where the url 'google.com/#link' would match '#link' as a hashtag.\n            matches = this.compactMatches(matches);\n            // And finally, remove matches for match types that have been turned\n            // off. We needed to have all match types turned on initially so that\n            // things like hashtags could be filtered out if they were really just\n            // part of a URL match (for instance, as a named anchor).\n            matches = this.removeUnwantedMatches(matches);\n            return matches;\n        };\n        /**\n         * After we have found all matches, we need to remove matches that overlap\n         * with a previous match. This can happen for instance with URLs, where the\n         * url 'google.com/#link' would match '#link' as a hashtag. Because the\n         * '#link' part is contained in a larger match that comes before the HashTag\n         * match, we'll remove the HashTag match.\n         *\n         * @private\n         * @param {Autolinker.match.Match[]} matches\n         * @return {Autolinker.match.Match[]}\n         */\n        Autolinker.prototype.compactMatches = function (matches) {\n            // First, the matches need to be sorted in order of offset\n            matches.sort(function (a, b) { return a.getOffset() - b.getOffset(); });\n            for (var i = 0; i < matches.length - 1; i++) {\n                var match = matches[i], offset = match.getOffset(), matchedTextLength = match.getMatchedText().length, endIdx = offset + matchedTextLength;\n                if (i + 1 < matches.length) {\n                    // Remove subsequent matches that equal offset with current match\n                    if (matches[i + 1].getOffset() === offset) {\n                        var removeIdx = matches[i + 1].getMatchedText().length > matchedTextLength ? i : i + 1;\n                        matches.splice(removeIdx, 1);\n                        continue;\n                    }\n                    // Remove subsequent matches that overlap with the current match\n                    if (matches[i + 1].getOffset() < endIdx) {\n                        matches.splice(i + 1, 1);\n                    }\n                }\n            }\n            return matches;\n        };\n        /**\n         * Removes matches for matchers that were turned off in the options. For\n         * example, if {@link #hashtag hashtags} were not to be matched, we'll\n         * remove them from the `matches` array here.\n         *\n         * Note: we *must* use all Matchers on the input string, and then filter\n         * them out later. For example, if the options were `{ url: false, hashtag: true }`,\n         * we wouldn't want to match the text '#link' as a HashTag inside of the text\n         * 'google.com/#link'. The way the algorithm works is that we match the full\n         * URL first (which prevents the accidental HashTag match), and then we'll\n         * simply throw away the URL match.\n         *\n         * @private\n         * @param {Autolinker.match.Match[]} matches The array of matches to remove\n         *   the unwanted matches from. Note: this array is mutated for the\n         *   removals.\n         * @return {Autolinker.match.Match[]} The mutated input `matches` array.\n         */\n        Autolinker.prototype.removeUnwantedMatches = function (matches) {\n            if (!this.hashtag)\n                remove(matches, function (match) { return match.getType() === 'hashtag'; });\n            if (!this.email)\n                remove(matches, function (match) { return match.getType() === 'email'; });\n            if (!this.phone)\n                remove(matches, function (match) { return match.getType() === 'phone'; });\n            if (!this.mention)\n                remove(matches, function (match) { return match.getType() === 'mention'; });\n            if (!this.urls.schemeMatches) {\n                remove(matches, function (m) { return m.getType() === 'url' && m.getUrlMatchType() === 'scheme'; });\n            }\n            if (!this.urls.wwwMatches) {\n                remove(matches, function (m) { return m.getType() === 'url' && m.getUrlMatchType() === 'www'; });\n            }\n            if (!this.urls.tldMatches) {\n                remove(matches, function (m) { return m.getType() === 'url' && m.getUrlMatchType() === 'tld'; });\n            }\n            return matches;\n        };\n        /**\n         * Parses the input `text` looking for URLs, email addresses, phone\n         * numbers, username handles, and hashtags (depending on the configuration\n         * of the Autolinker instance), and returns an array of {@link Autolinker.match.Match}\n         * objects describing those matches.\n         *\n         * This method processes a **non-HTML string**, and is used to parse and\n         * match within the text nodes of an HTML string. This method is used\n         * internally by {@link #parse}.\n         *\n         * @private\n         * @param {String} text The text to find matches within (depending on if the\n         *   {@link #urls}, {@link #email}, {@link #phone},\n         *   {@link #hashtag}, and {@link #mention} options are enabled). This must be a non-HTML string.\n         * @param {Number} [offset=0] The offset of the text node within the\n         *   original string. This is used when parsing with the {@link #parse}\n         *   method to generate correct offsets within the {@link Autolinker.match.Match}\n         *   instances, but may be omitted if calling this method publicly.\n         * @return {Autolinker.match.Match[]} The array of Matches found in the\n         *   given input `text`.\n         */\n        Autolinker.prototype.parseText = function (text, offset) {\n            if (offset === void 0) { offset = 0; }\n            offset = offset || 0;\n            var matchers = this.getMatchers(), matches = [];\n            for (var i = 0, numMatchers = matchers.length; i < numMatchers; i++) {\n                var textMatches = matchers[i].parseMatches(text);\n                // Correct the offset of each of the matches. They are originally\n                // the offset of the match within the provided text node, but we\n                // need to correct them to be relative to the original HTML input\n                // string (i.e. the one provided to #parse).\n                for (var j = 0, numTextMatches = textMatches.length; j < numTextMatches; j++) {\n                    textMatches[j].setOffset(offset + textMatches[j].getOffset());\n                }\n                matches.push.apply(matches, textMatches);\n            }\n            return matches;\n        };\n        /**\n         * Automatically links URLs, Email addresses, Phone numbers, Hashtags,\n         * and Mentions (Twitter, Instagram, Soundcloud) found in the given chunk of HTML. Does not link\n         * URLs found within HTML tags.\n         *\n         * For instance, if given the text: `You should go to http://www.yahoo.com`,\n         * then the result will be `You should go to\n         * &lt;a href=\"http://www.yahoo.com\"&gt;http://www.yahoo.com&lt;/a&gt;`\n         *\n         * This method finds the text around any HTML elements in the input\n         * `textOrHtml`, which will be the text that is processed. Any original HTML\n         * elements will be left as-is, as well as the text that is already wrapped\n         * in anchor (&lt;a&gt;) tags.\n         *\n         * @param {String} textOrHtml The HTML or text to autolink matches within\n         *   (depending on if the {@link #urls}, {@link #email}, {@link #phone}, {@link #hashtag}, and {@link #mention} options are enabled).\n         * @return {String} The HTML, with matches automatically linked.\n         */\n        Autolinker.prototype.link = function (textOrHtml) {\n            if (!textOrHtml) {\n                return \"\";\n            } // handle `null` and `undefined`\n            var matches = this.parse(textOrHtml), newHtml = [], lastIndex = 0;\n            for (var i = 0, len = matches.length; i < len; i++) {\n                var match = matches[i];\n                newHtml.push(textOrHtml.substring(lastIndex, match.getOffset()));\n                newHtml.push(this.createMatchReturnVal(match));\n                lastIndex = match.getOffset() + match.getMatchedText().length;\n            }\n            newHtml.push(textOrHtml.substring(lastIndex)); // handle the text after the last match\n            return newHtml.join('');\n        };\n        /**\n         * Creates the return string value for a given match in the input string.\n         *\n         * This method handles the {@link #replaceFn}, if one was provided.\n         *\n         * @private\n         * @param {Autolinker.match.Match} match The Match object that represents\n         *   the match.\n         * @return {String} The string that the `match` should be replaced with.\n         *   This is usually the anchor tag string, but may be the `matchStr` itself\n         *   if the match is not to be replaced.\n         */\n        Autolinker.prototype.createMatchReturnVal = function (match) {\n            // Handle a custom `replaceFn` being provided\n            var replaceFnResult;\n            if (this.replaceFn) {\n                replaceFnResult = this.replaceFn.call(this.context, match); // Autolinker instance is the context\n            }\n            if (typeof replaceFnResult === 'string') {\n                return replaceFnResult; // `replaceFn` returned a string, use that\n            }\n            else if (replaceFnResult === false) {\n                return match.getMatchedText(); // no replacement for the match\n            }\n            else if (replaceFnResult instanceof HtmlTag) {\n                return replaceFnResult.toAnchorString();\n            }\n            else { // replaceFnResult === true, or no/unknown return value from function\n                // Perform Autolinker's default anchor tag generation\n                var anchorTag = match.buildTag(); // returns an Autolinker.HtmlTag instance\n                return anchorTag.toAnchorString();\n            }\n        };\n        /**\n         * Lazily instantiates and returns the {@link Autolinker.matcher.Matcher}\n         * instances for this Autolinker instance.\n         *\n         * @protected\n         * @return {Autolinker.matcher.Matcher[]}\n         */\n        Autolinker.prototype.getMatchers = function () {\n            if (!this.matchers) {\n                var tagBuilder = this.getTagBuilder();\n                var matchers = [\n                    new HashtagMatcher({ tagBuilder: tagBuilder, serviceName: this.hashtag }),\n                    new EmailMatcher({ tagBuilder: tagBuilder }),\n                    new PhoneMatcher({ tagBuilder: tagBuilder }),\n                    new MentionMatcher({ tagBuilder: tagBuilder, serviceName: this.mention }),\n                    new UrlMatcher({ tagBuilder: tagBuilder, stripPrefix: this.stripPrefix, stripTrailingSlash: this.stripTrailingSlash, decodePercentEncoding: this.decodePercentEncoding })\n                ];\n                return (this.matchers = matchers);\n            }\n            else {\n                return this.matchers;\n            }\n        };\n        /**\n         * Returns the {@link #tagBuilder} instance for this Autolinker instance, lazily instantiating it\n         * if it does not yet exist.\n         *\n         * This method may be used in a {@link #replaceFn} to generate the {@link Autolinker.HtmlTag HtmlTag} instance that\n         * Autolinker would normally generate, and then allow for modifications before returning it. For example:\n         *\n         *     var html = Autolinker.link( \"Test google.com\", {\n         *         replaceFn : function( match ) {\n         *             var tag = match.buildTag();  // returns an {@link Autolinker.HtmlTag} instance\n         *             tag.setAttr( 'rel', 'nofollow' );\n         *\n         *             return tag;\n         *         }\n         *     } );\n         *\n         *     // generated html:\n         *     //   Test <a href=\"http://google.com\" target=\"_blank\" rel=\"nofollow\">google.com</a>\n         *\n         * @return {Autolinker.AnchorTagBuilder}\n         */\n        Autolinker.prototype.getTagBuilder = function () {\n            var tagBuilder = this.tagBuilder;\n            if (!tagBuilder) {\n                tagBuilder = this.tagBuilder = new AnchorTagBuilder({\n                    newWindow: this.newWindow,\n                    truncate: this.truncate,\n                    className: this.className\n                });\n            }\n            return tagBuilder;\n        };\n        /**\n         * The Autolinker version number in the form major.minor.patch\n         *\n         * Ex: 0.25.1\n         */\n        Autolinker.version = '1.8.3';\n        /**\n         * For backwards compatibility with Autolinker 1.x, the AnchorTagBuilder\n         * class is provided as a static on the Autolinker class.\n         */\n        Autolinker.AnchorTagBuilder = AnchorTagBuilder;\n        /**\n         * For backwards compatibility with Autolinker 1.x, the HtmlTag class is\n         * provided as a static on the Autolinker class.\n         */\n        Autolinker.HtmlTag = HtmlTag;\n        /**\n         * For backwards compatibility with Autolinker 1.x, the Matcher classes are\n         * provided as statics on the Autolinker class.\n         */\n        Autolinker.matcher = {\n            Email: EmailMatcher,\n            Hashtag: HashtagMatcher,\n            Matcher: Matcher,\n            Mention: MentionMatcher,\n            Phone: PhoneMatcher,\n            Url: UrlMatcher\n        };\n        /**\n         * For backwards compatibility with Autolinker 1.x, the Match classes are\n         * provided as statics on the Autolinker class.\n         */\n        Autolinker.match = {\n            Email: EmailMatch,\n            Hashtag: HashtagMatch,\n            Match: Match,\n            Mention: MentionMatch,\n            Phone: PhoneMatch,\n            Url: UrlMatch\n        };\n        return Autolinker;\n    }());\n\n    return Autolinker;\n\n}));\n\n\n\n","/**\n * Assigns (shallow copies) the properties of `src` onto `dest`, if the\n * corresponding property on `dest` === `undefined`.\n *\n * @param {Object} dest The destination object.\n * @param {Object} src The source object.\n * @return {Object} The destination object (`dest`)\n */\nexport function defaults(dest, src) {\n    for (var prop in src) {\n        if (src.hasOwnProperty(prop) && dest[prop] === undefined) {\n            dest[prop] = src[prop];\n        }\n    }\n    return dest;\n}\n/**\n * Truncates the `str` at `len - ellipsisChars.length`, and adds the `ellipsisChars` to the\n * end of the string (by default, two periods: '..'). If the `str` length does not exceed\n * `len`, the string will be returned unchanged.\n *\n * @param {String} str The string to truncate and add an ellipsis to.\n * @param {Number} truncateLen The length to truncate the string at.\n * @param {String} [ellipsisChars=...] The ellipsis character(s) to add to the end of `str`\n *   when truncated. Defaults to '...'\n */\nexport function ellipsis(str, truncateLen, ellipsisChars) {\n    var ellipsisLength;\n    if (str.length > truncateLen) {\n        if (ellipsisChars == null) {\n            ellipsisChars = '&hellip;';\n            ellipsisLength = 3;\n        }\n        else {\n            ellipsisLength = ellipsisChars.length;\n        }\n        str = str.substring(0, truncateLen - ellipsisLength) + ellipsisChars;\n    }\n    return str;\n}\n/**\n * Supports `Array.prototype.indexOf()` functionality for old IE (IE8 and below).\n *\n * @param {Array} arr The array to find an element of.\n * @param {*} element The element to find in the array, and return the index of.\n * @return {Number} The index of the `element`, or -1 if it was not found.\n */\nexport function indexOf(arr, element) {\n    if (Array.prototype.indexOf) {\n        return arr.indexOf(element);\n    }\n    else {\n        for (var i = 0, len = arr.length; i < len; i++) {\n            if (arr[i] === element)\n                return i;\n        }\n        return -1;\n    }\n}\n/**\n * Removes array elements based on a filtering function. Mutates the input\n * array.\n *\n * Using this instead of the ES5 Array.prototype.filter() function, to allow\n * Autolinker compatibility with IE8, and also to prevent creating many new\n * arrays in memory for filtering.\n *\n * @param {Array} arr The array to remove elements from. This array is\n *   mutated.\n * @param {Function} fn A function which should return `true` to\n *   remove an element.\n * @return {Array} The mutated input `arr`.\n */\nexport function remove(arr, fn) {\n    for (var i = arr.length - 1; i >= 0; i--) {\n        if (fn(arr[i]) === true) {\n            arr.splice(i, 1);\n        }\n    }\n}\n/**\n * Performs the functionality of what modern browsers do when `String.prototype.split()` is called\n * with a regular expression that contains capturing parenthesis.\n *\n * For example:\n *\n *     // Modern browsers:\n *     \"a,b,c\".split( /(,)/ );  // --> [ 'a', ',', 'b', ',', 'c' ]\n *\n *     // Old IE (including IE8):\n *     \"a,b,c\".split( /(,)/ );  // --> [ 'a', 'b', 'c' ]\n *\n * This method emulates the functionality of modern browsers for the old IE case.\n *\n * @param {String} str The string to split.\n * @param {RegExp} splitRegex The regular expression to split the input `str` on. The splitting\n *   character(s) will be spliced into the array, as in the \"modern browsers\" example in the\n *   description of this method.\n *   Note #1: the supplied regular expression **must** have the 'g' flag specified.\n *   Note #2: for simplicity's sake, the regular expression does not need\n *   to contain capturing parenthesis - it will be assumed that any match has them.\n * @return {String[]} The split array of strings, with the splitting character(s) included.\n */\nexport function splitAndCapture(str, splitRegex) {\n    if (!splitRegex.global)\n        throw new Error(\"`splitRegex` must have the 'g' flag set\");\n    var result = [], lastIdx = 0, match;\n    while (match = splitRegex.exec(str)) {\n        result.push(str.substring(lastIdx, match.index));\n        result.push(match[0]); // push the splitting char(s)\n        lastIdx = match.index + match[0].length;\n    }\n    result.push(str.substring(lastIdx));\n    return result;\n}\n\n//# sourceMappingURL=utils.js.map\n","/**\n * Date: 2015-10-05\n * Author: Kasper Sfren <soefritz@gmail.com> (https://github.com/kafoso)\n *\n * A truncation feature, where the ellipsis will be placed at a section within\n * the URL making it still somewhat human readable.\n *\n * @param {String} url\t\t\t\t\t\t A URL.\n * @param {Number} truncateLen\t\t The maximum length of the truncated output URL string.\n * @param {String} ellipsisChars\t The characters to place within the url, e.g. \"...\".\n * @return {String} The truncated URL.\n */\nexport function truncateSmart(url, truncateLen, ellipsisChars) {\n    var ellipsisLengthBeforeParsing;\n    var ellipsisLength;\n    if (ellipsisChars == null) {\n        ellipsisChars = '&hellip;';\n        ellipsisLength = 3;\n        ellipsisLengthBeforeParsing = 8;\n    }\n    else {\n        ellipsisLength = ellipsisChars.length;\n        ellipsisLengthBeforeParsing = ellipsisChars.length;\n    }\n    var parse_url = function (url) {\n        var urlObj = {};\n        var urlSub = url;\n        var match = urlSub.match(/^([a-z]+):\\/\\//i);\n        if (match) {\n            urlObj.scheme = match[1];\n            urlSub = urlSub.substr(match[0].length);\n        }\n        match = urlSub.match(/^(.*?)(?=(\\?|#|\\/|$))/i);\n        if (match) {\n            urlObj.host = match[1];\n            urlSub = urlSub.substr(match[0].length);\n        }\n        match = urlSub.match(/^\\/(.*?)(?=(\\?|#|$))/i);\n        if (match) {\n            urlObj.path = match[1];\n            urlSub = urlSub.substr(match[0].length);\n        }\n        match = urlSub.match(/^\\?(.*?)(?=(#|$))/i);\n        if (match) {\n            urlObj.query = match[1];\n            urlSub = urlSub.substr(match[0].length);\n        }\n        match = urlSub.match(/^#(.*?)$/i);\n        if (match) {\n            urlObj.fragment = match[1];\n            //urlSub = urlSub.substr(match[0].length);  -- not used. Uncomment if adding another block.\n        }\n        return urlObj;\n    };\n    var buildUrl = function (urlObj) {\n        var url = \"\";\n        if (urlObj.scheme && urlObj.host) {\n            url += urlObj.scheme + \"://\";\n        }\n        if (urlObj.host) {\n            url += urlObj.host;\n        }\n        if (urlObj.path) {\n            url += \"/\" + urlObj.path;\n        }\n        if (urlObj.query) {\n            url += \"?\" + urlObj.query;\n        }\n        if (urlObj.fragment) {\n            url += \"#\" + urlObj.fragment;\n        }\n        return url;\n    };\n    var buildSegment = function (segment, remainingAvailableLength) {\n        var remainingAvailableLengthHalf = remainingAvailableLength / 2, startOffset = Math.ceil(remainingAvailableLengthHalf), endOffset = (-1) * Math.floor(remainingAvailableLengthHalf), end = \"\";\n        if (endOffset < 0) {\n            end = segment.substr(endOffset);\n        }\n        return segment.substr(0, startOffset) + ellipsisChars + end;\n    };\n    if (url.length <= truncateLen) {\n        return url;\n    }\n    var availableLength = truncateLen - ellipsisLength;\n    var urlObj = parse_url(url);\n    // Clean up the URL\n    if (urlObj.query) {\n        var matchQuery = urlObj.query.match(/^(.*?)(?=(\\?|\\#))(.*?)$/i);\n        if (matchQuery) {\n            // Malformed URL; two or more \"?\". Removed any content behind the 2nd.\n            urlObj.query = urlObj.query.substr(0, matchQuery[1].length);\n            url = buildUrl(urlObj);\n        }\n    }\n    if (url.length <= truncateLen) {\n        return url;\n    }\n    if (urlObj.host) {\n        urlObj.host = urlObj.host.replace(/^www\\./, \"\");\n        url = buildUrl(urlObj);\n    }\n    if (url.length <= truncateLen) {\n        return url;\n    }\n    // Process and build the URL\n    var str = \"\";\n    if (urlObj.host) {\n        str += urlObj.host;\n    }\n    if (str.length >= availableLength) {\n        if (urlObj.host.length == truncateLen) {\n            return (urlObj.host.substr(0, (truncateLen - ellipsisLength)) + ellipsisChars).substr(0, availableLength + ellipsisLengthBeforeParsing);\n        }\n        return buildSegment(str, availableLength).substr(0, availableLength + ellipsisLengthBeforeParsing);\n    }\n    var pathAndQuery = \"\";\n    if (urlObj.path) {\n        pathAndQuery += \"/\" + urlObj.path;\n    }\n    if (urlObj.query) {\n        pathAndQuery += \"?\" + urlObj.query;\n    }\n    if (pathAndQuery) {\n        if ((str + pathAndQuery).length >= availableLength) {\n            if ((str + pathAndQuery).length == truncateLen) {\n                return (str + pathAndQuery).substr(0, truncateLen);\n            }\n            var remainingAvailableLength = availableLength - str.length;\n            return (str + buildSegment(pathAndQuery, remainingAvailableLength)).substr(0, availableLength + ellipsisLengthBeforeParsing);\n        }\n        else {\n            str += pathAndQuery;\n        }\n    }\n    if (urlObj.fragment) {\n        var fragment = \"#\" + urlObj.fragment;\n        if ((str + fragment).length >= availableLength) {\n            if ((str + fragment).length == truncateLen) {\n                return (str + fragment).substr(0, truncateLen);\n            }\n            var remainingAvailableLength2 = availableLength - str.length;\n            return (str + buildSegment(fragment, remainingAvailableLength2)).substr(0, availableLength + ellipsisLengthBeforeParsing);\n        }\n        else {\n            str += fragment;\n        }\n    }\n    if (urlObj.scheme && urlObj.host) {\n        var scheme = urlObj.scheme + \"://\";\n        if ((str + scheme).length < availableLength) {\n            return (scheme + str).substr(0, truncateLen);\n        }\n    }\n    if (str.length <= truncateLen) {\n        return str;\n    }\n    var end = \"\";\n    if (availableLength > 0) {\n        end = str.substr((-1) * Math.floor(availableLength / 2));\n    }\n    return (str.substr(0, Math.ceil(availableLength / 2)) + ellipsisChars + end).substr(0, availableLength + ellipsisLengthBeforeParsing);\n}\n\n//# sourceMappingURL=truncate-smart.js.map\n","/**\n * Date: 2015-10-05\n * Author: Kasper Sfren <soefritz@gmail.com> (https://github.com/kafoso)\n *\n * A truncation feature, where the ellipsis will be placed in the dead-center of the URL.\n *\n * @param {String} url             A URL.\n * @param {Number} truncateLen     The maximum length of the truncated output URL string.\n * @param {String} ellipsisChars   The characters to place within the url, e.g. \"..\".\n * @return {String} The truncated URL.\n */\nexport function truncateMiddle(url, truncateLen, ellipsisChars) {\n    if (url.length <= truncateLen) {\n        return url;\n    }\n    var ellipsisLengthBeforeParsing;\n    var ellipsisLength;\n    if (ellipsisChars == null) {\n        ellipsisChars = '&hellip;';\n        ellipsisLengthBeforeParsing = 8;\n        ellipsisLength = 3;\n    }\n    else {\n        ellipsisLengthBeforeParsing = ellipsisChars.length;\n        ellipsisLength = ellipsisChars.length;\n    }\n    var availableLength = truncateLen - ellipsisLength;\n    var end = \"\";\n    if (availableLength > 0) {\n        end = url.substr((-1) * Math.floor(availableLength / 2));\n    }\n    return (url.substr(0, Math.ceil(availableLength / 2)) + ellipsisChars + end).substr(0, availableLength + ellipsisLengthBeforeParsing);\n}\n\n//# sourceMappingURL=truncate-middle.js.map\n","import { ellipsis } from \"../utils\";\n/**\n * A truncation feature where the ellipsis will be placed at the end of the URL.\n *\n * @param {String} anchorText\n * @param {Number} truncateLen The maximum length of the truncated output URL string.\n * @param {String} ellipsisChars The characters to place within the url, e.g. \"..\".\n * @return {String} The truncated URL.\n */\nexport function truncateEnd(anchorText, truncateLen, ellipsisChars) {\n    return ellipsis(anchorText, truncateLen, ellipsisChars);\n}\n\n//# sourceMappingURL=truncate-end.js.map\n","/**\n * @class Autolinker.HtmlTag\n * @extends Object\n *\n * Represents an HTML tag, which can be used to easily build/modify HTML tags programmatically.\n *\n * Autolinker uses this abstraction to create HTML tags, and then write them out as strings. You may also use\n * this class in your code, especially within a {@link Autolinker#replaceFn replaceFn}.\n *\n * ## Examples\n *\n * Example instantiation:\n *\n *     var tag = new Autolinker.HtmlTag( {\n *         tagName : 'a',\n *         attrs   : { 'href': 'http://google.com', 'class': 'external-link' },\n *         innerHtml : 'Google'\n *     } );\n *\n *     tag.toAnchorString();  // <a href=\"http://google.com\" class=\"external-link\">Google</a>\n *\n *     // Individual accessor methods\n *     tag.getTagName();                 // 'a'\n *     tag.getAttr( 'href' );            // 'http://google.com'\n *     tag.hasClass( 'external-link' );  // true\n *\n *\n * Using mutator methods (which may be used in combination with instantiation config properties):\n *\n *     var tag = new Autolinker.HtmlTag();\n *     tag.setTagName( 'a' );\n *     tag.setAttr( 'href', 'http://google.com' );\n *     tag.addClass( 'external-link' );\n *     tag.setInnerHtml( 'Google' );\n *\n *     tag.getTagName();                 // 'a'\n *     tag.getAttr( 'href' );            // 'http://google.com'\n *     tag.hasClass( 'external-link' );  // true\n *\n *     tag.toAnchorString();  // <a href=\"http://google.com\" class=\"external-link\">Google</a>\n *\n *\n * ## Example use within a {@link Autolinker#replaceFn replaceFn}\n *\n *     var html = Autolinker.link( \"Test google.com\", {\n *         replaceFn : function( match ) {\n *             var tag = match.buildTag();  // returns an {@link Autolinker.HtmlTag} instance, configured with the Match's href and anchor text\n *             tag.setAttr( 'rel', 'nofollow' );\n *\n *             return tag;\n *         }\n *     } );\n *\n *     // generated html:\n *     //   Test <a href=\"http://google.com\" target=\"_blank\" rel=\"nofollow\">google.com</a>\n *\n *\n * ## Example use with a new tag for the replacement\n *\n *     var html = Autolinker.link( \"Test google.com\", {\n *         replaceFn : function( match ) {\n *             var tag = new Autolinker.HtmlTag( {\n *                 tagName : 'button',\n *                 attrs   : { 'title': 'Load URL: ' + match.getAnchorHref() },\n *                 innerHtml : 'Load URL: ' + match.getAnchorText()\n *             } );\n *\n *             return tag;\n *         }\n *     } );\n *\n *     // generated html:\n *     //   Test <button title=\"Load URL: http://google.com\">Load URL: google.com</button>\n */\nimport { indexOf } from \"./utils\";\nvar HtmlTag = /** @class */ (function () {\n    /**\n     * @constructor\n     * @param {Object} [cfg] The configuration properties for this class, in an Object (map)\n     */\n    function HtmlTag(cfg) {\n        if (cfg === void 0) { cfg = {}; }\n        /**\n         * @protected\n         * @property {RegExp} whitespaceRegex\n         *\n         * Regular expression used to match whitespace in a string of CSS classes.\n         */\n        this.whitespaceRegex = /\\s+/;\n        this.tagName = cfg.tagName || '';\n        this.attrs = cfg.attrs || {};\n        this.innerHTML = cfg.innerHtml || cfg.innerHTML || ''; // accept either the camelCased form or the fully capitalized acronym as in the DOM\n    }\n    /**\n     * Sets the tag name that will be used to generate the tag with.\n     *\n     * @param {String} tagName\n     * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n     */\n    HtmlTag.prototype.setTagName = function (tagName) {\n        this.tagName = tagName;\n        return this;\n    };\n    /**\n     * Retrieves the tag name.\n     *\n     * @return {String}\n     */\n    HtmlTag.prototype.getTagName = function () {\n        return this.tagName || '';\n    };\n    /**\n     * Sets an attribute on the HtmlTag.\n     *\n     * @param {String} attrName The attribute name to set.\n     * @param {String} attrValue The attribute value to set.\n     * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n     */\n    HtmlTag.prototype.setAttr = function (attrName, attrValue) {\n        var tagAttrs = this.getAttrs();\n        tagAttrs[attrName] = attrValue;\n        return this;\n    };\n    /**\n     * Retrieves an attribute from the HtmlTag. If the attribute does not exist, returns `undefined`.\n     *\n     * @param {String} attrName The attribute name to retrieve.\n     * @return {String} The attribute's value, or `undefined` if it does not exist on the HtmlTag.\n     */\n    HtmlTag.prototype.getAttr = function (attrName) {\n        return this.getAttrs()[attrName];\n    };\n    /**\n     * Sets one or more attributes on the HtmlTag.\n     *\n     * @param {Object.<String, String>} attrs A key/value Object (map) of the attributes to set.\n     * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n     */\n    HtmlTag.prototype.setAttrs = function (attrs) {\n        Object.assign(this.getAttrs(), attrs);\n        return this;\n    };\n    /**\n     * Retrieves the attributes Object (map) for the HtmlTag.\n     *\n     * @return {Object.<String, String>} A key/value object of the attributes for the HtmlTag.\n     */\n    HtmlTag.prototype.getAttrs = function () {\n        return this.attrs || (this.attrs = {});\n    };\n    /**\n     * Sets the provided `cssClass`, overwriting any current CSS classes on the HtmlTag.\n     *\n     * @param {String} cssClass One or more space-separated CSS classes to set (overwrite).\n     * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n     */\n    HtmlTag.prototype.setClass = function (cssClass) {\n        return this.setAttr('class', cssClass);\n    };\n    /**\n     * Convenience method to add one or more CSS classes to the HtmlTag. Will not add duplicate CSS classes.\n     *\n     * @param {String} cssClass One or more space-separated CSS classes to add.\n     * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n     */\n    HtmlTag.prototype.addClass = function (cssClass) {\n        var classAttr = this.getClass(), whitespaceRegex = this.whitespaceRegex, classes = (!classAttr) ? [] : classAttr.split(whitespaceRegex), newClasses = cssClass.split(whitespaceRegex), newClass;\n        while (newClass = newClasses.shift()) {\n            if (indexOf(classes, newClass) === -1) {\n                classes.push(newClass);\n            }\n        }\n        this.getAttrs()['class'] = classes.join(\" \");\n        return this;\n    };\n    /**\n     * Convenience method to remove one or more CSS classes from the HtmlTag.\n     *\n     * @param {String} cssClass One or more space-separated CSS classes to remove.\n     * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n     */\n    HtmlTag.prototype.removeClass = function (cssClass) {\n        var classAttr = this.getClass(), whitespaceRegex = this.whitespaceRegex, classes = (!classAttr) ? [] : classAttr.split(whitespaceRegex), removeClasses = cssClass.split(whitespaceRegex), removeClass;\n        while (classes.length && (removeClass = removeClasses.shift())) {\n            var idx = indexOf(classes, removeClass);\n            if (idx !== -1) {\n                classes.splice(idx, 1);\n            }\n        }\n        this.getAttrs()['class'] = classes.join(\" \");\n        return this;\n    };\n    /**\n     * Convenience method to retrieve the CSS class(es) for the HtmlTag, which will each be separated by spaces when\n     * there are multiple.\n     *\n     * @return {String}\n     */\n    HtmlTag.prototype.getClass = function () {\n        return this.getAttrs()['class'] || \"\";\n    };\n    /**\n     * Convenience method to check if the tag has a CSS class or not.\n     *\n     * @param {String} cssClass The CSS class to check for.\n     * @return {Boolean} `true` if the HtmlTag has the CSS class, `false` otherwise.\n     */\n    HtmlTag.prototype.hasClass = function (cssClass) {\n        return (' ' + this.getClass() + ' ').indexOf(' ' + cssClass + ' ') !== -1;\n    };\n    /**\n     * Sets the inner HTML for the tag.\n     *\n     * @param {String} html The inner HTML to set.\n     * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n     */\n    HtmlTag.prototype.setInnerHTML = function (html) {\n        this.innerHTML = html;\n        return this;\n    };\n    /**\n     * Backwards compatibility method name.\n     *\n     * @param {String} html The inner HTML to set.\n     * @return {Autolinker.HtmlTag} This HtmlTag instance, so that method calls may be chained.\n     */\n    HtmlTag.prototype.setInnerHtml = function (html) {\n        return this.setInnerHTML(html);\n    };\n    /**\n     * Retrieves the inner HTML for the tag.\n     *\n     * @return {String}\n     */\n    HtmlTag.prototype.getInnerHTML = function () {\n        return this.innerHTML || \"\";\n    };\n    /**\n     * Backward compatibility method name.\n     *\n     * @return {String}\n     */\n    HtmlTag.prototype.getInnerHtml = function () {\n        return this.getInnerHTML();\n    };\n    /**\n     * Override of superclass method used to generate the HTML string for the tag.\n     *\n     * @return {String}\n     */\n    HtmlTag.prototype.toAnchorString = function () {\n        var tagName = this.getTagName(), attrsStr = this.buildAttrsStr();\n        attrsStr = (attrsStr) ? ' ' + attrsStr : ''; // prepend a space if there are actually attributes\n        return ['<', tagName, attrsStr, '>', this.getInnerHtml(), '</', tagName, '>'].join(\"\");\n    };\n    /**\n     * Support method for {@link #toAnchorString}, returns the string space-separated key=\"value\" pairs, used to populate\n     * the stringified HtmlTag.\n     *\n     * @protected\n     * @return {String} Example return: `attr1=\"value1\" attr2=\"value2\"`\n     */\n    HtmlTag.prototype.buildAttrsStr = function () {\n        if (!this.attrs)\n            return \"\"; // no `attrs` Object (map) has been set, return empty string\n        var attrs = this.getAttrs(), attrsArr = [];\n        for (var prop in attrs) {\n            if (attrs.hasOwnProperty(prop)) {\n                attrsArr.push(prop + '=\"' + attrs[prop] + '\"');\n            }\n        }\n        return attrsArr.join(\" \");\n    };\n    return HtmlTag;\n}());\nexport { HtmlTag };\n\n//# sourceMappingURL=html-tag.js.map\n","import { HtmlTag } from \"./html-tag\";\nimport { truncateSmart } from \"./truncate/truncate-smart\";\nimport { truncateMiddle } from \"./truncate/truncate-middle\";\nimport { truncateEnd } from \"./truncate/truncate-end\";\n/**\n * @protected\n * @class Autolinker.AnchorTagBuilder\n * @extends Object\n *\n * Builds anchor (&lt;a&gt;) tags for the Autolinker utility when a match is\n * found.\n *\n * Normally this class is instantiated, configured, and used internally by an\n * {@link Autolinker} instance, but may actually be used indirectly in a\n * {@link Autolinker#replaceFn replaceFn} to create {@link Autolinker.HtmlTag HtmlTag}\n * instances which may be modified before returning from the\n * {@link Autolinker#replaceFn replaceFn}. For example:\n *\n *     var html = Autolinker.link( \"Test google.com\", {\n *         replaceFn : function( match ) {\n *             var tag = match.buildTag();  // returns an {@link Autolinker.HtmlTag} instance\n *             tag.setAttr( 'rel', 'nofollow' );\n *\n *             return tag;\n *         }\n *     } );\n *\n *     // generated html:\n *     //   Test <a href=\"http://google.com\" target=\"_blank\" rel=\"nofollow\">google.com</a>\n */\nvar AnchorTagBuilder = /** @class */ (function () {\n    /**\n     * @constructor\n     * @param {Object} [cfg] The configuration options for the AnchorTagBuilder instance, specified in an Object (map).\n     */\n    function AnchorTagBuilder(cfg) {\n        if (cfg === void 0) { cfg = {}; }\n        this.newWindow = cfg.newWindow || false;\n        this.truncate = cfg.truncate || {};\n        this.className = cfg.className || '';\n    }\n    /**\n     * Generates the actual anchor (&lt;a&gt;) tag to use in place of the\n     * matched text, via its `match` object.\n     *\n     * @param {Autolinker.match.Match} match The Match instance to generate an\n     *   anchor tag from.\n     * @return {Autolinker.HtmlTag} The HtmlTag instance for the anchor tag.\n     */\n    AnchorTagBuilder.prototype.build = function (match) {\n        return new HtmlTag({\n            tagName: 'a',\n            attrs: this.createAttrs(match),\n            innerHtml: this.processAnchorText(match.getAnchorText())\n        });\n    };\n    /**\n     * Creates the Object (map) of the HTML attributes for the anchor (&lt;a&gt;)\n     *   tag being generated.\n     *\n     * @protected\n     * @param {Autolinker.match.Match} match The Match instance to generate an\n     *   anchor tag from.\n     * @return {Object} A key/value Object (map) of the anchor tag's attributes.\n     */\n    AnchorTagBuilder.prototype.createAttrs = function (match) {\n        var attrs = {\n            'href': match.getAnchorHref() // we'll always have the `href` attribute\n        };\n        var cssClass = this.createCssClass(match);\n        if (cssClass) {\n            attrs['class'] = cssClass;\n        }\n        if (this.newWindow) {\n            attrs['target'] = \"_blank\";\n            attrs['rel'] = \"noopener noreferrer\";\n        }\n        if (this.truncate) {\n            if (this.truncate.length && this.truncate.length < match.getAnchorText().length) {\n                attrs['title'] = match.getAnchorHref();\n            }\n        }\n        return attrs;\n    };\n    /**\n     * Creates the CSS class that will be used for a given anchor tag, based on\n     * the `matchType` and the {@link #className} config.\n     *\n     * Example returns:\n     *\n     * - \"\"                                      // no {@link #className}\n     * - \"myLink myLink-url\"                     // url match\n     * - \"myLink myLink-email\"                   // email match\n     * - \"myLink myLink-phone\"                   // phone match\n     * - \"myLink myLink-hashtag\"                 // hashtag match\n     * - \"myLink myLink-mention myLink-twitter\"  // mention match with Twitter service\n     *\n     * @private\n     * @param {Autolinker.match.Match} match The Match instance to generate an\n     *   anchor tag from.\n     * @return {String} The CSS class string for the link. Example return:\n     *   \"myLink myLink-url\". If no {@link #className} was configured, returns\n     *   an empty string.\n     */\n    AnchorTagBuilder.prototype.createCssClass = function (match) {\n        var className = this.className;\n        if (!className) {\n            return \"\";\n        }\n        else {\n            var returnClasses = [className], cssClassSuffixes = match.getCssClassSuffixes();\n            for (var i = 0, len = cssClassSuffixes.length; i < len; i++) {\n                returnClasses.push(className + '-' + cssClassSuffixes[i]);\n            }\n            return returnClasses.join(' ');\n        }\n    };\n    /**\n     * Processes the `anchorText` by truncating the text according to the\n     * {@link #truncate} config.\n     *\n     * @private\n     * @param {String} anchorText The anchor tag's text (i.e. what will be\n     *   displayed).\n     * @return {String} The processed `anchorText`.\n     */\n    AnchorTagBuilder.prototype.processAnchorText = function (anchorText) {\n        anchorText = this.doTruncate(anchorText);\n        return anchorText;\n    };\n    /**\n     * Performs the truncation of the `anchorText` based on the {@link #truncate}\n     * option. If the `anchorText` is longer than the length specified by the\n     * {@link #truncate} option, the truncation is performed based on the\n     * `location` property. See {@link #truncate} for details.\n     *\n     * @private\n     * @param {String} anchorText The anchor tag's text (i.e. what will be\n     *   displayed).\n     * @return {String} The truncated anchor text.\n     */\n    AnchorTagBuilder.prototype.doTruncate = function (anchorText) {\n        var truncate = this.truncate;\n        if (!truncate || !truncate.length)\n            return anchorText;\n        var truncateLength = truncate.length, truncateLocation = truncate.location;\n        if (truncateLocation === 'smart') {\n            return truncateSmart(anchorText, truncateLength);\n        }\n        else if (truncateLocation === 'middle') {\n            return truncateMiddle(anchorText, truncateLength);\n        }\n        else {\n            return truncateEnd(anchorText, truncateLength);\n        }\n    };\n    return AnchorTagBuilder;\n}());\nexport { AnchorTagBuilder };\n\n//# sourceMappingURL=anchor-tag-builder.js.map\n","/**\n * @abstract\n * @class Autolinker.htmlParser.HtmlNode\n *\n * Represents an HTML node found in an input string. An HTML node is one of the\n * following:\n *\n * 1. An {@link Autolinker.htmlParser.ElementNode ElementNode}, which represents\n *    HTML tags.\n * 2. A {@link Autolinker.htmlParser.CommentNode CommentNode}, which represents\n *    HTML comments.\n * 3. A {@link Autolinker.htmlParser.TextNode TextNode}, which represents text\n *    outside or within HTML tags.\n * 4. A {@link Autolinker.htmlParser.EntityNode EntityNode}, which represents\n *    one of the known HTML entities that Autolinker looks for. This includes\n *    common ones such as &amp;quot; and &amp;nbsp;\n */\nvar HtmlNode = /** @class */ (function () {\n    /**\n     * @constructor\n     * @param {Object} cfg The configuration properties for the Match instance,\n     * specified in an Object (map).\n     */\n    function HtmlNode(cfg) {\n        this.offset = cfg.offset;\n        this.text = cfg.text;\n    }\n    /**\n     * Retrieves the {@link #offset} of the HtmlNode. This is the offset of the\n     * HTML node in the original string that was parsed.\n     *\n     * @return {Number}\n     */\n    HtmlNode.prototype.getOffset = function () {\n        return this.offset;\n    };\n    /**\n     * Retrieves the {@link #text} for the HtmlNode.\n     *\n     * @return {String}\n     */\n    HtmlNode.prototype.getText = function () {\n        return this.text;\n    };\n    return HtmlNode;\n}());\nexport { HtmlNode };\n\n//# sourceMappingURL=html-node.js.map\n","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { HtmlNode } from \"./html-node\";\n/**\n * @class Autolinker.htmlParser.CommentNode\n * @extends Autolinker.htmlParser.HtmlNode\n *\n * Represents an HTML comment node that has been parsed by the\n * {@link Autolinker.htmlParser.HtmlParser}.\n *\n * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more\n * details.\n */\nvar CommentNode = /** @class */ (function (_super) {\n    __extends(CommentNode, _super);\n    function CommentNode(cfg) {\n        var _this = _super.call(this, cfg) || this;\n        _this.comment = cfg.comment;\n        return _this;\n    }\n    /**\n     * Returns a string name for the type of node that this class represents.\n     *\n     * @return {String}\n     */\n    CommentNode.prototype.getType = function () {\n        return 'comment';\n    };\n    /**\n     * Returns the comment inside the comment tag.\n     *\n     * @return {String}\n     */\n    CommentNode.prototype.getComment = function () {\n        return this.comment;\n    };\n    return CommentNode;\n}(HtmlNode));\nexport { CommentNode };\n\n//# sourceMappingURL=comment-node.js.map\n","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @class Autolinker.htmlParser.ElementNode\n * @extends Autolinker.htmlParser.HtmlNode\n *\n * Represents an HTML element node that has been parsed by the {@link Autolinker.htmlParser.HtmlParser}.\n *\n * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more\n * details.\n */\nimport { HtmlNode } from \"./html-node\";\nvar ElementNode = /** @class */ (function (_super) {\n    __extends(ElementNode, _super);\n    function ElementNode(cfg) {\n        var _this = _super.call(this, cfg) || this;\n        _this.tagName = cfg.tagName;\n        _this.closing = cfg.closing;\n        return _this;\n    }\n    /**\n     * Returns a string name for the type of node that this class represents.\n     *\n     * @return {String}\n     */\n    ElementNode.prototype.getType = function () {\n        return 'element';\n    };\n    /**\n     * Returns the HTML element's (tag's) name. Ex: for an &lt;img&gt; tag,\n     * returns \"img\".\n     *\n     * @return {String}\n     */\n    ElementNode.prototype.getTagName = function () {\n        return this.tagName;\n    };\n    /**\n     * Determines if the HTML element (tag) is a closing tag. Ex: &lt;div&gt;\n     * returns `false`, while &lt;/div&gt; returns `true`.\n     *\n     * @return {Boolean}\n     */\n    ElementNode.prototype.isClosing = function () {\n        return this.closing;\n    };\n    return ElementNode;\n}(HtmlNode));\nexport { ElementNode };\n\n//# sourceMappingURL=element-node.js.map\n","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @class Autolinker.htmlParser.EntityNode\n * @extends Autolinker.htmlParser.HtmlNode\n *\n * Represents a known HTML entity node that has been parsed by the {@link Autolinker.htmlParser.HtmlParser}.\n * Ex: '&amp;nbsp;', or '&amp#160;' (which will be retrievable from the {@link #getText}\n * method.\n *\n * Note that this class will only be returned from the HtmlParser for the set of\n * checked HTML entity nodes  defined by the {@link Autolinker.htmlParser.HtmlParser#htmlCharacterEntitiesRegex}.\n *\n * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more\n * details.\n */\nimport { HtmlNode } from \"./html-node\";\nvar EntityNode = /** @class */ (function (_super) {\n    __extends(EntityNode, _super);\n    function EntityNode() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Returns a string name for the type of node that this class represents.\n     *\n     * @return {String}\n     */\n    EntityNode.prototype.getType = function () {\n        return 'entity';\n    };\n    return EntityNode;\n}(HtmlNode));\nexport { EntityNode };\n\n//# sourceMappingURL=entity-node.js.map\n","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { HtmlNode } from \"./html-node\";\n/**\n * @class Autolinker.htmlParser.TextNode\n * @extends Autolinker.htmlParser.HtmlNode\n *\n * Represents a text node that has been parsed by the {@link Autolinker.htmlParser.HtmlParser}.\n *\n * See this class's superclass ({@link Autolinker.htmlParser.HtmlNode}) for more\n * details.\n */\nvar TextNode = /** @class */ (function (_super) {\n    __extends(TextNode, _super);\n    function TextNode() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Returns a string name for the type of node that this class represents.\n     *\n     * @return {String}\n     */\n    TextNode.prototype.getType = function () {\n        return 'text';\n    };\n    return TextNode;\n}(HtmlNode));\nexport { TextNode };\n\n//# sourceMappingURL=text-node.js.map\n","/**\n * @private\n * @property {RegExp} htmlRegex\n *\n * The regular expression used to pull out HTML tags from a string. Handles namespaced HTML tags and\n * attribute names, as specified by http://www.w3.org/TR/html-markup/syntax.html.\n *\n * Capturing groups:\n *\n * 1. The \"!DOCTYPE\" tag name, if a tag is a &lt;!DOCTYPE&gt; tag.\n * 2. If it is an end tag, this group will have the '/'.\n * 3. If it is a comment tag, this group will hold the comment text (i.e.\n *    the text inside the `&lt;!--` and `--&gt;`.\n * 4. The tag name for a tag without attributes (other than the &lt;!DOCTYPE&gt; tag)\n * 5. The tag name for a tag with attributes (other than the &lt;!DOCTYPE&gt; tag)\n */\nimport { splitAndCapture } from \"../utils\";\nimport { CommentNode } from \"./comment-node\";\nimport { ElementNode } from \"./element-node\";\nimport { EntityNode } from \"./entity-node\";\nimport { TextNode } from \"./text-node\";\nvar htmlRegex = (function () {\n    var commentTagRegex = /!--([\\s\\S]+?)--/, tagNameRegex = /[0-9a-zA-Z][0-9a-zA-Z:]*/, attrNameRegex = /[^\\s\"'>\\/=\\x00-\\x1F\\x7F]+/, // the unicode range accounts for excluding control chars, and the delete char\n    attrValueRegex = /(?:\"[^\"]*?\"|'[^']*?'|[^'\"=<>`\\s]+)/, // double quoted, single quoted, or unquoted attribute values\n    optionalAttrValueRegex = '(?:\\\\s*?=\\\\s*?' + attrValueRegex.source + ')?'; // optional '=[value]'\n    var getNameEqualsValueRegex = function (group) {\n        return '(?=(' + attrNameRegex.source + '))\\\\' + group + optionalAttrValueRegex;\n    };\n    return new RegExp([\n        // for <!DOCTYPE> tag. Ex: <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">)\n        '(?:',\n        '<(!DOCTYPE)',\n        // Zero or more attributes following the tag name\n        '(?:',\n        '\\\\s+',\n        // Either:\n        // A. attr=\"value\", or\n        // B. \"value\" alone (To cover example doctype tag: <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">)\n        // *** Capturing Group 2 - Pseudo-atomic group for attrNameRegex\n        '(?:', getNameEqualsValueRegex(2), '|', attrValueRegex.source + ')',\n        ')*',\n        '>',\n        ')',\n        '|',\n        // All other HTML tags (i.e. tags that are not <!DOCTYPE>)\n        '(?:',\n        '<(/)?',\n        // *** Capturing Group 3: The slash or an empty string. Slash ('/') for end tag, empty string for start or self-closing tag.\n        '(?:',\n        commentTagRegex.source,\n        '|',\n        // Handle tag without attributes.\n        // Doing this separately from a tag that has attributes\n        // to fix a regex time complexity issue seen with the\n        // example in https://github.com/gregjacobs/Autolinker.js/issues/172\n        '(?:',\n        // *** Capturing Group 5 - The tag name for a tag without attributes\n        '(' + tagNameRegex.source + ')',\n        '\\\\s*/?',\n        ')',\n        '|',\n        // Handle tag with attributes\n        // Doing this separately from a tag with no attributes\n        // to fix a regex time complexity issue seen with the\n        // example in https://github.com/gregjacobs/Autolinker.js/issues/172\n        '(?:',\n        // *** Capturing Group 6 - The tag name for a tag with attributes\n        '(' + tagNameRegex.source + ')',\n        '\\\\s+',\n        // Zero or more attributes following the tag name\n        '(?:',\n        '(?:\\\\s+|\\\\b)',\n        // *** Capturing Group 7 - Pseudo-atomic group for attrNameRegex\n        getNameEqualsValueRegex(7),\n        ')*',\n        '\\\\s*/?',\n        ')',\n        ')',\n        '>',\n        ')'\n    ].join(\"\"), 'gi');\n})();\n/**\n * @private\n * @property {RegExp} htmlCharacterEntitiesRegex\n *\n * The regular expression that matches common HTML character entities.\n *\n * Ignoring &amp; as it could be part of a query string -- handling it separately.\n */\nvar htmlCharacterEntitiesRegex = /(&nbsp;|&#160;|&lt;|&#60;|&gt;|&#62;|&quot;|&#34;|&#39;)/gi;\n/**\n * @class Autolinker.htmlParser.HtmlParser\n * @extends Object\n *\n * An HTML parser implementation which simply walks an HTML string and returns an array of\n * {@link Autolinker.htmlParser.HtmlNode HtmlNodes} that represent the basic HTML structure of the input string.\n *\n * Autolinker uses this to only link URLs/emails/mentions within text nodes, effectively ignoring / \"walking\n * around\" HTML tags.\n */\nvar HtmlParser = /** @class */ (function () {\n    function HtmlParser() {\n    }\n    /**\n     * Parses an HTML string and returns a simple array of {@link Autolinker.htmlParser.HtmlNode HtmlNodes}\n     * to represent the HTML structure of the input string.\n     *\n     * @param {String} html The HTML to parse.\n     * @return {Autolinker.htmlParser.HtmlNode[]}\n     */\n    HtmlParser.prototype.parse = function (html) {\n        var currentResult, lastIndex = 0, textAndEntityNodes, nodes = []; // will be the result of the method\n        while ((currentResult = htmlRegex.exec(html)) !== null) {\n            var tagText = currentResult[0], commentText = currentResult[4], // if we've matched a comment\n            tagName = currentResult[1] || currentResult[5] || currentResult[6], // The <!DOCTYPE> tag (ex: \"!DOCTYPE\"), or another tag (ex: \"a\" or \"img\")\n            isClosingTag = !!currentResult[3], offset = currentResult.index, inBetweenTagsText = html.substring(lastIndex, offset);\n            // Push TextNodes and EntityNodes for any text found between tags\n            if (inBetweenTagsText) {\n                textAndEntityNodes = this.parseTextAndEntityNodes(lastIndex, inBetweenTagsText);\n                nodes.push.apply(nodes, textAndEntityNodes);\n            }\n            // Push the CommentNode or ElementNode\n            if (commentText) {\n                nodes.push(this.createCommentNode(offset, tagText, commentText));\n            }\n            else {\n                nodes.push(this.createElementNode(offset, tagText, tagName, isClosingTag));\n            }\n            lastIndex = offset + tagText.length;\n        }\n        // Process any remaining text after the last HTML element. Will process all of the text if there were no HTML elements.\n        if (lastIndex < html.length) {\n            var text = html.substring(lastIndex);\n            // Push TextNodes and EntityNodes for any text found between tags\n            if (text) {\n                textAndEntityNodes = this.parseTextAndEntityNodes(lastIndex, text);\n                // Note: the following 3 lines were previously:\n                //   nodes.push.apply( nodes, textAndEntityNodes );\n                // but this was causing a \"Maximum Call Stack Size Exceeded\"\n                // error on inputs with a large number of html entities.\n                textAndEntityNodes.forEach(function (node) { return nodes.push(node); });\n            }\n        }\n        return nodes;\n    };\n    /**\n     * Parses text and HTML entity nodes from a given string. The input string\n     * should not have any HTML tags (elements) within it.\n     *\n     * @private\n     * @param {Number} offset The offset of the text node match within the\n     *   original HTML string.\n     * @param {String} text The string of text to parse. This is from an HTML\n     *   text node.\n     * @return {Autolinker.htmlParser.HtmlNode[]} An array of HtmlNodes to\n     *   represent the {@link Autolinker.htmlParser.TextNode TextNodes} and\n     *   {@link Autolinker.htmlParser.EntityNode EntityNodes} found.\n     */\n    HtmlParser.prototype.parseTextAndEntityNodes = function (offset, text) {\n        var nodes = [], textAndEntityTokens = splitAndCapture(text, htmlCharacterEntitiesRegex); // split at HTML entities, but include the HTML entities in the results array\n        // Every even numbered token is a TextNode, and every odd numbered token is an EntityNode\n        // For example: an input `text` of \"Test &quot;this&quot; today\" would turn into the\n        //   `textAndEntityTokens`: [ 'Test ', '&quot;', 'this', '&quot;', ' today' ]\n        for (var i = 0, len = textAndEntityTokens.length; i < len; i += 2) {\n            var textToken = textAndEntityTokens[i], entityToken = textAndEntityTokens[i + 1];\n            if (textToken) {\n                nodes.push(this.createTextNode(offset, textToken));\n                offset += textToken.length;\n            }\n            if (entityToken) {\n                nodes.push(this.createEntityNode(offset, entityToken));\n                offset += entityToken.length;\n            }\n        }\n        return nodes;\n    };\n    /**\n     * Factory method to create an {@link Autolinker.htmlParser.CommentNode CommentNode}.\n     *\n     * @private\n     * @param {Number} offset The offset of the match within the original HTML\n     *   string.\n     * @param {String} tagText The full text of the tag (comment) that was\n     *   matched, including its &lt;!-- and --&gt;.\n     * @param {String} commentText The full text of the comment that was matched.\n     */\n    HtmlParser.prototype.createCommentNode = function (offset, tagText, commentText) {\n        return new CommentNode({\n            offset: offset,\n            text: tagText,\n            comment: commentText.trim()\n        });\n    };\n    /**\n     * Factory method to create an {@link Autolinker.htmlParser.ElementNode ElementNode}.\n     *\n     * @private\n     * @param {Number} offset The offset of the match within the original HTML\n     *   string.\n     * @param {String} tagText The full text of the tag (element) that was\n     *   matched, including its attributes.\n     * @param {String} tagName The name of the tag. Ex: An &lt;img&gt; tag would\n     *   be passed to this method as \"img\".\n     * @param {Boolean} isClosingTag `true` if it's a closing tag, false\n     *   otherwise.\n     * @return {Autolinker.htmlParser.ElementNode}\n     */\n    HtmlParser.prototype.createElementNode = function (offset, tagText, tagName, isClosingTag) {\n        return new ElementNode({\n            offset: offset,\n            text: tagText,\n            tagName: tagName.toLowerCase(),\n            closing: isClosingTag\n        });\n    };\n    /**\n     * Factory method to create a {@link Autolinker.htmlParser.EntityNode EntityNode}.\n     *\n     * @private\n     * @param {Number} offset The offset of the match within the original HTML\n     *   string.\n     * @param {String} text The text that was matched for the HTML entity (such\n     *   as '&amp;nbsp;').\n     * @return {Autolinker.htmlParser.EntityNode}\n     */\n    HtmlParser.prototype.createEntityNode = function (offset, text) {\n        return new EntityNode({ offset: offset, text: text });\n    };\n    /**\n     * Factory method to create a {@link Autolinker.htmlParser.TextNode TextNode}.\n     *\n     * @private\n     * @param {Number} offset The offset of the match within the original HTML\n     *   string.\n     * @param {String} text The text that was matched.\n     * @return {Autolinker.htmlParser.TextNode}\n     */\n    HtmlParser.prototype.createTextNode = function (offset, text) {\n        return new TextNode({ offset: offset, text: text });\n    };\n    return HtmlParser;\n}());\nexport { HtmlParser };\n\n//# sourceMappingURL=html-parser.js.map\n","var Match = /** @class */ (function () {\n    /**\n     * @constructor\n     * @param {Object} cfg The configuration properties for the Match\n     *   instance, specified in an Object (map).\n     */\n    function Match(cfg) {\n        this.tagBuilder = cfg.tagBuilder;\n        this.matchedText = cfg.matchedText;\n        this.offset = cfg.offset;\n    }\n    /**\n     * Returns the original text that was matched.\n     *\n     * @return {String}\n     */\n    Match.prototype.getMatchedText = function () {\n        return this.matchedText;\n    };\n    /**\n     * Sets the {@link #offset} of where the match was made in the input string.\n     *\n     * A {@link Autolinker.matcher.Matcher} will be fed only HTML text nodes,\n     * and will therefore set an original offset that is relative to the HTML\n     * text node itself. However, we want this offset to be relative to the full\n     * HTML input string, and thus if using {@link Autolinker#parse} (rather\n     * than calling a {@link Autolinker.matcher.Matcher} directly), then this\n     * offset is corrected after the Matcher itself has done its job.\n     *\n     * @param {Number} offset\n     */\n    Match.prototype.setOffset = function (offset) {\n        this.offset = offset;\n    };\n    /**\n     * Returns the offset of where the match was made in the input string. This\n     * is the 0-based index of the match.\n     *\n     * @return {Number}\n     */\n    Match.prototype.getOffset = function () {\n        return this.offset;\n    };\n    /**\n     * Returns the CSS class suffix(es) for this match.\n     *\n     * A CSS class suffix is appended to the {@link Autolinker#className} in\n     * the {@link Autolinker.AnchorTagBuilder} when a match is translated into\n     * an anchor tag.\n     *\n     * For example, if {@link Autolinker#className} was configured as 'myLink',\n     * and this method returns `[ 'url' ]`, the final class name of the element\n     * will become: 'myLink myLink-url'.\n     *\n     * The match may provide multiple CSS class suffixes to be appended to the\n     * {@link Autolinker#className} in order to facilitate better styling\n     * options for different match criteria. See {@link Autolinker.match.Mention}\n     * for an example.\n     *\n     * By default, this method returns a single array with the match's\n     * {@link #getType type} name, but may be overridden by subclasses.\n     *\n     * @return {String[]}\n     */\n    Match.prototype.getCssClassSuffixes = function () {\n        return [this.getType()];\n    };\n    /**\n     * Builds and returns an {@link Autolinker.HtmlTag} instance based on the\n     * Match.\n     *\n     * This can be used to easily generate anchor tags from matches, and either\n     * return their HTML string, or modify them before doing so.\n     *\n     * Example Usage:\n     *\n     *     var tag = match.buildTag();\n     *     tag.addClass( 'cordova-link' );\n     *     tag.setAttr( 'target', '_system' );\n     *\n     *     tag.toAnchorString();  // <a href=\"http://google.com\" class=\"cordova-link\" target=\"_system\">Google</a>\n     */\n    Match.prototype.buildTag = function () {\n        return this.tagBuilder.build(this);\n    };\n    return Match;\n}());\nexport { Match };\n\n//# sourceMappingURL=match.js.map\n","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { Match } from \"./match\";\n/**\n * @class Autolinker.match.Email\n * @extends Autolinker.match.Match\n *\n * Represents a Email match found in an input string which should be Autolinked.\n *\n * See this class's superclass ({@link Autolinker.match.Match}) for more details.\n */\nvar EmailMatch = /** @class */ (function (_super) {\n    __extends(EmailMatch, _super);\n    /**\n     * @constructor\n     * @param {Object} cfg The configuration properties for the Match\n     *   instance, specified in an Object (map).\n     */\n    function EmailMatch(cfg) {\n        var _this = _super.call(this, cfg) || this;\n        _this.email = cfg.email;\n        return _this;\n    }\n    /**\n     * Returns a string name for the type of match that this class represents.\n     *\n     * @return {String}\n     */\n    EmailMatch.prototype.getType = function () {\n        return 'email';\n    };\n    /**\n     * Returns the email address that was matched.\n     *\n     * @return {String}\n     */\n    EmailMatch.prototype.getEmail = function () {\n        return this.email;\n    };\n    /**\n     * Returns the anchor href that should be generated for the match.\n     *\n     * @return {String}\n     */\n    EmailMatch.prototype.getAnchorHref = function () {\n        return 'mailto:' + this.email;\n    };\n    /**\n     * Returns the anchor text that should be generated for the match.\n     *\n     * @return {String}\n     */\n    EmailMatch.prototype.getAnchorText = function () {\n        return this.email;\n    };\n    return EmailMatch;\n}(Match));\nexport { EmailMatch };\n\n//# sourceMappingURL=email-match.js.map\n","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { Match } from \"./match\";\n/**\n * @class Autolinker.match.Hashtag\n * @extends Autolinker.match.Match\n *\n * Represents a HashtagMatch match found in an input string which should be\n * Autolinked.\n *\n * See this class's superclass ({@link Autolinker.match.Match}) for more\n * details.\n */\nvar HashtagMatch = /** @class */ (function (_super) {\n    __extends(HashtagMatch, _super);\n    /**\n     * @constructor\n     * @param {Object} cfg The configuration properties for the Match\n     *   instance, specified in an Object (map).\n     */\n    function HashtagMatch(cfg) {\n        var _this = _super.call(this, cfg) || this;\n        _this.serviceName = cfg.serviceName;\n        _this.hashtag = cfg.hashtag;\n        return _this;\n    }\n    /**\n     * Returns the type of match that this class represents.\n     *\n     * @return {String}\n     */\n    HashtagMatch.prototype.getType = function () {\n        return 'hashtag';\n    };\n    /**\n     * Returns the configured {@link #serviceName} to point the HashtagMatch to.\n     * Ex: 'facebook', 'twitter'.\n     *\n     * @return {String}\n     */\n    HashtagMatch.prototype.getServiceName = function () {\n        return this.serviceName;\n    };\n    /**\n     * Returns the matched hashtag, without the '#' character.\n     *\n     * @return {String}\n     */\n    HashtagMatch.prototype.getHashtag = function () {\n        return this.hashtag;\n    };\n    /**\n     * Returns the anchor href that should be generated for the match.\n     *\n     * @return {String}\n     */\n    HashtagMatch.prototype.getAnchorHref = function () {\n        var serviceName = this.serviceName, hashtag = this.hashtag;\n        switch (serviceName) {\n            case 'twitter':\n                return 'https://twitter.com/hashtag/' + hashtag;\n            case 'facebook':\n                return 'https://www.facebook.com/hashtag/' + hashtag;\n            case 'instagram':\n                return 'https://instagram.com/explore/tags/' + hashtag;\n            default: // Shouldn't happen because Autolinker's constructor should block any invalid values, but just in case.\n                throw new Error('Unknown service name to point hashtag to: ' + serviceName);\n        }\n    };\n    /**\n     * Returns the anchor text that should be generated for the match.\n     *\n     * @return {String}\n     */\n    HashtagMatch.prototype.getAnchorText = function () {\n        return '#' + this.hashtag;\n    };\n    return HashtagMatch;\n}(Match));\nexport { HashtagMatch };\n\n//# sourceMappingURL=hashtag-match.js.map\n","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { Match } from \"./match\";\n/**\n * @class Autolinker.match.Mention\n * @extends Autolinker.match.Match\n *\n * Represents a Mention match found in an input string which should be Autolinked.\n *\n * See this class's superclass ({@link Autolinker.match.Match}) for more details.\n */\nvar MentionMatch = /** @class */ (function (_super) {\n    __extends(MentionMatch, _super);\n    /**\n     * @constructor\n     * @param {Object} cfg The configuration properties for the Match\n     *   instance, specified in an Object (map).\n     */\n    function MentionMatch(cfg) {\n        var _this = _super.call(this, cfg) || this;\n        _this.mention = cfg.mention;\n        _this.serviceName = cfg.serviceName;\n        return _this;\n    }\n    /**\n     * Returns the type of match that this class represents.\n     *\n     * @return {String}\n     */\n    MentionMatch.prototype.getType = function () {\n        return 'mention';\n    };\n    /**\n     * Returns the mention, without the '@' character.\n     *\n     * @return {String}\n     */\n    MentionMatch.prototype.getMention = function () {\n        return this.mention;\n    };\n    /**\n     * Returns the configured {@link #serviceName} to point the mention to.\n     * Ex: 'instagram', 'twitter', 'soundcloud'.\n     *\n     * @return {String}\n     */\n    MentionMatch.prototype.getServiceName = function () {\n        return this.serviceName;\n    };\n    /**\n     * Returns the anchor href that should be generated for the match.\n     *\n     * @return {String}\n     */\n    MentionMatch.prototype.getAnchorHref = function () {\n        switch (this.serviceName) {\n            case 'twitter':\n                return 'https://twitter.com/' + this.mention;\n            case 'instagram':\n                return 'https://instagram.com/' + this.mention;\n            case 'soundcloud':\n                return 'https://soundcloud.com/' + this.mention;\n            default: // Shouldn't happen because Autolinker's constructor should block any invalid values, but just in case.\n                throw new Error('Unknown service name to point mention to: ' + this.serviceName);\n        }\n    };\n    /**\n     * Returns the anchor text that should be generated for the match.\n     *\n     * @return {String}\n     */\n    MentionMatch.prototype.getAnchorText = function () {\n        return '@' + this.mention;\n    };\n    /**\n     * Returns the CSS class suffixes that should be used on a tag built with\n     * the match. See {@link Autolinker.match.Match#getCssClassSuffixes} for\n     * details.\n     *\n     * @return {String[]}\n     */\n    MentionMatch.prototype.getCssClassSuffixes = function () {\n        var cssClassSuffixes = _super.prototype.getCssClassSuffixes.call(this), serviceName = this.getServiceName();\n        if (serviceName) {\n            cssClassSuffixes.push(serviceName);\n        }\n        return cssClassSuffixes;\n    };\n    return MentionMatch;\n}(Match));\nexport { MentionMatch };\n\n//# sourceMappingURL=mention-match.js.map\n","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { Match } from \"./match\";\n/**\n * @class Autolinker.match.Phone\n * @extends Autolinker.match.Match\n *\n * Represents a Phone number match found in an input string which should be\n * Autolinked.\n *\n * See this class's superclass ({@link Autolinker.match.Match}) for more\n * details.\n */\nvar PhoneMatch = /** @class */ (function (_super) {\n    __extends(PhoneMatch, _super);\n    /**\n     * @constructor\n     * @param {Object} cfg The configuration properties for the Match\n     *   instance, specified in an Object (map).\n     */\n    function PhoneMatch(cfg) {\n        var _this = _super.call(this, cfg) || this;\n        _this.number = cfg.number;\n        _this.plusSign = cfg.plusSign;\n        return _this;\n    }\n    /**\n     * Returns a string name for the type of match that this class represents.\n     *\n     * @return {String}\n     */\n    PhoneMatch.prototype.getType = function () {\n        return 'phone';\n    };\n    /**\n     * Returns the phone number that was matched as a string, without any\n     * delimiter characters.\n     *\n     * Note: This is a string to allow for prefixed 0's.\n     *\n     * @return {String}\n     */\n    PhoneMatch.prototype.getNumber = function () {\n        return this.number;\n    };\n    /**\n     * Returns the anchor href that should be generated for the match.\n     *\n     * @return {String}\n     */\n    PhoneMatch.prototype.getAnchorHref = function () {\n        return 'tel:' + (this.plusSign ? '+' : '') + this.number;\n    };\n    /**\n     * Returns the anchor text that should be generated for the match.\n     *\n     * @return {String}\n     */\n    PhoneMatch.prototype.getAnchorText = function () {\n        return this.matchedText;\n    };\n    return PhoneMatch;\n}(Match));\nexport { PhoneMatch };\n\n//# sourceMappingURL=phone-match.js.map\n","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { Match } from \"./match\";\n/**\n * @class Autolinker.match.Url\n * @extends Autolinker.match.Match\n *\n * Represents a Url match found in an input string which should be Autolinked.\n *\n * See this class's superclass ({@link Autolinker.match.Match}) for more details.\n */\nvar UrlMatch = /** @class */ (function (_super) {\n    __extends(UrlMatch, _super);\n    /**\n     * @constructor\n     * @param {Object} cfg The configuration properties for the Match\n     *   instance, specified in an Object (map).\n     */\n    function UrlMatch(cfg) {\n        var _this = _super.call(this, cfg) || this;\n        /**\n         * @private\n         * @property {RegExp} schemePrefixRegex\n         *\n         * A regular expression used to remove the 'http://' or 'https://' from\n         * URLs.\n         */\n        _this.schemePrefixRegex = /^(https?:\\/\\/)?/i;\n        /**\n         * @private\n         * @property {RegExp} wwwPrefixRegex\n         *\n         * A regular expression used to remove the 'www.' from URLs.\n         */\n        _this.wwwPrefixRegex = /^(https?:\\/\\/)?(www\\.)?/i;\n        /**\n         * @private\n         * @property {RegExp} protocolRelativeRegex\n         *\n         * The regular expression used to remove the protocol-relative '//' from the {@link #url} string, for purposes\n         * of {@link #getAnchorText}. A protocol-relative URL is, for example, \"//yahoo.com\"\n         */\n        _this.protocolRelativeRegex = /^\\/\\//;\n        /**\n         * @private\n         * @property {Boolean} protocolPrepended\n         *\n         * Will be set to `true` if the 'http://' protocol has been prepended to the {@link #url} (because the\n         * {@link #url} did not have a protocol)\n         */\n        _this.protocolPrepended = false;\n        _this.urlMatchType = cfg.urlMatchType;\n        _this.url = cfg.url;\n        _this.protocolUrlMatch = cfg.protocolUrlMatch;\n        _this.protocolRelativeMatch = cfg.protocolRelativeMatch;\n        _this.stripPrefix = cfg.stripPrefix;\n        _this.stripTrailingSlash = cfg.stripTrailingSlash;\n        _this.decodePercentEncoding = cfg.decodePercentEncoding;\n        return _this;\n    }\n    /**\n     * Returns a string name for the type of match that this class represents.\n     *\n     * @return {String}\n     */\n    UrlMatch.prototype.getType = function () {\n        return 'url';\n    };\n    /**\n     * Returns a string name for the type of URL match that this class\n     * represents.\n     *\n     * This helps to determine if the match was made in the original text with a\n     * prefixed scheme (ex: 'http://www.google.com'), a prefixed 'www' (ex:\n     * 'www.google.com'), or was matched by a known top-level domain (ex:\n     * 'google.com').\n     *\n     * @return {\"scheme\"/\"www\"/\"tld\"}\n     */\n    UrlMatch.prototype.getUrlMatchType = function () {\n        return this.urlMatchType;\n    };\n    /**\n     * Returns the url that was matched, assuming the protocol to be 'http://' if the original\n     * match was missing a protocol.\n     *\n     * @return {String}\n     */\n    UrlMatch.prototype.getUrl = function () {\n        var url = this.url;\n        // if the url string doesn't begin with a protocol, assume 'http://'\n        if (!this.protocolRelativeMatch && !this.protocolUrlMatch && !this.protocolPrepended) {\n            url = this.url = 'http://' + url;\n            this.protocolPrepended = true;\n        }\n        return url;\n    };\n    /**\n     * Returns the anchor href that should be generated for the match.\n     *\n     * @return {String}\n     */\n    UrlMatch.prototype.getAnchorHref = function () {\n        var url = this.getUrl();\n        return url.replace(/&amp;/g, '&'); // any &amp;'s in the URL should be converted back to '&' if they were displayed as &amp; in the source html\n    };\n    /**\n     * Returns the anchor text that should be generated for the match.\n     *\n     * @return {String}\n     */\n    UrlMatch.prototype.getAnchorText = function () {\n        var anchorText = this.getMatchedText();\n        if (this.protocolRelativeMatch) {\n            // Strip off any protocol-relative '//' from the anchor text\n            anchorText = this.stripProtocolRelativePrefix(anchorText);\n        }\n        if (this.stripPrefix.scheme) {\n            anchorText = this.stripSchemePrefix(anchorText);\n        }\n        if (this.stripPrefix.www) {\n            anchorText = this.stripWwwPrefix(anchorText);\n        }\n        if (this.stripTrailingSlash) {\n            anchorText = this.removeTrailingSlash(anchorText); // remove trailing slash, if there is one\n        }\n        if (this.decodePercentEncoding) {\n            anchorText = this.removePercentEncoding(anchorText);\n        }\n        return anchorText;\n    };\n    // ---------------------------------------\n    // Utility Functionality\n    /**\n     * Strips the scheme prefix (such as \"http://\" or \"https://\") from the given\n     * `url`.\n     *\n     * @private\n     * @param {String} url The text of the anchor that is being generated, for\n     *   which to strip off the url scheme.\n     * @return {String} The `url`, with the scheme stripped.\n     */\n    UrlMatch.prototype.stripSchemePrefix = function (url) {\n        return url.replace(this.schemePrefixRegex, '');\n    };\n    /**\n     * Strips the 'www' prefix from the given `url`.\n     *\n     * @private\n     * @param {String} url The text of the anchor that is being generated, for\n     *   which to strip off the 'www' if it exists.\n     * @return {String} The `url`, with the 'www' stripped.\n     */\n    UrlMatch.prototype.stripWwwPrefix = function (url) {\n        return url.replace(this.wwwPrefixRegex, '$1'); // leave any scheme ($1), it one exists\n    };\n    /**\n     * Strips any protocol-relative '//' from the anchor text.\n     *\n     * @private\n     * @param {String} text The text of the anchor that is being generated, for which to strip off the\n     *   protocol-relative prefix (such as stripping off \"//\")\n     * @return {String} The `anchorText`, with the protocol-relative prefix stripped.\n     */\n    UrlMatch.prototype.stripProtocolRelativePrefix = function (text) {\n        return text.replace(this.protocolRelativeRegex, '');\n    };\n    /**\n     * Removes any trailing slash from the given `anchorText`, in preparation for the text to be displayed.\n     *\n     * @private\n     * @param {String} anchorText The text of the anchor that is being generated, for which to remove any trailing\n     *   slash ('/') that may exist.\n     * @return {String} The `anchorText`, with the trailing slash removed.\n     */\n    UrlMatch.prototype.removeTrailingSlash = function (anchorText) {\n        if (anchorText.charAt(anchorText.length - 1) === '/') {\n            anchorText = anchorText.slice(0, -1);\n        }\n        return anchorText;\n    };\n    /**\n     * Decodes percent-encoded characters from the given `anchorText`, in preparation for the text to be displayed.\n     *\n     * @private\n     * @param {String} anchorText The text of the anchor that is being generated, for which to decode any percent-encoded characters.\n     * @return {String} The `anchorText`, with the percent-encoded characters decoded.\n     */\n    UrlMatch.prototype.removePercentEncoding = function (anchorText) {\n        try {\n            return decodeURIComponent(anchorText\n                .replace(/%22/gi, '&quot;')\n                .replace(/%26/gi, '&amp;')\n                .replace(/%27/gi, '&#39;')\n                .replace(/%3C/gi, '&lt;')\n                .replace(/%3E/gi, '&gt;'));\n        }\n        catch (e) {\n            // Invalid escape sequence.\n            return anchorText;\n        }\n    };\n    return UrlMatch;\n}(Match));\nexport { UrlMatch };\n\n//# sourceMappingURL=url-match.js.map\n","/**\n * @abstract\n * @class Autolinker.matcher.Matcher\n *\n * An abstract class and interface for individual matchers to find matches in\n * an input string with linkified versions of them.\n *\n * Note that Matchers do not take HTML into account - they must be fed the text\n * nodes of any HTML string, which is handled by {@link Autolinker#parse}.\n */\nvar Matcher = /** @class */ (function () {\n    /**\n     * @constructor\n     * @param {Object} cfg The configuration properties for the Matcher\n     *   instance, specified in an Object (map).\n     */\n    function Matcher(cfg) {\n        this.tagBuilder = cfg.tagBuilder;\n    }\n    return Matcher;\n}());\nexport { Matcher };\n\n//# sourceMappingURL=matcher.js.map\n","/*\n * This file builds and stores a library of the common regular expressions used\n * by the Autolinker utility.\n *\n * Other regular expressions may exist ad-hoc, but these are generally the\n * regular expressions that are shared between source files.\n */\n/**\n * The string form of a regular expression that would match all of the\n * alphabetic (\"letter\") chars in the unicode character set when placed in a\n * RegExp character class (`[]`). This includes all international alphabetic\n * characters.\n *\n * These would be the characters matched by unicode regex engines `\\p{L}`\n * escape (\"all letters\").\n *\n * Taken from the XRegExp library: http://xregexp.com/\n * Specifically: http://xregexp.com/v/3.0.0/unicode-categories.js\n */\nexport var alphaCharsStr = 'A-Za-z\\\\xAA\\\\xB5\\\\xBA\\\\xC0-\\\\xD6\\\\xD8-\\\\xF6\\\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B4\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16F1-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2183\\u2184\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005\\u3006\\u3031-\\u3035\\u303B\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6E5\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AD\\uA7B0-\\uA7B7\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC';\n/**\n * The string form of a regular expression that would match all of the\n * decimal number chars in the unicode character set when placed in a RegExp\n * character class (`[]`).\n *\n * These would be the characters matched by unicode regex engines `\\p{Nd}`\n * escape (\"all decimal numbers\")\n *\n * Taken from the XRegExp library: http://xregexp.com/\n * Specifically: http://xregexp.com/v/3.0.0/unicode-categories.js\n *\n * @private\n * @type {String}\n */\nexport var decimalNumbersStr = '0-9\\u0660-\\u0669\\u06F0-\\u06F9\\u07C0-\\u07C9\\u0966-\\u096F\\u09E6-\\u09EF\\u0A66-\\u0A6F\\u0AE6-\\u0AEF\\u0B66-\\u0B6F\\u0BE6-\\u0BEF\\u0C66-\\u0C6F\\u0CE6-\\u0CEF\\u0D66-\\u0D6F\\u0DE6-\\u0DEF\\u0E50-\\u0E59\\u0ED0-\\u0ED9\\u0F20-\\u0F29\\u1040-\\u1049\\u1090-\\u1099\\u17E0-\\u17E9\\u1810-\\u1819\\u1946-\\u194F\\u19D0-\\u19D9\\u1A80-\\u1A89\\u1A90-\\u1A99\\u1B50-\\u1B59\\u1BB0-\\u1BB9\\u1C40-\\u1C49\\u1C50-\\u1C59\\uA620-\\uA629\\uA8D0-\\uA8D9\\uA900-\\uA909\\uA9D0-\\uA9D9\\uA9F0-\\uA9F9\\uAA50-\\uAA59\\uABF0-\\uABF9\\uFF10-\\uFF19';\n/**\n * The string form of a regular expression that would match all of the\n * letters and decimal number chars in the unicode character set when placed\n * in a RegExp character class (`[]`).\n *\n * These would be the characters matched by unicode regex engines `[\\p{L}\\p{Nd}]`\n * escape (\"all letters and decimal numbers\")\n */\nexport var alphaNumericCharsStr = alphaCharsStr + decimalNumbersStr;\n// Simplified IP regular expression\nvar ipStr = '(?:[' + decimalNumbersStr + ']{1,3}\\\\.){3}[' + decimalNumbersStr + ']{1,3}';\n// Protected domain label which do not allow \"-\" character on the beginning and the end of a single label\nvar domainLabelStr = '[' + alphaNumericCharsStr + '](?:[' + alphaNumericCharsStr + '\\\\-]{0,61}[' + alphaNumericCharsStr + '])?';\nvar getDomainLabelStr = function (group) {\n    return '(?=(' + domainLabelStr + '))\\\\' + group;\n};\n/**\n * A function to match domain names of a URL or email address.\n * Ex: 'google', 'yahoo', 'some-other-company', etc.\n */\nexport var getDomainNameStr = function (group) {\n    return '(?:' + getDomainLabelStr(group) + '(?:\\\\.' + getDomainLabelStr(group + 1) + '){0,126}|' + ipStr + ')';\n};\n/**\n * A regular expression to match domain names of a URL or email address.\n * Ex: 'google', 'yahoo', 'some-other-company', etc.\n */\nexport var domainNameRegex = new RegExp('[' + alphaNumericCharsStr + '.\\\\-]*[' + alphaNumericCharsStr + '\\\\-]');\n\n//# sourceMappingURL=regex-lib.js.map\n","// NOTE: THIS IS A GENERATED FILE\n// To update with the latest TLD list, run `gulp update-tld-list`\nexport var tldRegex = /(?:xn--vermgensberatung-pwb|xn--vermgensberater-ctb|xn--clchc0ea0b2g2a9gcd|xn--w4r85el8fhu5dnra|northwesternmutual|travelersinsurance|vermgensberatung|xn--3oq18vl8pn36a|xn--5su34j936bgsg|xn--bck1b9a5dre4c|xn--mgbai9azgqp6j|xn--mgberp4a5d4ar|xn--xkc2dl3a5ee0h|vermgensberater|xn--fzys8d69uvgm|xn--mgba7c0bbn0a|xn--xkc2al3hye2a|americanexpress|kerryproperties|sandvikcoromant|xn--i1b6b1a6a2e|xn--kcrx77d1x4a|xn--lgbbat1ad8j|xn--mgba3a4f16a|xn--mgbc0a9azcg|xn--nqv7fs00ema|afamilycompany|americanfamily|bananarepublic|cancerresearch|cookingchannel|kerrylogistics|weatherchannel|xn--54b7fta0cc|xn--6qq986b3xl|xn--80aqecdr1a|xn--b4w605ferd|xn--fiq228c5hs|xn--jlq61u9w7b|xn--mgba3a3ejt|xn--mgbaam7a8h|xn--mgbayh7gpa|xn--mgbb9fbpob|xn--mgbbh1a71e|xn--mgbca7dzdo|xn--mgbi4ecexp|xn--mgbx4cd0ab|international|lifeinsurance|orientexpress|spreadbetting|travelchannel|wolterskluwer|xn--eckvdtc9d|xn--fpcrj9c3d|xn--fzc2c9e2c|xn--tiq49xqyj|xn--yfro4i67o|xn--ygbi2ammx|construction|lplfinancial|pamperedchef|scholarships|versicherung|xn--3e0b707e|xn--80adxhks|xn--80asehdb|xn--8y0a063a|xn--gckr3f0f|xn--mgb9awbf|xn--mgbab2bd|xn--mgbpl2fh|xn--mgbt3dhd|xn--mk1bu44c|xn--ngbc5azd|xn--ngbe9e0a|xn--ogbpf8fl|xn--qcka1pmc|accountants|barclaycard|blackfriday|blockbuster|bridgestone|calvinklein|contractors|creditunion|engineering|enterprises|foodnetwork|investments|kerryhotels|lamborghini|motorcycles|olayangroup|photography|playstation|productions|progressive|redumbrella|rightathome|williamhill|xn--11b4c3d|xn--1ck2e1b|xn--1qqw23a|xn--3bst00m|xn--3ds443g|xn--42c2d9a|xn--45brj9c|xn--55qw42g|xn--6frz82g|xn--80ao21a|xn--9krt00a|xn--cck2b3b|xn--czr694b|xn--d1acj3b|xn--efvy88h|xn--estv75g|xn--fct429k|xn--fjq720a|xn--flw351e|xn--g2xx48c|xn--gecrj9c|xn--gk3at1e|xn--h2brj9c|xn--hxt814e|xn--imr513n|xn--j6w193g|xn--jvr189m|xn--kprw13d|xn--kpry57d|xn--kpu716f|xn--mgbtx2b|xn--mix891f|xn--nyqy26a|xn--pbt977c|xn--pgbs0dh|xn--q9jyb4c|xn--rhqv96g|xn--rovu88b|xn--s9brj9c|xn--ses554g|xn--t60b56a|xn--vuq861b|xn--w4rs40l|xn--xhq521b|xn--zfr164b||accountant|apartments|associates|basketball|bnpparibas|boehringer|capitalone|consulting|creditcard|cuisinella|eurovision|extraspace|foundation|healthcare|immobilien|industries|management|mitsubishi|nationwide|newholland|nextdirect|onyourside|properties|protection|prudential|realestate|republican|restaurant|schaeffler|swiftcover|tatamotors|technology|telefonica|university|vistaprint|vlaanderen|volkswagen|xn--30rr7y|xn--3pxu8k|xn--45q11c|xn--4gbrim|xn--55qx5d|xn--5tzm5g|xn--80aswg|xn--90a3ac|xn--9dbq2a|xn--9et52u|xn--c2br7g|xn--cg4bki|xn--czrs0t|xn--czru2d|xn--fiq64b|xn--fiqs8s|xn--fiqz9s|xn--io0a7i|xn--kput3i|xn--mxtq1m|xn--o3cw4h|xn--pssy2u|xn--unup4y|xn--wgbh1c|xn--wgbl6a|xn--y9a3aq|accenture|alfaromeo|allfinanz|amsterdam|analytics|aquarelle|barcelona|bloomberg|christmas|community|directory|education|equipment|fairwinds|financial|firestone|fresenius|frontdoor|fujixerox|furniture|goldpoint|goodhands|hisamitsu|homedepot|homegoods|homesense|honeywell|institute|insurance|kuokgroup|ladbrokes|lancaster|landrover|lifestyle|marketing|marshalls|mcdonalds|melbourne|microsoft|montblanc|panasonic|passagens|pramerica|richardli|scjohnson|shangrila|solutions|statebank|statefarm|stockholm|travelers|vacations|xn--90ais|xn--c1avg|xn--d1alf|xn--e1a4c|xn--fhbei|xn--j1aef|xn--j1amh|xn--l1acc|xn--nqv7f|xn--p1acf|xn--tckwe|xn--vhquv|yodobashi|abudhabi|airforce|allstate|attorney|barclays|barefoot|bargains|baseball|boutique|bradesco|broadway|brussels|budapest|builders|business|capetown|catering|catholic|chrysler|cipriani|cityeats|cleaning|clinique|clothing|commbank|computer|delivery|deloitte|democrat|diamonds|discount|discover|download|engineer|ericsson|esurance|everbank|exchange|feedback|fidelity|firmdale|football|frontier|goodyear|grainger|graphics|guardian|hdfcbank|helsinki|holdings|hospital|infiniti|ipiranga|istanbul|jpmorgan|lighting|lundbeck|marriott|maserati|mckinsey|memorial|mortgage|movistar|observer|partners|pharmacy|pictures|plumbing|property|redstone|reliance|saarland|samsclub|security|services|shopping|showtime|softbank|software|stcgroup|supplies|symantec|telecity|training|uconnect|vanguard|ventures|verisign|woodside|xn--90ae|xn--node|xn--p1ai|xn--qxam|yokohama||abogado|academy|agakhan|alibaba|android|athleta|auction|audible|auspost|avianca|banamex|bauhaus|bentley|bestbuy|booking|brother|bugatti|capital|caravan|careers|cartier|channel|chintai|citadel|clubmed|college|cologne|comcast|company|compare|contact|cooking|corsica|country|coupons|courses|cricket|cruises|dentist|digital|domains|exposed|express|farmers|fashion|ferrari|ferrero|finance|fishing|fitness|flights|florist|flowers|forsale|frogans|fujitsu|gallery|genting|godaddy|guitars|hamburg|hangout|hitachi|holiday|hosting|hoteles|hotmail|hyundai|iselect|ismaili|jewelry|juniper|kitchen|komatsu|lacaixa|lancome|lanxess|lasalle|latrobe|leclerc|liaison|limited|lincoln|markets|metlife|monster|netbank|netflix|network|neustar|okinawa|oldnavy|organic|origins|panerai|philips|pioneer|politie|realtor|recipes|rentals|reviews|rexroth|samsung|sandvik|schmidt|schwarz|science|shiksha|shriram|singles|spiegel|staples|starhub|statoil|storage|support|surgery|systems|temasek|theater|theatre|tickets|tiffany|toshiba|trading|walmart|wanggou|watches|weather|website|wedding|whoswho|windows|winners|xfinity|yamaxun|youtube|zuerich||||||||abarth|abbott|abbvie|active|africa|agency|airbus|airtel|alipay|alsace|alstom|anquan|aramco|author|bayern|beauty|berlin|bharti|blanco|bostik|boston|broker|camera|career|caseih|casino|center|chanel|chrome|church|circle|claims|clinic|coffee|comsec|condos|coupon|credit|cruise|dating|datsun|dealer|degree|dental|design|direct|doctor|dunlop|dupont|durban|emerck|energy|estate|events|expert|family|flickr|futbol|gallup|garden|george|giving|global|google|gratis|health|hermes|hiphop|hockey|hughes|imamat|insure|intuit|jaguar|joburg|juegos|kaufen|kinder|kindle|kosher|lancia|latino|lawyer|lefrak|living|locker|london|luxury|madrid|maison|makeup|market|mattel|mobile|mobily|monash|mormon|moscow|museum|mutual|nagoya|natura|nissan|nissay|norton|nowruz|office|olayan|online|oracle|orange|otsuka|pfizer|photos|physio|piaget|pictet|quebec|racing|realty|reisen|repair|report|review|rocher|rogers|ryukyu|safety|sakura|sanofi|school|schule|secure|select|shouji|soccer|social|stream|studio|supply|suzuki|swatch|sydney|taipei|taobao|target|tattoo|tennis|tienda|tjmaxx|tkmaxx|toyota|travel|unicom|viajes|viking|villas|virgin|vision|voting|voyage|vuelos|walter|warman|webcam|xihuan|xperia|yachts|yandex|zappos||||||||||||actor|adult|aetna|amfam|amica|apple|archi|audio|autos|azure|baidu|beats|bible|bingo|black|boats|boots|bosch|build|canon|cards|chase|cheap|chloe|cisco|citic|click|cloud|coach|codes|crown|cymru|dabur|dance|deals|delta|dodge|drive|dubai|earth|edeka|email|epost|epson|faith|fedex|final|forex|forum|gallo|games|gifts|gives|glade|glass|globo|gmail|green|gripe|group|gucci|guide|homes|honda|horse|house|hyatt|ikano|intel|irish|iveco|jetzt|koeln|kyoto|lamer|lease|legal|lexus|lilly|linde|lipsy|lixil|loans|locus|lotte|lotto|lupin|macys|mango|media|miami|money|mopar|movie|nadex|nexus|nikon|ninja|nokia|nowtv|omega|osaka|paris|parts|party|phone|photo|pizza|place|poker|praxi|press|prime|promo|quest|radio|rehab|reise|ricoh|rocks|rodeo|salon|sener|seven|sharp|shell|shoes|skype|sling|smart|smile|solar|space|stada|store|study|style|sucks|swiss|tatar|tires|tirol|tmall|today|tokyo|tools|toray|total|tours|trade|trust|tunes|tushu|ubank|vegas|video|vista|vodka|volvo|wales|watch|weber|weibo|works|world|xerox|yahoo|zippo|||||||||||aarp|able|adac|aero|aigo|akdn|ally|amex|army|arpa|arte|asda|asia|audi|auto|baby|band|bank|bbva|beer|best|bike|bing|blog|blue|bofa|bond|book|buzz|cafe|call|camp|care|cars|casa|case|cash|cbre|cern|chat|citi|city|club|cool|coop|cyou|data|date|dclk|deal|dell|desi|diet|dish|docs|doha|duck|duns|dvag|erni|fage|fail|fans|farm|fast|fiat|fido|film|fire|fish|flir|food|ford|free|fund|game|gbiz|gent|ggee|gift|gmbh|gold|golf|goog|guge|guru|hair|haus|hdfc|help|here|hgtv|host|hsbc|icbc|ieee|imdb|immo|info|itau|java|jeep|jobs|jprs|kddi|kiwi|kpmg|kred|land|lego|lgbt|lidl|life|like|limo|link|live|loan|loft|love|ltda|luxe|maif|meet|meme|menu|mini|mint|mobi|moda|moto|mtpc|name|navy|news|next|nico|nike|ollo|open|page|pars|pccw|pics|ping|pink|play|plus|pohl|porn|post|prod|prof|qpon|raid|read|reit|rent|rest|rich|rmit|room|rsvp|ruhr|safe|sale|sapo|sarl|save|saxo|scor|scot|seat|seek|sexy|shaw|shia|shop|show|silk|sina|site|skin|sncf|sohu|song|sony|spot|star|surf|talk|taxi|team|tech|teva|tiaa|tips|town|toys|tube|vana|visa|viva|vivo|vote|voto|wang|weir|wien|wiki|wine|work|xbox|yoga|zara|zero|zone|||||||||||||||||||||aaa|abb|abc|aco|ads|aeg|afl|aig|anz|aol|app|art|aws|axa|bar|bbc|bbt|bcg|bcn|bet|bid|bio|biz|bms|bmw|bnl|bom|boo|bot|box|buy|bzh|cab|cal|cam|car|cat|cba|cbn|cbs|ceb|ceo|cfa|cfd|com|crs|csc|dad|day|dds|dev|dhl|diy|dnp|dog|dot|dtv|dvr|eat|eco|edu|esq|eus|fan|fit|fly|foo|fox|frl|ftr|fun|fyi|gal|gap|gdn|gea|gle|gmo|gmx|goo|gop|got|gov|hbo|hiv|hkt|hot|how|htc|ibm|ice|icu|ifm|ing|ink|int|ist|itv|iwc|jcb|jcp|jio|jlc|jll|jmp|jnj|jot|joy|kfh|kia|kim|kpn|krd|lat|law|lds|lol|lpl|ltd|man|mba|mcd|med|men|meo|mil|mit|mlb|mls|mma|moe|moi|mom|mov|msd|mtn|mtr|nab|nba|nec|net|new|nfl|ngo|nhk|now|nra|nrw|ntt|nyc|obi|off|one|ong|onl|ooo|org|ott|ovh|pay|pet|pid|pin|pnc|pro|pru|pub|pwc|qvc|red|ren|ril|rio|rip|run|rwe|sap|sas|sbi|sbs|sca|scb|ses|sew|sex|sfr|ski|sky|soy|srl|srt|stc|tab|tax|tci|tdk|tel|thd|tjx|top|trv|tui|tvs|ubs|uno|uol|ups|vet|vig|vin|vip|wed|win|wme|wow|wtc|wtf|xin|xxx|xyz|you|yun|zip|||||||||||||||||||||||||||||ac|ad|ae|af|ag|ai|al|am|ao|aq|ar|as|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cw|cx|cy|cz|de|dj|dk|dm|do|dz|ec|ee|eg|er|es|et|eu|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|py|qa|re|ro|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sk|sl|sm|sn|so|sr|st|su|sv|sx|sy|sz|tc|td|tf|tg|th|tj|tk|tl|tm|tn|to|tr|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|za|zm|zw||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||)/;\n\n//# sourceMappingURL=tld-regex.js.map\n","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { Matcher } from \"./matcher\";\nimport { alphaNumericCharsStr, getDomainNameStr } from \"../regex-lib\";\nimport { tldRegex } from \"./tld-regex\";\nimport { EmailMatch } from \"../match/email-match\";\n/**\n * @class Autolinker.matcher.Email\n * @extends Autolinker.matcher.Matcher\n *\n * Matcher to find email matches in an input string.\n *\n * See this class's superclass ({@link Autolinker.matcher.Matcher}) for more details.\n */\nvar EmailMatcher = /** @class */ (function (_super) {\n    __extends(EmailMatcher, _super);\n    function EmailMatcher() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /**\n         * The regular expression to match email addresses. Example match:\n         *\n         *     person@place.com\n         *\n         * @private\n         * @property {RegExp} matcherRegex\n         */\n        _this.matcherRegex = (function () {\n            var alphaNumericChars = alphaNumericCharsStr, specialCharacters = '!#$%&\\'*+\\\\-\\\\/=?^_`{|}~', restrictedSpecialCharacters = '\\\\s\"(),:;<>@\\\\[\\\\]', validCharacters = alphaNumericChars + specialCharacters, validRestrictedCharacters = validCharacters + restrictedSpecialCharacters, emailRegex = new RegExp('(?:[' + validCharacters + '](?:[' + validCharacters + ']|\\\\.(?!\\\\.|@))*|\\\\\"[' + validRestrictedCharacters + '.]+\\\\\")@');\n            return new RegExp([\n                emailRegex.source,\n                getDomainNameStr(1),\n                '\\\\.', tldRegex.source // '.com', '.net', etc\n            ].join(\"\"), 'gi');\n        })();\n        return _this;\n    }\n    /**\n     * @inheritdoc\n     */\n    EmailMatcher.prototype.parseMatches = function (text) {\n        var matcherRegex = this.matcherRegex, tagBuilder = this.tagBuilder, matches = [], match;\n        while ((match = matcherRegex.exec(text)) !== null) {\n            var matchedText = match[0];\n            matches.push(new EmailMatch({\n                tagBuilder: tagBuilder,\n                matchedText: matchedText,\n                offset: match.index,\n                email: matchedText\n            }));\n        }\n        return matches;\n    };\n    return EmailMatcher;\n}(Matcher));\nexport { EmailMatcher };\n\n//# sourceMappingURL=email-matcher.js.map\n","import { alphaCharsStr } from \"../regex-lib\";\n/**\n * @private\n * @class Autolinker.matcher.UrlMatchValidator\n * @singleton\n *\n * Used by Autolinker to filter out false URL positives from the\n * {@link Autolinker.matcher.Url UrlMatcher}.\n *\n * Due to the limitations of regular expressions (including the missing feature\n * of look-behinds in JS regular expressions), we cannot always determine the\n * validity of a given match. This class applies a bit of additional logic to\n * filter out any false positives that have been matched by the\n * {@link Autolinker.matcher.Url UrlMatcher}.\n */\nvar UrlMatchValidator = /** @class */ (function () {\n    function UrlMatchValidator() {\n    }\n    /**\n     * Determines if a given URL match found by the {@link Autolinker.matcher.Url UrlMatcher}\n     * is valid. Will return `false` for:\n     *\n     * 1) URL matches which do not have at least have one period ('.') in the\n     *    domain name (effectively skipping over matches like \"abc:def\").\n     *    However, URL matches with a protocol will be allowed (ex: 'http://localhost')\n     * 2) URL matches which do not have at least one word character in the\n     *    domain name (effectively skipping over matches like \"git:1.0\").\n     * 3) A protocol-relative url match (a URL beginning with '//') whose\n     *    previous character is a word character (effectively skipping over\n     *    strings like \"abc//google.com\")\n     *\n     * Otherwise, returns `true`.\n     *\n     * @param {String} urlMatch The matched URL, if there was one. Will be an\n     *   empty string if the match is not a URL match.\n     * @param {String} protocolUrlMatch The match URL string for a protocol\n     *   match. Ex: 'http://yahoo.com'. This is used to match something like\n     *   'http://localhost', where we won't double check that the domain name\n     *   has at least one '.' in it.\n     * @return {Boolean} `true` if the match given is valid and should be\n     *   processed, or `false` if the match is invalid and/or should just not be\n     *   processed.\n     */\n    UrlMatchValidator.isValid = function (urlMatch, protocolUrlMatch) {\n        if ((protocolUrlMatch && !this.isValidUriScheme(protocolUrlMatch)) ||\n            this.urlMatchDoesNotHaveProtocolOrDot(urlMatch, protocolUrlMatch) || // At least one period ('.') must exist in the URL match for us to consider it an actual URL, *unless* it was a full protocol match (like 'http://localhost')\n            (this.urlMatchDoesNotHaveAtLeastOneWordChar(urlMatch, protocolUrlMatch) && // At least one letter character must exist in the domain name after a protocol match. Ex: skip over something like \"git:1.0\"\n                !this.isValidIpAddress(urlMatch)) || // Except if it's an IP address\n            this.containsMultipleDots(urlMatch)) {\n            return false;\n        }\n        return true;\n    };\n    UrlMatchValidator.isValidIpAddress = function (uriSchemeMatch) {\n        var newRegex = new RegExp(this.hasFullProtocolRegex.source + this.ipRegex.source);\n        var uriScheme = uriSchemeMatch.match(newRegex);\n        return uriScheme !== null;\n    };\n    UrlMatchValidator.containsMultipleDots = function (urlMatch) {\n        var stringBeforeSlash = urlMatch;\n        if (this.hasFullProtocolRegex.test(urlMatch)) {\n            stringBeforeSlash = urlMatch.split('://')[1];\n        }\n        return stringBeforeSlash.split('/')[0].indexOf(\"..\") > -1;\n    };\n    /**\n     * Determines if the URI scheme is a valid scheme to be autolinked. Returns\n     * `false` if the scheme is 'javascript:' or 'vbscript:'\n     *\n     * @private\n     * @param {String} uriSchemeMatch The match URL string for a full URI scheme\n     *   match. Ex: 'http://yahoo.com' or 'mailto:a@a.com'.\n     * @return {Boolean} `true` if the scheme is a valid one, `false` otherwise.\n     */\n    UrlMatchValidator.isValidUriScheme = function (uriSchemeMatch) {\n        var uriSchemeMatchArr = uriSchemeMatch.match(this.uriSchemeRegex), uriScheme = uriSchemeMatchArr && uriSchemeMatchArr[0].toLowerCase();\n        return (uriScheme !== 'javascript:' && uriScheme !== 'vbscript:');\n    };\n    /**\n     * Determines if a URL match does not have either:\n     *\n     * a) a full protocol (i.e. 'http://'), or\n     * b) at least one dot ('.') in the domain name (for a non-full-protocol\n     *    match).\n     *\n     * Either situation is considered an invalid URL (ex: 'git:d' does not have\n     * either the '://' part, or at least one dot in the domain name. If the\n     * match was 'git:abc.com', we would consider this valid.)\n     *\n     * @private\n     * @param {String} urlMatch The matched URL, if there was one. Will be an\n     *   empty string if the match is not a URL match.\n     * @param {String} protocolUrlMatch The match URL string for a protocol\n     *   match. Ex: 'http://yahoo.com'. This is used to match something like\n     *   'http://localhost', where we won't double check that the domain name\n     *   has at least one '.' in it.\n     * @return {Boolean} `true` if the URL match does not have a full protocol,\n     *   or at least one dot ('.') in a non-full-protocol match.\n     */\n    UrlMatchValidator.urlMatchDoesNotHaveProtocolOrDot = function (urlMatch, protocolUrlMatch) {\n        return (!!urlMatch && (!protocolUrlMatch || !this.hasFullProtocolRegex.test(protocolUrlMatch)) && urlMatch.indexOf('.') === -1);\n    };\n    /**\n     * Determines if a URL match does not have at least one word character after\n     * the protocol (i.e. in the domain name).\n     *\n     * At least one letter character must exist in the domain name after a\n     * protocol match. Ex: skip over something like \"git:1.0\"\n     *\n     * @private\n     * @param {String} urlMatch The matched URL, if there was one. Will be an\n     *   empty string if the match is not a URL match.\n     * @param {String} protocolUrlMatch The match URL string for a protocol\n     *   match. Ex: 'http://yahoo.com'. This is used to know whether or not we\n     *   have a protocol in the URL string, in order to check for a word\n     *   character after the protocol separator (':').\n     * @return {Boolean} `true` if the URL match does not have at least one word\n     *   character in it after the protocol, `false` otherwise.\n     */\n    UrlMatchValidator.urlMatchDoesNotHaveAtLeastOneWordChar = function (urlMatch, protocolUrlMatch) {\n        if (urlMatch && protocolUrlMatch) {\n            return !this.hasWordCharAfterProtocolRegex.test(urlMatch);\n        }\n        else {\n            return false;\n        }\n    };\n    /**\n     * Regex to test for a full protocol, with the two trailing slashes. Ex: 'http://'\n     *\n     * @private\n     * @property {RegExp} hasFullProtocolRegex\n     */\n    UrlMatchValidator.hasFullProtocolRegex = /^[A-Za-z][-.+A-Za-z0-9]*:\\/\\//;\n    /**\n     * Regex to find the URI scheme, such as 'mailto:'.\n     *\n     * This is used to filter out 'javascript:' and 'vbscript:' schemes.\n     *\n     * @private\n     * @property {RegExp} uriSchemeRegex\n     */\n    UrlMatchValidator.uriSchemeRegex = /^[A-Za-z][-.+A-Za-z0-9]*:/;\n    /**\n     * Regex to determine if at least one word char exists after the protocol (i.e. after the ':')\n     *\n     * @private\n     * @property {RegExp} hasWordCharAfterProtocolRegex\n     */\n    UrlMatchValidator.hasWordCharAfterProtocolRegex = new RegExp(\":[^\\\\s]*?[\" + alphaCharsStr + \"]\");\n    /**\n     * Regex to determine if the string is a valid IP address\n     *\n     * @private\n     * @property {RegExp} ipRegex\n     */\n    UrlMatchValidator.ipRegex = /[0-9][0-9]?[0-9]?\\.[0-9][0-9]?[0-9]?\\.[0-9][0-9]?[0-9]?\\.[0-9][0-9]?[0-9]?(:[0-9]*)?\\/?$/;\n    return UrlMatchValidator;\n}());\nexport { UrlMatchValidator };\n\n//# sourceMappingURL=url-match-validator.js.map\n","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { Matcher } from \"./matcher\";\nimport { alphaNumericCharsStr, getDomainNameStr } from \"../regex-lib\";\nimport { tldRegex } from \"./tld-regex\";\nimport { UrlMatch } from \"../match/url-match\";\nimport { UrlMatchValidator } from \"./url-match-validator\";\n/**\n * @class Autolinker.matcher.Url\n * @extends Autolinker.matcher.Matcher\n *\n * Matcher to find URL matches in an input string.\n *\n * See this class's superclass ({@link Autolinker.matcher.Matcher}) for more details.\n */\nvar UrlMatcher = /** @class */ (function (_super) {\n    __extends(UrlMatcher, _super);\n    /**\n     * @constructor\n     * @param {Object} cfg The configuration properties for the Match instance,\n     *   specified in an Object (map).\n     */\n    function UrlMatcher(cfg) {\n        var _this = _super.call(this, cfg) || this;\n        /**\n         * @private\n         * @property {RegExp} matcherRegex\n         *\n         * The regular expression to match URLs with an optional scheme, port\n         * number, path, query string, and hash anchor.\n         *\n         * Example matches:\n         *\n         *     http://google.com\n         *     www.google.com\n         *     google.com/path/to/file?q1=1&q2=2#myAnchor\n         *\n         *\n         * This regular expression will have the following capturing groups:\n         *\n         * 1.  Group that matches a scheme-prefixed URL (i.e. 'http://google.com').\n         *     This is used to match scheme URLs with just a single word, such as\n         *     'http://localhost', where we won't double check that the domain name\n         *     has at least one dot ('.') in it.\n         * 2.  Group that matches a 'www.' prefixed URL. This is only matched if the\n         *     'www.' text was not prefixed by a scheme (i.e.: not prefixed by\n         *     'http://', 'ftp:', etc.)\n         * 3.  A protocol-relative ('//') match for the case of a 'www.' prefixed\n         *     URL. Will be an empty string if it is not a protocol-relative match.\n         *     We need to know the character before the '//' in order to determine\n         *     if it is a valid match or the // was in a string we don't want to\n         *     auto-link.\n         * 4.  Group that matches a known TLD (top level domain), when a scheme\n         *     or 'www.'-prefixed domain is not matched.\n         * 5.  A protocol-relative ('//') match for the case of a known TLD prefixed\n         *     URL. Will be an empty string if it is not a protocol-relative match.\n         *     See #3 for more info.\n         */\n        _this.matcherRegex = (function () {\n            var schemeRegex = /(?:[A-Za-z][-.+A-Za-z0-9]{0,63}:(?![A-Za-z][-.+A-Za-z0-9]{0,63}:\\/\\/)(?!\\d+\\/?)(?:\\/\\/)?)/, // match protocol, allow in format \"http://\" or \"mailto:\". However, do not match the first part of something like 'link:http://www.google.com' (i.e. don't match \"link:\"). Also, make sure we don't interpret 'google.com:8000' as if 'google.com' was a protocol here (i.e. ignore a trailing port number in this regex)\n            wwwRegex = /(?:www\\.)/, // starting with 'www.'\n            // Allow optional path, query string, and hash anchor, not ending in the following characters: \"?!:,.;\"\n            // http://blog.codinghorror.com/the-problem-with-urls/\n            urlSuffixRegex = new RegExp('[/?#](?:[' + alphaNumericCharsStr + '\\\\-+&@#/%=~_()|\\'$*\\\\[\\\\]?!:,.;\\u2713]*[' + alphaNumericCharsStr + '\\\\-+&@#/%=~_()|\\'$*\\\\[\\\\]\\u2713])?');\n            return new RegExp([\n                '(?:',\n                '(',\n                schemeRegex.source,\n                getDomainNameStr(2),\n                ')',\n                '|',\n                '(',\n                '(//)?',\n                wwwRegex.source,\n                getDomainNameStr(6),\n                ')',\n                '|',\n                '(',\n                '(//)?',\n                getDomainNameStr(10) + '\\\\.',\n                tldRegex.source,\n                '(?![-' + alphaNumericCharsStr + '])',\n                ')',\n                ')',\n                '(?::[0-9]+)?',\n                '(?:' + urlSuffixRegex.source + ')?' // match for path, query string, and/or hash anchor - optional\n            ].join(\"\"), 'gi');\n        })();\n        /**\n         * A regular expression to use to check the character before a protocol-relative\n         * URL match. We don't want to match a protocol-relative URL if it is part\n         * of another word.\n         *\n         * For example, we want to match something like \"Go to: //google.com\",\n         * but we don't want to match something like \"abc//google.com\"\n         *\n         * This regular expression is used to test the character before the '//'.\n         *\n         * @private\n         * @type {RegExp} wordCharRegExp\n         */\n        _this.wordCharRegExp = new RegExp('[' + alphaNumericCharsStr + ']');\n        /**\n         * The regular expression to match opening parenthesis in a URL match.\n         *\n         * This is to determine if we have unbalanced parenthesis in the URL, and to\n         * drop the final parenthesis that was matched if so.\n         *\n         * Ex: The text \"(check out: wikipedia.com/something_(disambiguation))\"\n         * should only autolink the inner \"wikipedia.com/something_(disambiguation)\"\n         * part, so if we find that we have unbalanced parenthesis, we will drop the\n         * last one for the match.\n         *\n         * @private\n         * @property {RegExp}\n         */\n        _this.openParensRe = /\\(/g;\n        /**\n         * The regular expression to match closing parenthesis in a URL match. See\n         * {@link #openParensRe} for more information.\n         *\n         * @private\n         * @property {RegExp}\n         */\n        _this.closeParensRe = /\\)/g;\n        _this.stripPrefix = cfg.stripPrefix;\n        _this.stripTrailingSlash = cfg.stripTrailingSlash;\n        _this.decodePercentEncoding = cfg.decodePercentEncoding;\n        return _this;\n    }\n    /**\n     * @inheritdoc\n     */\n    UrlMatcher.prototype.parseMatches = function (text) {\n        var matcherRegex = this.matcherRegex, stripPrefix = this.stripPrefix, stripTrailingSlash = this.stripTrailingSlash, decodePercentEncoding = this.decodePercentEncoding, tagBuilder = this.tagBuilder, matches = [], match;\n        while ((match = matcherRegex.exec(text)) !== null) {\n            var matchStr = match[0], schemeUrlMatch = match[1], wwwUrlMatch = match[4], wwwProtocolRelativeMatch = match[5], \n            //tldUrlMatch = match[ 8 ],  -- not needed at the moment\n            tldProtocolRelativeMatch = match[9], offset = match.index, protocolRelativeMatch = wwwProtocolRelativeMatch || tldProtocolRelativeMatch, prevChar = text.charAt(offset - 1);\n            if (!UrlMatchValidator.isValid(matchStr, schemeUrlMatch)) {\n                continue;\n            }\n            // If the match is preceded by an '@' character, then it is either\n            // an email address or a username. Skip these types of matches.\n            if (offset > 0 && prevChar === '@') {\n                continue;\n            }\n            // If it's a protocol-relative '//' match, but the character before the '//'\n            // was a word character (i.e. a letter/number), then we found the '//' in the\n            // middle of another word (such as \"asdf//asdf.com\"). In this case, skip the\n            // match.\n            if (offset > 0 && protocolRelativeMatch && this.wordCharRegExp.test(prevChar)) {\n                continue;\n            }\n            if (/\\?$/.test(matchStr)) {\n                matchStr = matchStr.substr(0, matchStr.length - 1);\n            }\n            // Handle a closing parenthesis at the end of the match, and exclude\n            // it if there is not a matching open parenthesis in the match\n            // itself.\n            if (this.matchHasUnbalancedClosingParen(matchStr)) {\n                matchStr = matchStr.substr(0, matchStr.length - 1); // remove the trailing \")\"\n            }\n            else {\n                // Handle an invalid character after the TLD\n                var pos = this.matchHasInvalidCharAfterTld(matchStr, schemeUrlMatch);\n                if (pos > -1) {\n                    matchStr = matchStr.substr(0, pos); // remove the trailing invalid chars\n                }\n            }\n            var urlMatchType = schemeUrlMatch ? 'scheme' : (wwwUrlMatch ? 'www' : 'tld'), protocolUrlMatch = !!schemeUrlMatch;\n            matches.push(new UrlMatch({\n                tagBuilder: tagBuilder,\n                matchedText: matchStr,\n                offset: offset,\n                urlMatchType: urlMatchType,\n                url: matchStr,\n                protocolUrlMatch: protocolUrlMatch,\n                protocolRelativeMatch: !!protocolRelativeMatch,\n                stripPrefix: stripPrefix,\n                stripTrailingSlash: stripTrailingSlash,\n                decodePercentEncoding: decodePercentEncoding,\n            }));\n        }\n        return matches;\n    };\n    /**\n     * Determines if a match found has an unmatched closing parenthesis. If so,\n     * this parenthesis will be removed from the match itself, and appended\n     * after the generated anchor tag.\n     *\n     * A match may have an extra closing parenthesis at the end of the match\n     * because the regular expression must include parenthesis for URLs such as\n     * \"wikipedia.com/something_(disambiguation)\", which should be auto-linked.\n     *\n     * However, an extra parenthesis *will* be included when the URL itself is\n     * wrapped in parenthesis, such as in the case of \"(wikipedia.com/something_(disambiguation))\".\n     * In this case, the last closing parenthesis should *not* be part of the\n     * URL itself, and this method will return `true`.\n     *\n     * @private\n     * @param {String} matchStr The full match string from the {@link #matcherRegex}.\n     * @return {Boolean} `true` if there is an unbalanced closing parenthesis at\n     *   the end of the `matchStr`, `false` otherwise.\n     */\n    UrlMatcher.prototype.matchHasUnbalancedClosingParen = function (matchStr) {\n        var lastChar = matchStr.charAt(matchStr.length - 1);\n        if (lastChar === ')') {\n            var openParensMatch = matchStr.match(this.openParensRe), closeParensMatch = matchStr.match(this.closeParensRe), numOpenParens = (openParensMatch && openParensMatch.length) || 0, numCloseParens = (closeParensMatch && closeParensMatch.length) || 0;\n            if (numOpenParens < numCloseParens) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * Determine if there's an invalid character after the TLD in a URL. Valid\n     * characters after TLD are ':/?#'. Exclude scheme matched URLs from this\n     * check.\n     *\n     * @private\n     * @param {String} urlMatch The matched URL, if there was one. Will be an\n     *   empty string if the match is not a URL match.\n     * @param {String} schemeUrlMatch The match URL string for a scheme\n     *   match. Ex: 'http://yahoo.com'. This is used to match something like\n     *   'http://localhost', where we won't double check that the domain name\n     *   has at least one '.' in it.\n     * @return {Number} the position where the invalid character was found. If\n     *   no such character was found, returns -1\n     */\n    UrlMatcher.prototype.matchHasInvalidCharAfterTld = function (urlMatch, schemeUrlMatch) {\n        if (!urlMatch) {\n            return -1;\n        }\n        var offset = 0;\n        if (schemeUrlMatch) {\n            offset = urlMatch.indexOf(':');\n            urlMatch = urlMatch.slice(offset);\n        }\n        var re = new RegExp(\"^((.?\\/\\/)?[-.\" + alphaNumericCharsStr + \"]*[-\" + alphaNumericCharsStr + \"]\\\\.[-\" + alphaNumericCharsStr + \"]+)\");\n        var res = re.exec(urlMatch);\n        if (res === null) {\n            return -1;\n        }\n        offset += res[1].length;\n        urlMatch = urlMatch.slice(res[1].length);\n        if (/^[^-.A-Za-z0-9:\\/?#]/.test(urlMatch)) {\n            return offset;\n        }\n        return -1;\n    };\n    return UrlMatcher;\n}(Matcher));\nexport { UrlMatcher };\n\n//# sourceMappingURL=url-matcher.js.map\n","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { Matcher } from \"./matcher\";\nimport { alphaNumericCharsStr } from \"../regex-lib\";\nimport { HashtagMatch } from \"../match/hashtag-match\";\n/**\n * @class Autolinker.matcher.Hashtag\n * @extends Autolinker.matcher.Matcher\n *\n * Matcher to find HashtagMatch matches in an input string.\n */\nvar HashtagMatcher = /** @class */ (function (_super) {\n    __extends(HashtagMatcher, _super);\n    /**\n     * @constructor\n     * @param {Object} cfg The configuration properties for the Match instance,\n     *   specified in an Object (map).\n     */\n    function HashtagMatcher(cfg) {\n        var _this = _super.call(this, cfg) || this;\n        /**\n         * The regular expression to match Hashtags. Example match:\n         *\n         *     #asdf\n         *\n         * @private\n         * @property {RegExp} matcherRegex\n         */\n        _this.matcherRegex = new RegExp('#[_' + alphaNumericCharsStr + ']{1,139}', 'g');\n        /**\n         * The regular expression to use to check the character before a username match to\n         * make sure we didn't accidentally match an email address.\n         *\n         * For example, the string \"asdf@asdf.com\" should not match \"@asdf\" as a username.\n         *\n         * @private\n         * @property {RegExp} nonWordCharRegex\n         */\n        _this.nonWordCharRegex = new RegExp('[^' + alphaNumericCharsStr + ']');\n        _this.serviceName = cfg.serviceName;\n        return _this;\n    }\n    /**\n     * @inheritdoc\n     */\n    HashtagMatcher.prototype.parseMatches = function (text) {\n        var matcherRegex = this.matcherRegex, nonWordCharRegex = this.nonWordCharRegex, serviceName = this.serviceName, tagBuilder = this.tagBuilder, matches = [], match;\n        while ((match = matcherRegex.exec(text)) !== null) {\n            var offset = match.index, prevChar = text.charAt(offset - 1);\n            // If we found the match at the beginning of the string, or we found the match\n            // and there is a whitespace char in front of it (meaning it is not a '#' char\n            // in the middle of a word), then it is a hashtag match.\n            if (offset === 0 || nonWordCharRegex.test(prevChar)) {\n                var matchedText = match[0], hashtag = match[0].slice(1); // strip off the '#' character at the beginning\n                matches.push(new HashtagMatch({\n                    tagBuilder: tagBuilder,\n                    matchedText: matchedText,\n                    offset: offset,\n                    serviceName: serviceName,\n                    hashtag: hashtag\n                }));\n            }\n        }\n        return matches;\n    };\n    return HashtagMatcher;\n}(Matcher));\nexport { HashtagMatcher };\n\n//# sourceMappingURL=hashtag-matcher.js.map\n","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { Matcher } from \"./matcher\";\nimport { PhoneMatch } from \"../match/phone-match\";\n/**\n * @class Autolinker.matcher.Phone\n * @extends Autolinker.matcher.Matcher\n *\n * Matcher to find Phone number matches in an input string.\n *\n * See this class's superclass ({@link Autolinker.matcher.Matcher}) for more\n * details.\n */\nvar PhoneMatcher = /** @class */ (function (_super) {\n    __extends(PhoneMatcher, _super);\n    function PhoneMatcher() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        /**\n         * The regular expression to match Phone numbers. Example match:\n         *\n         *     (123) 456-7890\n         *\n         * This regular expression has the following capturing groups:\n         *\n         * 1 or 2. The prefixed '+' sign, if there is one.\n         *\n         * @private\n         * @property {RegExp} matcherRegex\n         */\n        _this.matcherRegex = /(?:(?:(?:(\\+)?\\d{1,3}[-\\040.]?)?\\(?\\d{3}\\)?[-\\040.]?\\d{3}[-\\040.]?\\d{4})|(?:(\\+)(?:9[976]\\d|8[987530]\\d|6[987]\\d|5[90]\\d|42\\d|3[875]\\d|2[98654321]\\d|9[8543210]|8[6421]|6[6543210]|5[87654321]|4[987654310]|3[9643210]|2[70]|7|1)[-\\040.]?(?:\\d[-\\040.]?){6,12}\\d+))([,;]+[0-9]+#?)*/g;\n        return _this;\n    }\n    // ex: (123) 456-7890, 123 456 7890, 123-456-7890, +18004441234,,;,10226420346#,\n    // +1 (800) 444 1234, 10226420346#, 1-800-444-1234,1022,64,20346#\n    /**\n     * @inheritdoc\n     */\n    PhoneMatcher.prototype.parseMatches = function (text) {\n        var matcherRegex = this.matcherRegex, tagBuilder = this.tagBuilder, matches = [], match;\n        while ((match = matcherRegex.exec(text)) !== null) {\n            // Remove non-numeric values from phone number string\n            var matchedText = match[0], cleanNumber = matchedText.replace(/[^0-9,;#]/g, ''), // strip out non-digit characters exclude comma semicolon and #\n            plusSign = !!(match[1] || match[2]), // match[ 1 ] or match[ 2 ] is the prefixed plus sign, if there is one\n            before = match.index == 0 ? '' : text.substr(match.index - 1, 1), after = text.substr(match.index + matchedText.length, 1), contextClear = !before.match(/\\d/) && !after.match(/\\d/);\n            if (this.testMatch(match[3]) && this.testMatch(matchedText) && contextClear) {\n                matches.push(new PhoneMatch({\n                    tagBuilder: tagBuilder,\n                    matchedText: matchedText,\n                    offset: match.index,\n                    number: cleanNumber,\n                    plusSign: plusSign\n                }));\n            }\n        }\n        return matches;\n    };\n    PhoneMatcher.prototype.testMatch = function (text) {\n        return /\\D/.test(text);\n    };\n    return PhoneMatcher;\n}(Matcher));\nexport { PhoneMatcher };\n\n//# sourceMappingURL=phone-matcher.js.map\n","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { Matcher } from \"./matcher\";\nimport { alphaNumericCharsStr } from \"../regex-lib\";\nimport { MentionMatch } from \"../match/mention-match\";\n/**\n * @class Autolinker.matcher.Mention\n * @extends Autolinker.matcher.Matcher\n *\n * Matcher to find/replace username matches in an input string.\n */\nvar MentionMatcher = /** @class */ (function (_super) {\n    __extends(MentionMatcher, _super);\n    /**\n     * @constructor\n     * @param {Object} cfg The configuration properties for the Match instance,\n     *   specified in an Object (map).\n     */\n    function MentionMatcher(cfg) {\n        var _this = _super.call(this, cfg) || this;\n        /**\n         * Hash of regular expression to match username handles. Example match:\n         *\n         *     @asdf\n         *\n         * @private\n         * @property {Object} matcherRegexes\n         */\n        _this.matcherRegexes = {\n            'twitter': new RegExp('@[_' + alphaNumericCharsStr + ']{1,20}', 'g'),\n            'instagram': new RegExp('@[_.' + alphaNumericCharsStr + ']{1,50}', 'g'),\n            'soundcloud': new RegExp('@[_.' + alphaNumericCharsStr + \"\\-\" + ']{1,50}', 'g')\n        };\n        /**\n         * The regular expression to use to check the character before a username match to\n         * make sure we didn't accidentally match an email address.\n         *\n         * For example, the string \"asdf@asdf.com\" should not match \"@asdf\" as a username.\n         *\n         * @private\n         * @property {RegExp} nonWordCharRegex\n         */\n        _this.nonWordCharRegex = new RegExp('[^' + alphaNumericCharsStr + ']');\n        _this.serviceName = cfg.serviceName;\n        return _this;\n    }\n    /**\n     * @inheritdoc\n     */\n    MentionMatcher.prototype.parseMatches = function (text) {\n        var serviceName = this.serviceName, matcherRegex = this.matcherRegexes[this.serviceName], nonWordCharRegex = this.nonWordCharRegex, tagBuilder = this.tagBuilder, matches = [], match;\n        if (!matcherRegex) {\n            return matches;\n        }\n        while ((match = matcherRegex.exec(text)) !== null) {\n            var offset = match.index, prevChar = text.charAt(offset - 1);\n            // If we found the match at the beginning of the string, or we found the match\n            // and there is a whitespace char in front of it (meaning it is not an email\n            // address), then it is a username match.\n            if (offset === 0 || nonWordCharRegex.test(prevChar)) {\n                var matchedText = match[0].replace(/\\.+$/g, ''), // strip off trailing .\n                mention = matchedText.slice(1); // strip off the '@' character at the beginning\n                matches.push(new MentionMatch({\n                    tagBuilder: tagBuilder,\n                    matchedText: matchedText,\n                    offset: offset,\n                    serviceName: serviceName,\n                    mention: mention\n                }));\n            }\n        }\n        return matches;\n    };\n    return MentionMatcher;\n}(Matcher));\nexport { MentionMatcher };\n\n//# sourceMappingURL=mention-matcher.js.map\n","import { defaults, remove } from \"./utils\";\nimport { AnchorTagBuilder } from \"./anchor-tag-builder\";\nimport { HtmlParser } from \"./htmlParser/html-parser\";\nimport { Match } from \"./match/match\";\nimport { EmailMatch } from \"./match/email-match\";\nimport { HashtagMatch } from \"./match/hashtag-match\";\nimport { MentionMatch } from \"./match/mention-match\";\nimport { PhoneMatch } from \"./match/phone-match\";\nimport { UrlMatch } from \"./match/url-match\";\nimport { Matcher } from \"./matcher/matcher\";\nimport { HtmlTag } from \"./html-tag\";\nimport { EmailMatcher } from \"./matcher/email-matcher\";\nimport { UrlMatcher } from \"./matcher/url-matcher\";\nimport { HashtagMatcher } from \"./matcher/hashtag-matcher\";\nimport { PhoneMatcher } from \"./matcher/phone-matcher\";\nimport { MentionMatcher } from \"./matcher/mention-matcher\";\n/**\n * @class Autolinker\n * @extends Object\n *\n * Utility class used to process a given string of text, and wrap the matches in\n * the appropriate anchor (&lt;a&gt;) tags to turn them into links.\n *\n * Any of the configuration options may be provided in an Object (map) provided\n * to the Autolinker constructor, which will configure how the {@link #link link()}\n * method will process the links.\n *\n * For example:\n *\n *     var autolinker = new Autolinker( {\n *         newWindow : false,\n *         truncate  : 30\n *     } );\n *\n *     var html = autolinker.link( \"Joe went to www.yahoo.com\" );\n *     // produces: 'Joe went to <a href=\"http://www.yahoo.com\">yahoo.com</a>'\n *\n *\n * The {@link #static-link static link()} method may also be used to inline\n * options into a single call, which may be more convenient for one-off uses.\n * For example:\n *\n *     var html = Autolinker.link( \"Joe went to www.yahoo.com\", {\n *         newWindow : false,\n *         truncate  : 30\n *     } );\n *     // produces: 'Joe went to <a href=\"http://www.yahoo.com\">yahoo.com</a>'\n *\n *\n * ## Custom Replacements of Links\n *\n * If the configuration options do not provide enough flexibility, a {@link #replaceFn}\n * may be provided to fully customize the output of Autolinker. This function is\n * called once for each URL/Email/Phone#/Hashtag/Mention (Twitter, Instagram, Soundcloud)\n * match that is encountered.\n *\n * For example:\n *\n *     var input = \"...\";  // string with URLs, Email Addresses, Phone #s, Hashtags, and Mentions (Twitter, Instagram, Soundcloud)\n *\n *     var linkedText = Autolinker.link( input, {\n *         replaceFn : function( match ) {\n *             console.log( \"href = \", match.getAnchorHref() );\n *             console.log( \"text = \", match.getAnchorText() );\n *\n *             switch( match.getType() ) {\n *                 case 'url' :\n *                     console.log( \"url: \", match.getUrl() );\n *\n *                     if( match.getUrl().indexOf( 'mysite.com' ) === -1 ) {\n *                         var tag = match.buildTag();  // returns an `Autolinker.HtmlTag` instance, which provides mutator methods for easy changes\n *                         tag.setAttr( 'rel', 'nofollow' );\n *                         tag.addClass( 'external-link' );\n *\n *                         return tag;\n *\n *                     } else {\n *                         return true;  // let Autolinker perform its normal anchor tag replacement\n *                     }\n *\n *                 case 'email' :\n *                     var email = match.getEmail();\n *                     console.log( \"email: \", email );\n *\n *                     if( email === \"my@own.address\" ) {\n *                         return false;  // don't auto-link this particular email address; leave as-is\n *                     } else {\n *                         return;  // no return value will have Autolinker perform its normal anchor tag replacement (same as returning `true`)\n *                     }\n *\n *                 case 'phone' :\n *                     var phoneNumber = match.getPhoneNumber();\n *                     console.log( phoneNumber );\n *\n *                     return '<a href=\"http://newplace.to.link.phone.numbers.to/\">' + phoneNumber + '</a>';\n *\n *                 case 'hashtag' :\n *                     var hashtag = match.getHashtag();\n *                     console.log( hashtag );\n *\n *                     return '<a href=\"http://newplace.to.link.hashtag.handles.to/\">' + hashtag + '</a>';\n *\n *                 case 'mention' :\n *                     var mention = match.getMention();\n *                     console.log( mention );\n *\n *                     return '<a href=\"http://newplace.to.link.mention.to/\">' + mention + '</a>';\n *             }\n *         }\n *     } );\n *\n *\n * The function may return the following values:\n *\n * - `true` (Boolean): Allow Autolinker to replace the match as it normally\n *   would.\n * - `false` (Boolean): Do not replace the current match at all - leave as-is.\n * - Any String: If a string is returned from the function, the string will be\n *   used directly as the replacement HTML for the match.\n * - An {@link Autolinker.HtmlTag} instance, which can be used to build/modify\n *   an HTML tag before writing out its HTML text.\n *\n * @constructor\n * @param {Object} [cfg] The configuration options for the Autolinker instance,\n *   specified in an Object (map).\n */\nvar Autolinker = /** @class */ (function () {\n    function Autolinker(cfg) {\n        if (cfg === void 0) { cfg = {}; }\n        /**\n         * The Autolinker version number exposed on the instance itself.\n         *\n         * Ex: 0.25.1\n         */\n        this.version = Autolinker.version;\n        this.urls = this.normalizeUrlsCfg(cfg.urls);\n        this.email = typeof cfg.email === 'boolean' ? cfg.email : true;\n        this.phone = typeof cfg.phone === 'boolean' ? cfg.phone : true;\n        this.hashtag = cfg.hashtag || false;\n        this.mention = cfg.mention || false;\n        this.newWindow = typeof cfg.newWindow === 'boolean' ? cfg.newWindow : true;\n        this.stripPrefix = this.normalizeStripPrefixCfg(cfg.stripPrefix);\n        this.stripTrailingSlash = typeof cfg.stripTrailingSlash === 'boolean' ? cfg.stripTrailingSlash : true;\n        this.decodePercentEncoding = typeof cfg.decodePercentEncoding === 'boolean' ? cfg.decodePercentEncoding : true;\n        // Validate the value of the `mention` cfg\n        var mention = this.mention;\n        if (mention !== false && mention !== 'twitter' && mention !== 'instagram') {\n            throw new Error(\"invalid `mention` cfg - see docs\");\n        }\n        // Validate the value of the `hashtag` cfg\n        var hashtag = this.hashtag;\n        if (hashtag !== false && hashtag !== 'twitter' && hashtag !== 'facebook' && hashtag !== 'instagram') {\n            throw new Error(\"invalid `hashtag` cfg - see docs\");\n        }\n        this.truncate = this.normalizeTruncateCfg(cfg.truncate);\n        this.className = cfg.className || '';\n        this.replaceFn = cfg.replaceFn || null;\n        this.context = cfg.context || this;\n        this.htmlParser = new HtmlParser();\n        this.matchers = null;\n        this.tagBuilder = null;\n    }\n    /**\n     * Automatically links URLs, Email addresses, Phone Numbers, Twitter handles,\n     * Hashtags, and Mentions found in the given chunk of HTML. Does not link URLs\n     * found within HTML tags.\n     *\n     * For instance, if given the text: `You should go to http://www.yahoo.com`,\n     * then the result will be `You should go to &lt;a href=\"http://www.yahoo.com\"&gt;http://www.yahoo.com&lt;/a&gt;`\n     *\n     * Example:\n     *\n     *     var linkedText = Autolinker.link( \"Go to google.com\", { newWindow: false } );\n     *     // Produces: \"Go to <a href=\"http://google.com\">google.com</a>\"\n     *\n     * @static\n     * @param {String} textOrHtml The HTML or text to find matches within (depending\n     *   on if the {@link #urls}, {@link #email}, {@link #phone}, {@link #mention},\n     *   {@link #hashtag}, and {@link #mention} options are enabled).\n     * @param {Object} [options] Any of the configuration options for the Autolinker\n     *   class, specified in an Object (map). See the class description for an\n     *   example call.\n     * @return {String} The HTML text, with matches automatically linked.\n     */\n    Autolinker.link = function (textOrHtml, options) {\n        var autolinker = new Autolinker(options);\n        return autolinker.link(textOrHtml);\n    };\n    /**\n     * Parses the input `textOrHtml` looking for URLs, email addresses, phone\n     * numbers, username handles, and hashtags (depending on the configuration\n     * of the Autolinker instance), and returns an array of {@link Autolinker.match.Match}\n     * objects describing those matches (without making any replacements).\n     *\n     * Note that if parsing multiple pieces of text, it is slightly more efficient\n     * to create an Autolinker instance, and use the instance-level {@link #parse}\n     * method.\n     *\n     * Example:\n     *\n     *     var matches = Autolinker.parse( \"Hello google.com, I am asdf@asdf.com\", {\n     *         urls: true,\n     *         email: true\n     *     } );\n     *\n     *     console.log( matches.length );           // 2\n     *     console.log( matches[ 0 ].getType() );   // 'url'\n     *     console.log( matches[ 0 ].getUrl() );    // 'google.com'\n     *     console.log( matches[ 1 ].getType() );   // 'email'\n     *     console.log( matches[ 1 ].getEmail() );  // 'asdf@asdf.com'\n     *\n     * @static\n     * @param {String} textOrHtml The HTML or text to find matches within\n     *   (depending on if the {@link #urls}, {@link #email}, {@link #phone},\n     *   {@link #hashtag}, and {@link #mention} options are enabled).\n     * @param {Object} [options] Any of the configuration options for the Autolinker\n     *   class, specified in an Object (map). See the class description for an\n     *   example call.\n     * @return {Autolinker.match.Match[]} The array of Matches found in the\n     *   given input `textOrHtml`.\n     */\n    Autolinker.parse = function (textOrHtml, options) {\n        var autolinker = new Autolinker(options);\n        return autolinker.parse(textOrHtml);\n    };\n    /**\n     * Normalizes the {@link #urls} config into an Object with 3 properties:\n     * `schemeMatches`, `wwwMatches`, and `tldMatches`, all Booleans.\n     *\n     * See {@link #urls} config for details.\n     *\n     * @param {Boolean/Object} urls\n     * @return {Object}\n     */\n    Autolinker.prototype.normalizeUrlsCfg = function (urls) {\n        if (urls == null)\n            urls = true; // default to `true`\n        if (typeof urls === 'boolean') {\n            return { schemeMatches: urls, wwwMatches: urls, tldMatches: urls };\n        }\n        else { // object form\n            return {\n                schemeMatches: typeof urls.schemeMatches === 'boolean' ? urls.schemeMatches : true,\n                wwwMatches: typeof urls.wwwMatches === 'boolean' ? urls.wwwMatches : true,\n                tldMatches: typeof urls.tldMatches === 'boolean' ? urls.tldMatches : true\n            };\n        }\n    };\n    /**\n     * Normalizes the {@link #stripPrefix} config into an Object with 2\n     * properties: `scheme`, and `www` - both Booleans.\n     *\n     * See {@link #stripPrefix} config for details.\n     *\n     * @private\n     * @param {Boolean/Object} stripPrefix\n     * @return {Object}\n     */\n    Autolinker.prototype.normalizeStripPrefixCfg = function (stripPrefix) {\n        if (stripPrefix == null)\n            stripPrefix = true; // default to `true`\n        if (typeof stripPrefix === 'boolean') {\n            return { scheme: stripPrefix, www: stripPrefix };\n        }\n        else { // object form\n            return {\n                scheme: typeof stripPrefix.scheme === 'boolean' ? stripPrefix.scheme : true,\n                www: typeof stripPrefix.www === 'boolean' ? stripPrefix.www : true\n            };\n        }\n    };\n    /**\n     * Normalizes the {@link #truncate} config into an Object with 2 properties:\n     * `length` (Number), and `location` (String).\n     *\n     * See {@link #truncate} config for details.\n     *\n     * @private\n     * @param {Number/Object} truncate\n     * @return {Object}\n     */\n    Autolinker.prototype.normalizeTruncateCfg = function (truncate) {\n        if (typeof truncate === 'number') {\n            return { length: truncate, location: 'end' };\n        }\n        else { // object, or undefined/null\n            return defaults(truncate || {}, {\n                length: Number.POSITIVE_INFINITY,\n                location: 'end'\n            });\n        }\n    };\n    /**\n     * Parses the input `textOrHtml` looking for URLs, email addresses, phone\n     * numbers, username handles, and hashtags (depending on the configuration\n     * of the Autolinker instance), and returns an array of {@link Autolinker.match.Match}\n     * objects describing those matches (without making any replacements).\n     *\n     * This method is used by the {@link #link} method, but can also be used to\n     * simply do parsing of the input in order to discover what kinds of links\n     * there are and how many.\n     *\n     * Example usage:\n     *\n     *     var autolinker = new Autolinker( {\n     *         urls: true,\n     *         email: true\n     *     } );\n     *\n     *     var matches = autolinker.parse( \"Hello google.com, I am asdf@asdf.com\" );\n     *\n     *     console.log( matches.length );           // 2\n     *     console.log( matches[ 0 ].getType() );   // 'url'\n     *     console.log( matches[ 0 ].getUrl() );    // 'google.com'\n     *     console.log( matches[ 1 ].getType() );   // 'email'\n     *     console.log( matches[ 1 ].getEmail() );  // 'asdf@asdf.com'\n     *\n     * @param {String} textOrHtml The HTML or text to find matches within\n     *   (depending on if the {@link #urls}, {@link #email}, {@link #phone},\n     *   {@link #hashtag}, and {@link #mention} options are enabled).\n     * @return {Autolinker.match.Match[]} The array of Matches found in the\n     *   given input `textOrHtml`.\n     */\n    Autolinker.prototype.parse = function (textOrHtml) {\n        var htmlNodes = this.htmlParser.parse(textOrHtml), anchorTagStackCount = 0, // used to only process text around anchor tags, and any inner text/html they may have;\n        matches = [];\n        // Find all matches within the `textOrHtml` (but not matches that are\n        // already nested within <a>, <style> and <script> tags)\n        for (var i = 0, len = htmlNodes.length; i < len; i++) {\n            var node = htmlNodes[i], nodeType = node.getType();\n            if (nodeType === 'element' && ['a', 'style', 'script'].indexOf(node.getTagName()) !== -1) { // Process HTML anchor, style and script element nodes in the input `textOrHtml` to find out when we're within an <a>, <style> or <script> tag\n                if (!node.isClosing()) { // it's the start <a>, <style> or <script> tag\n                    anchorTagStackCount++;\n                }\n                else { // it's the end </a>, </style> or </script> tag\n                    anchorTagStackCount = Math.max(anchorTagStackCount - 1, 0); // attempt to handle extraneous </a> tags by making sure the stack count never goes below 0\n                }\n            }\n            else if (nodeType === 'text' && anchorTagStackCount === 0) { // Process text nodes that are not within an <a>, <style> and <script> tag\n                var textNodeMatches = this.parseText(node.getText(), node.getOffset());\n                matches.push.apply(matches, textNodeMatches);\n            }\n        }\n        // After we have found all matches, remove subsequent matches that\n        // overlap with a previous match. This can happen for instance with URLs,\n        // where the url 'google.com/#link' would match '#link' as a hashtag.\n        matches = this.compactMatches(matches);\n        // And finally, remove matches for match types that have been turned\n        // off. We needed to have all match types turned on initially so that\n        // things like hashtags could be filtered out if they were really just\n        // part of a URL match (for instance, as a named anchor).\n        matches = this.removeUnwantedMatches(matches);\n        return matches;\n    };\n    /**\n     * After we have found all matches, we need to remove matches that overlap\n     * with a previous match. This can happen for instance with URLs, where the\n     * url 'google.com/#link' would match '#link' as a hashtag. Because the\n     * '#link' part is contained in a larger match that comes before the HashTag\n     * match, we'll remove the HashTag match.\n     *\n     * @private\n     * @param {Autolinker.match.Match[]} matches\n     * @return {Autolinker.match.Match[]}\n     */\n    Autolinker.prototype.compactMatches = function (matches) {\n        // First, the matches need to be sorted in order of offset\n        matches.sort(function (a, b) { return a.getOffset() - b.getOffset(); });\n        for (var i = 0; i < matches.length - 1; i++) {\n            var match = matches[i], offset = match.getOffset(), matchedTextLength = match.getMatchedText().length, endIdx = offset + matchedTextLength;\n            if (i + 1 < matches.length) {\n                // Remove subsequent matches that equal offset with current match\n                if (matches[i + 1].getOffset() === offset) {\n                    var removeIdx = matches[i + 1].getMatchedText().length > matchedTextLength ? i : i + 1;\n                    matches.splice(removeIdx, 1);\n                    continue;\n                }\n                // Remove subsequent matches that overlap with the current match\n                if (matches[i + 1].getOffset() < endIdx) {\n                    matches.splice(i + 1, 1);\n                }\n            }\n        }\n        return matches;\n    };\n    /**\n     * Removes matches for matchers that were turned off in the options. For\n     * example, if {@link #hashtag hashtags} were not to be matched, we'll\n     * remove them from the `matches` array here.\n     *\n     * Note: we *must* use all Matchers on the input string, and then filter\n     * them out later. For example, if the options were `{ url: false, hashtag: true }`,\n     * we wouldn't want to match the text '#link' as a HashTag inside of the text\n     * 'google.com/#link'. The way the algorithm works is that we match the full\n     * URL first (which prevents the accidental HashTag match), and then we'll\n     * simply throw away the URL match.\n     *\n     * @private\n     * @param {Autolinker.match.Match[]} matches The array of matches to remove\n     *   the unwanted matches from. Note: this array is mutated for the\n     *   removals.\n     * @return {Autolinker.match.Match[]} The mutated input `matches` array.\n     */\n    Autolinker.prototype.removeUnwantedMatches = function (matches) {\n        if (!this.hashtag)\n            remove(matches, function (match) { return match.getType() === 'hashtag'; });\n        if (!this.email)\n            remove(matches, function (match) { return match.getType() === 'email'; });\n        if (!this.phone)\n            remove(matches, function (match) { return match.getType() === 'phone'; });\n        if (!this.mention)\n            remove(matches, function (match) { return match.getType() === 'mention'; });\n        if (!this.urls.schemeMatches) {\n            remove(matches, function (m) { return m.getType() === 'url' && m.getUrlMatchType() === 'scheme'; });\n        }\n        if (!this.urls.wwwMatches) {\n            remove(matches, function (m) { return m.getType() === 'url' && m.getUrlMatchType() === 'www'; });\n        }\n        if (!this.urls.tldMatches) {\n            remove(matches, function (m) { return m.getType() === 'url' && m.getUrlMatchType() === 'tld'; });\n        }\n        return matches;\n    };\n    /**\n     * Parses the input `text` looking for URLs, email addresses, phone\n     * numbers, username handles, and hashtags (depending on the configuration\n     * of the Autolinker instance), and returns an array of {@link Autolinker.match.Match}\n     * objects describing those matches.\n     *\n     * This method processes a **non-HTML string**, and is used to parse and\n     * match within the text nodes of an HTML string. This method is used\n     * internally by {@link #parse}.\n     *\n     * @private\n     * @param {String} text The text to find matches within (depending on if the\n     *   {@link #urls}, {@link #email}, {@link #phone},\n     *   {@link #hashtag}, and {@link #mention} options are enabled). This must be a non-HTML string.\n     * @param {Number} [offset=0] The offset of the text node within the\n     *   original string. This is used when parsing with the {@link #parse}\n     *   method to generate correct offsets within the {@link Autolinker.match.Match}\n     *   instances, but may be omitted if calling this method publicly.\n     * @return {Autolinker.match.Match[]} The array of Matches found in the\n     *   given input `text`.\n     */\n    Autolinker.prototype.parseText = function (text, offset) {\n        if (offset === void 0) { offset = 0; }\n        offset = offset || 0;\n        var matchers = this.getMatchers(), matches = [];\n        for (var i = 0, numMatchers = matchers.length; i < numMatchers; i++) {\n            var textMatches = matchers[i].parseMatches(text);\n            // Correct the offset of each of the matches. They are originally\n            // the offset of the match within the provided text node, but we\n            // need to correct them to be relative to the original HTML input\n            // string (i.e. the one provided to #parse).\n            for (var j = 0, numTextMatches = textMatches.length; j < numTextMatches; j++) {\n                textMatches[j].setOffset(offset + textMatches[j].getOffset());\n            }\n            matches.push.apply(matches, textMatches);\n        }\n        return matches;\n    };\n    /**\n     * Automatically links URLs, Email addresses, Phone numbers, Hashtags,\n     * and Mentions (Twitter, Instagram, Soundcloud) found in the given chunk of HTML. Does not link\n     * URLs found within HTML tags.\n     *\n     * For instance, if given the text: `You should go to http://www.yahoo.com`,\n     * then the result will be `You should go to\n     * &lt;a href=\"http://www.yahoo.com\"&gt;http://www.yahoo.com&lt;/a&gt;`\n     *\n     * This method finds the text around any HTML elements in the input\n     * `textOrHtml`, which will be the text that is processed. Any original HTML\n     * elements will be left as-is, as well as the text that is already wrapped\n     * in anchor (&lt;a&gt;) tags.\n     *\n     * @param {String} textOrHtml The HTML or text to autolink matches within\n     *   (depending on if the {@link #urls}, {@link #email}, {@link #phone}, {@link #hashtag}, and {@link #mention} options are enabled).\n     * @return {String} The HTML, with matches automatically linked.\n     */\n    Autolinker.prototype.link = function (textOrHtml) {\n        if (!textOrHtml) {\n            return \"\";\n        } // handle `null` and `undefined`\n        var matches = this.parse(textOrHtml), newHtml = [], lastIndex = 0;\n        for (var i = 0, len = matches.length; i < len; i++) {\n            var match = matches[i];\n            newHtml.push(textOrHtml.substring(lastIndex, match.getOffset()));\n            newHtml.push(this.createMatchReturnVal(match));\n            lastIndex = match.getOffset() + match.getMatchedText().length;\n        }\n        newHtml.push(textOrHtml.substring(lastIndex)); // handle the text after the last match\n        return newHtml.join('');\n    };\n    /**\n     * Creates the return string value for a given match in the input string.\n     *\n     * This method handles the {@link #replaceFn}, if one was provided.\n     *\n     * @private\n     * @param {Autolinker.match.Match} match The Match object that represents\n     *   the match.\n     * @return {String} The string that the `match` should be replaced with.\n     *   This is usually the anchor tag string, but may be the `matchStr` itself\n     *   if the match is not to be replaced.\n     */\n    Autolinker.prototype.createMatchReturnVal = function (match) {\n        // Handle a custom `replaceFn` being provided\n        var replaceFnResult;\n        if (this.replaceFn) {\n            replaceFnResult = this.replaceFn.call(this.context, match); // Autolinker instance is the context\n        }\n        if (typeof replaceFnResult === 'string') {\n            return replaceFnResult; // `replaceFn` returned a string, use that\n        }\n        else if (replaceFnResult === false) {\n            return match.getMatchedText(); // no replacement for the match\n        }\n        else if (replaceFnResult instanceof HtmlTag) {\n            return replaceFnResult.toAnchorString();\n        }\n        else { // replaceFnResult === true, or no/unknown return value from function\n            // Perform Autolinker's default anchor tag generation\n            var anchorTag = match.buildTag(); // returns an Autolinker.HtmlTag instance\n            return anchorTag.toAnchorString();\n        }\n    };\n    /**\n     * Lazily instantiates and returns the {@link Autolinker.matcher.Matcher}\n     * instances for this Autolinker instance.\n     *\n     * @protected\n     * @return {Autolinker.matcher.Matcher[]}\n     */\n    Autolinker.prototype.getMatchers = function () {\n        if (!this.matchers) {\n            var tagBuilder = this.getTagBuilder();\n            var matchers = [\n                new HashtagMatcher({ tagBuilder: tagBuilder, serviceName: this.hashtag }),\n                new EmailMatcher({ tagBuilder: tagBuilder }),\n                new PhoneMatcher({ tagBuilder: tagBuilder }),\n                new MentionMatcher({ tagBuilder: tagBuilder, serviceName: this.mention }),\n                new UrlMatcher({ tagBuilder: tagBuilder, stripPrefix: this.stripPrefix, stripTrailingSlash: this.stripTrailingSlash, decodePercentEncoding: this.decodePercentEncoding })\n            ];\n            return (this.matchers = matchers);\n        }\n        else {\n            return this.matchers;\n        }\n    };\n    /**\n     * Returns the {@link #tagBuilder} instance for this Autolinker instance, lazily instantiating it\n     * if it does not yet exist.\n     *\n     * This method may be used in a {@link #replaceFn} to generate the {@link Autolinker.HtmlTag HtmlTag} instance that\n     * Autolinker would normally generate, and then allow for modifications before returning it. For example:\n     *\n     *     var html = Autolinker.link( \"Test google.com\", {\n     *         replaceFn : function( match ) {\n     *             var tag = match.buildTag();  // returns an {@link Autolinker.HtmlTag} instance\n     *             tag.setAttr( 'rel', 'nofollow' );\n     *\n     *             return tag;\n     *         }\n     *     } );\n     *\n     *     // generated html:\n     *     //   Test <a href=\"http://google.com\" target=\"_blank\" rel=\"nofollow\">google.com</a>\n     *\n     * @return {Autolinker.AnchorTagBuilder}\n     */\n    Autolinker.prototype.getTagBuilder = function () {\n        var tagBuilder = this.tagBuilder;\n        if (!tagBuilder) {\n            tagBuilder = this.tagBuilder = new AnchorTagBuilder({\n                newWindow: this.newWindow,\n                truncate: this.truncate,\n                className: this.className\n            });\n        }\n        return tagBuilder;\n    };\n    /**\n     * The Autolinker version number in the form major.minor.patch\n     *\n     * Ex: 0.25.1\n     */\n    Autolinker.version = '1.8.3';\n    /**\n     * For backwards compatibility with Autolinker 1.x, the AnchorTagBuilder\n     * class is provided as a static on the Autolinker class.\n     */\n    Autolinker.AnchorTagBuilder = AnchorTagBuilder;\n    /**\n     * For backwards compatibility with Autolinker 1.x, the HtmlTag class is\n     * provided as a static on the Autolinker class.\n     */\n    Autolinker.HtmlTag = HtmlTag;\n    /**\n     * For backwards compatibility with Autolinker 1.x, the Matcher classes are\n     * provided as statics on the Autolinker class.\n     */\n    Autolinker.matcher = {\n        Email: EmailMatcher,\n        Hashtag: HashtagMatcher,\n        Matcher: Matcher,\n        Mention: MentionMatcher,\n        Phone: PhoneMatcher,\n        Url: UrlMatcher\n    };\n    /**\n     * For backwards compatibility with Autolinker 1.x, the Match classes are\n     * provided as statics on the Autolinker class.\n     */\n    Autolinker.match = {\n        Email: EmailMatch,\n        Hashtag: HashtagMatch,\n        Match: Match,\n        Mention: MentionMatch,\n        Phone: PhoneMatch,\n        Url: UrlMatch\n    };\n    return Autolinker;\n}());\nexport default Autolinker;\n\n//# sourceMappingURL=autolinker.js.map\n"]}